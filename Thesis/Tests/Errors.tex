% !TEX root = ../Thesis.tex

\subsection{Error messages}
\label{tests:errors}
The proof of the pudding is in the eating, and therefore, our error message qualification definition from \autoref{analysis:errors} is applied to the new parser.
All erroneous syntax statements recorded during the analysis phase are fed to the new parser to draw up the error message quality overview of the new parser.

The results are placed in \autoref{tab:error-messages-results} next to the results of the old parser as a reference point.
The actual error list, containing the syntax statements with the corresponding error messages, is available in the \hyperref[app:docs]{project documentation (appendix)}.

\begin{table}[h]
  \centering\small
	\begin{tabular}{|l|lr|lr|}\hline
		\rowcolor[HTML]{DDDDDD}
    \textbf{Error quality}  & \multicolumn{2}{|c|}{\textbf{Old parser}} & \multicolumn{2}{|c|}{\textbf{New parser}} \\\hline\hline
		Good           & 19          & 22,35\%          & 70          & 82,35\%          \\\hline
		Acceptable        & 48          & 56,47\%          & 14          & 16,47\%          \\\hline
		Bad            & 18          & 21,18\%          & 1           &  1,18\%          \\\hline
		\rowcolor[HTML]{DDDDDD}\hline\hline
		\textbf{Total} & \textbf{85} & \textbf{100\%} & \textbf{85} & \textbf{100\%} \\\hline
	\end{tabular}
  \caption{Error message comparison results}
  \label{tab:error-messages-results}
\end{table}

The table clearly visualizes that there indeed was an issue with the error messages generated by the old Ampersand parser.
By implementing the new parser, a substantial improvement is made towards the creation of good error messages in which 82\% of the generated error messages are good, compared to 22\% in the old parser.

One bad error message remains in the system.
After analysis, the resolution of this remaining bad error would require too much effort, hence increased complexity, compared to the actual value gain.
The error in question is given when the \code{Meta} statement is used with only one string value. 
Given the simple structure of the notation, we assume that the reference to the line number of the \code{Meta} is sufficient although the error message is unclear.
Therefore, this message is kept as is.

A typical example of an error message improvement is presented below.

The following syntax error is reported as an error by both the old and the new parser:
\begin{adl}
   CONTEXT DeliverySimple INCLUDE 0FILEPATH IN ENGLISH
\end{adl}
%TODO: Check why the above sentence is printing half blue and half black

The main issue in the example is that the requirement engineer misplaced the language reference as this had to be mentioned before the include statement.
Another minor error is that the include statement should be a quoted string.
This error is indicated by the new parser in the following way:
\begin{error}
   "ArchitectureAndDesign/Syntax/testfile_mba.adl" (line 1, column 24):
   unexpected Keyword "INCLUDE"
   expecting Keyword "IN"
\end{error}

This error message is concise, and provides a good indication of the error position and the expected input.
The old parser reported the same syntax error in a very elaborated and indistinct way:
\begin{error}
   Error(s) found:

   before "0" at line 1, column 32 of file "testfile_mba.adl"
   Expecting string ""
   Try deleting symbol "0" at line 1, column 32 of file "testfile_mba.adl"

   ==============================

   before upper case identifier FILEPATH at line 1, column 33 of file "testfile_mba.adl"
   Expecting string ""
   Try inserting symbol string ""

   ==============================

   before upper case identifier FILEPATH at line 1, column 33 of file "testfile_mba.adl"
   Expecting lower case identifier ?lc? or "CLASSIFY" or "CONCEPT" or "ENDCONTEXT" or "IDENT" or "INCLUDE" or "INTERFACE" or "KEY" or "META" or "PATTERN" or "PHPPL UG" or "POPULATION" or "PROCESS" or "PURPOSE" or "RELATION" or "RULE" or "SPEC" or "SQLPLUG" or "THEMES" or "VIEW"
   Try inserting symbol "PURPOSE"

   ==============================

   before upper case identifier FILEPATH at line 1, column 33 of file "testfile_mba.adl"
   Expecting "CONCEPT" or "CONTEXT" or "IDENT" or "INTERFACE" or "PATTERN" or "PROCESS" or "RELATION" or "RULE" or "VIEW"
   Try inserting symbol "CONCEPT"

   ==============================

   before lower case identifier clientName at line 14, column 1 of file "testfile_mba.adl"
   Expecting "HTML" or "LATEX" or "MARKDOWN" or "REF" or "REST" or explanation {+-}

   Try inserting symbol explanation {+-}
\end{error}

\noindent
General remarks and highlights:
 \begin{itemize}
	\item 	If the error qualification was defined in a less strict way, the numbers would be slightly different as some bad errors would be judged as being acceptable. 
		In the comparison between the old and new parser, the exact same qualification method is used while the syntax issue was, as well, identical.
		Due to this approach, we can conclude that the achieved results are justified.
	\item 	Error positioning was already correct in the old Ampersand parser; this is maintained in the new parser.
	\item 	The principle of Parsec to end parsing after the first error is found to have a massive improvement on the bad error messages due the conciseness issues.
		Nearly 50\% of the acceptable and bad messages changed to good error messages just due to this principle.
	\item 	Some error messages were extremely elaborated due to which the standard Windows command prompt was unable to fully show the error message.
\end {itemize}

To provide a better insight in the full list of the old and new error messages, together with the error qualification is provided in the \hyperref[app:docs]{project documentation (appendix)}.

Based on the defined error qualification method, we can clearly conclude that the implementation of the new Ampersand parser has a very positive effect on the error messages quality.
The percentage of good errors is now on an acceptable level and the remaining errors are, except for one, of acceptable quality, while still giving valuable information that can be used for error resolution.

To avoid the risk of additional complexity in the parser code, thus decreasing the code maintainability, we judged that this result is the best compromise between error message quality and maintainability.
