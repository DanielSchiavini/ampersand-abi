% !TEX root = ../Parsing.tex

\section{Haskell parsing libraries}
\label{sec:libraries}

\subsection{Parsing remarks}
Parsing is sometimes divided into two stages: lexical analysis (the domain of tools like flex) and parsing itself (performed by programs such as bison). Parsec can perform both lexical analysis and parsing.

My impression is that Happy has significantly better performance than almost any parser combinator library, especially for large grammars with little or no context. On the other hand, the flexibility of combinator libraries (with regards to effects, treating parsers as first class values, etc) is I think an everywhere better choice until performance becomes the dominating factor and one is dealing with a complex grammar.

Since Happy packs things down to neat little state machines which it can optimize, then the more states the parser can be in, the better the expected gain, I 'd imagine. Also, bear in mind that happy is happiest (most performant) when used with a separate lexer pass such as by alex

My rule of thumb is if I have a LR grammar (LR parsers are a type of bottom-up parsers that efficiently handle deterministic context-free languages in guaranteed linear time) I go with Happy, otherwise I use Parsec. It's usually not worth the effort changing LR to Parsec (more code, slower parser), but if I have to work out the grammar myself I like the tricks that Parsec supplies (e.g. context sensitive parsing).

uu-parsinglib is very full-featured (automatic error correction is nice), and simple to use. The documentation is decent also. I probably use attoparsec more because I do more work with binary stuff, for which it's very efficient. The on-demand model also matches well with enumerator-style IO (which I naturally use heavily). I listed polyparse because I admire the simplicity and elegance, although I rarely use it.

Another vote for uu-parsinglib. Our team switched from Parsec to uu-parsinglib a bit more than a year ago, and we haven't looked back. No explicit 'try' combinator needed, ability to do lazy parsing, and error correction mean that the fundamentals are more powerful than those of Parsec (even if the end-user niceties - documentation,pre-provided parsers for lexing etc aren't yet quite as good - but getting better). Happy is generally somewhat more awkward to use - but you do get the standard yacc-style guarantee of linear time parsing - otherwise you get told at compile time. 

As a downside of Parsec, you'll never know if your Parsec parser contains a left recursion, and your parser will get stuck in runtime (because Parsec is basically a top-down recursive-descent parser).

Happy is a program and you'll write in a different language if you use Happy and then compile with Happy

 keep life simple by not having to run a separate program in order to generate a parser 

Of course, recursive descent parsers defined by hand lack the efficiency of bottom-up parsers generated by machine (Aho et al., 1986; Mogensen, 1993; Gill & Marlow, 1995)

\subsection{Generators vs. combinators}
For complicated cases Happy and parser generators in general are much better. However, in case of simple, stupid languages with LL(k) parseable grammars I would use parser combinator library as more maintainer-friendly.

An LL parser is a top-down parser for a subset of context-free languages. It parses the input from Left to right, performing Leftmost derivation of the sentence.
An LL parser is called an LL(k) parser if it uses k tokens of lookahead when parsing a sentence. If such a parser exists for a certain grammar and it can parse sentences of this grammar without backtracking then it is called an LL(k) grammar.

In computer science, LR parsers are a type of bottom-up parsers that efficiently handle deterministic context-free languages in guaranteed linear time.[1] The LALR parsers and the SLR parsers are common variants of LR parsers. LR parsers are often mechanically generated from a formal grammar for the language by a parser generator tool. They are very widely used for the processing of computer languages, more than other kinds of generated parsers.

\subsection{Combinators vs. monads}
\lipsum[1]

\subsection{UU.Parsing}
\dict{UU.Parsing}{Haskell parsing library from the Utrecht University. \url{http://foswiki.cs.uu.nl/foswiki/HUT/ParserCombinators}}%
~4k downloads

can have error correcting and permutations for free, and also the things that parsec has
\lipsum[1]

\subsection{Parsec}
\dict{UU.Parsing}{Haskell monadic parsing combinator library written by Daan Leijen. \url{https://www.haskell.org/haskellwiki/Parsec}}%
~200k downloads

\subsection{Happy Parser Generator}
\dict{Happy Parser Generator}{Parser generator system for Haskell. \url{https://www.haskell.org/happy/}}%
~75k downloads

\subsection{Feature comparison}
\lipsum[1]

\subsection{Maintainability}
\lipsum[1]