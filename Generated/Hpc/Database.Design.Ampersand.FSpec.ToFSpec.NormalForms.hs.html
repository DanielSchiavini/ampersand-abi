<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=CP850">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="lineno">    1 </span>{-# OPTIONS_GHC -XFlexibleInstances #-}
<span class="lineno">    2 </span>module Database.Design.Ampersand.FSpec.ToFSpec.NormalForms
<span class="lineno">    3 </span>  (delta,conjNF,disjNF,normPA,cfProof,dfProof,proofPA,simplify
<span class="lineno">    4 </span>  ,cfProofs, dfProofs  -- these are for confluence testing.
<span class="lineno">    5 </span>  , makeAllConjs, conjuncts
<span class="lineno">    6 </span>  ) where
<span class="lineno">    7 </span>  
<span class="lineno">    8 </span>import Data.Set (Set)
<span class="lineno">    9 </span>import qualified Data.Set as Set
<span class="lineno">   10 </span>import Data.List (nub, intercalate, permutations)
<span class="lineno">   11 </span>import Database.Design.Ampersand.Basics
<span class="lineno">   12 </span>import Database.Design.Ampersand.ADL1.ECArule
<span class="lineno">   13 </span>import Database.Design.Ampersand.ADL1.Expression
<span class="lineno">   14 </span>import Database.Design.Ampersand.ADL1.P2A_Converters (pCpt2aCpt)
<span class="lineno">   15 </span>import Database.Design.Ampersand.Classes.Relational
<span class="lineno">   16 </span>import Database.Design.Ampersand.Core.AbstractSyntaxTree
<span class="lineno">   17 </span>import Database.Design.Ampersand.Core.ParseTree
<span class="lineno">   18 </span>import Database.Design.Ampersand.Misc.Options
<span class="lineno">   19 </span>import Database.Design.Ampersand.Input (parseRule)
<span class="lineno">   20 </span>import Database.Design.Ampersand.FSpec.ShowADL  -- for debug purposes only
<span class="lineno">   21 </span>import Prelude hiding (head)
<span class="lineno">   22 </span>-- import Debug.Trace
<span class="lineno">   23 </span>fatal :: Int -&gt; String -&gt; a
<span class="lineno">   24 </span><span class="decl"><span class="nottickedoff">fatal = fatalMsg &quot;FSpec.ToFSpec.NormalForms&quot;</span></span>
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>{- SJC:
<span class="lineno">   27 </span>Ideas for future work:
<span class="lineno">   28 </span>-&gt; Create a Unifier data type / class with
<span class="lineno">   29 </span>   &gt; extend :: key -&gt; value -&gt; Unifier -&gt; Maybe Unifier
<span class="lineno">   30 </span>   (returns Nothing if the key is already in the Unifier)
<span class="lineno">   31 </span>   &gt; obtain :: key -&gt; Unifier -&gt; value
<span class="lineno">   32 </span>   (something like this twice! Handle types separate from relations)
<span class="lineno">   33 </span>   &gt; think of a way in which substitution never fails (unify matching and substitution for this)
<span class="lineno">   34 </span>-&gt; Make RTerm polymorphic, so we can treat variables and constants separately.
<span class="lineno">   35 </span>   We'd have RTerm Expression and RTerm (String,String,String)
<span class="lineno">   36 </span>   We'd be able to derive fmap, and make RTerm Foldable.
<span class="lineno">   37 </span>-&gt; Really long term: Unify RTerm and Expression in a way that still allows us to write simple code for binary operators. Would require separating = and |- from Expression, which is also nice.
<span class="lineno">   38 </span>-}
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>-- The following was built for the purpose of testing confluence.
<span class="lineno">   41 </span>-- These functions produce all derivations of results from the normalizer.
<span class="lineno">   42 </span>-- A useful side effect is that it implicitly tests for soundness.
<span class="lineno">   43 </span>cfProofs, dfProofs :: Expression -&gt; [(Expression, Proof Expression)]
<span class="lineno">   44 </span>(cfProofs, dfProofs) = <span class="nottickedoff">(prfs False, prfs True)</span>
<span class="lineno">   45 </span> where
<span class="lineno">   46 </span>   prfs :: Bool -&gt; Expression -&gt; [(Expression, Proof Expression)]
<span class="lineno">   47 </span>   <span class="nottickedoff">prfs dnf expr</span>
<span class="lineno">   48 </span><span class="spaces">    </span><span class="nottickedoff">= nub [ (rTerm2expr t, map makeExpr derivs) | (t, derivs)&lt;-f (expr2RTerm expr) ]</span>
<span class="lineno">   49 </span><span class="spaces">      </span><span class="nottickedoff">where</span>
<span class="lineno">   50 </span><span class="spaces">        </span><span class="nottickedoff">f :: RTerm -&gt; [(RTerm,[(RTerm, [String], String)])]</span>
<span class="lineno">   51 </span><span class="spaces">        </span><span class="nottickedoff">f term = [ (term,[(term, [], &quot;&lt;=&gt;&quot;)]) | null dsteps ]++</span>
<span class="lineno">   52 </span><span class="spaces">                 </span><span class="nottickedoff">[ (t, (term, [showStep dstep], &quot;&lt;=&gt;&quot;):deriv)</span>
<span class="lineno">   53 </span><span class="spaces">                 </span><span class="nottickedoff">| dstep&lt;-dsteps, (t,deriv)&lt;-f (rhs dstep)</span>
<span class="lineno">   54 </span><span class="spaces">                 </span><span class="nottickedoff">]</span>
<span class="lineno">   55 </span><span class="spaces">                 </span><span class="nottickedoff">where dsteps = [ dstep | dstep&lt;-dSteps tceDerivRules term, w (rhs dstep)&lt;w term]</span>
<span class="lineno">   56 </span><span class="spaces">        </span><span class="nottickedoff">w = weightNF dnf -- the weight function for disjunctive normal form.</span>
<span class="lineno">   57 </span><span class="spaces">        </span><span class="nottickedoff">showStep dstep = &quot; weight: &quot;++(show.w.lhs) dstep++&quot;,   &quot;++showADL tmpl++&quot; = &quot;++showADL stp++&quot;  with unifier: &quot;++showADL unif</span>
<span class="lineno">   58 </span><span class="spaces">                         </span><span class="nottickedoff">where (tmpl,unif,stp) = rul dstep</span>
<span class="lineno">   59 </span><span class="spaces">        </span><span class="nottickedoff">makeExpr (term, explStr, logicSym) = (rTerm2expr term, explStr, logicSym)</span>
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>-- Deriving normal forms and representing the neccessary derivation rules are defined by means of RTerms.
<span class="lineno">   62 </span>-- The data structure RTerm is a representation of relation algebra expressions,
<span class="lineno">   63 </span>-- which is not redundant with respect to associativity and commutativity.
<span class="lineno">   64 </span>-- The reason for this is that we use term rewriting for normalization.
<span class="lineno">   65 </span>-- This algorithm performs poorly with commutative rules, because it may explode combinatorially.
<span class="lineno">   66 </span>data RTerm = RIsc {<span class="nottickedoff"><span class="decl"><span class="nottickedoff">rTermSet</span></span></span> :: Set RTerm}  -- intersection is associative and commutative
<span class="lineno">   67 </span>           | RUni {rTermSet :: Set RTerm}  -- union is associative and commutative
<span class="lineno">   68 </span>           | RDif {<span class="nottickedoff"><span class="decl"><span class="nottickedoff">rTermLft</span></span></span> :: RTerm, <span class="nottickedoff"><span class="decl"><span class="nottickedoff">rTermRht</span></span></span> :: RTerm}
<span class="lineno">   69 </span>           | RCpl {<span class="nottickedoff"><span class="decl"><span class="nottickedoff">rTermUny</span></span></span> :: RTerm}
<span class="lineno">   70 </span>           | RDia {rTermLft :: RTerm, rTermRht :: RTerm}
<span class="lineno">   71 </span>           | RLrs {rTermLft :: RTerm, rTermRht :: RTerm}
<span class="lineno">   72 </span>           | RRrs {rTermLft :: RTerm, rTermRht :: RTerm}
<span class="lineno">   73 </span>           | RRad {<span class="nottickedoff"><span class="decl"><span class="nottickedoff">rTermList</span></span></span> :: [RTerm]}      -- ! is associative
<span class="lineno">   74 </span>           | RCps {rTermList :: [RTerm]}      -- ; is associative
<span class="lineno">   75 </span>           | RPrd {rTermList :: [RTerm]}      -- # is associative
<span class="lineno">   76 </span>           | RKl0 {rTermUny :: RTerm}
<span class="lineno">   77 </span>           | RKl1 {rTermUny :: RTerm}
<span class="lineno">   78 </span>           | RFlp {rTermUny :: RTerm}
<span class="lineno">   79 </span>           | RId  A_Concept
<span class="lineno">   80 </span>           | RVee A_Concept A_Concept
<span class="lineno">   81 </span>           | RAtm String A_Concept
<span class="lineno">   82 </span>           | RVar String String String  -- relation name, source name, target name.
<span class="lineno">   83 </span>           | RConst Expression
<span class="lineno">   84 </span>           deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>,<span class="decl"><span class="nottickedoff">Ord</span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>)
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>-- The following condition must hold at all times for every RTerm, in order to make equality work
<span class="lineno">   87 </span>-- It ensures that nested RIsc terms do not occur, and RIsc terms are at least 2 terms of length.
<span class="lineno">   88 </span>-- The same holds for RUni, RRad, RCps, and RPrd.
<span class="lineno">   89 </span>isValid :: RTerm -&gt; Bool
<span class="lineno">   90 </span><span class="decl"><span class="nottickedoff">isValid (RIsc s)   = and [not (isRIsc e) &amp;&amp; isValid e &amp;&amp; length ls&gt;1 | let ls=Set.toList s, e&lt;-ls]</span>
<span class="lineno">   91 </span><span class="spaces"></span><span class="nottickedoff">isValid (RUni s)   = and [not (isRUni e) &amp;&amp; isValid e &amp;&amp; length ls&gt;1 | let ls=Set.toList s, e&lt;-ls]</span>
<span class="lineno">   92 </span><span class="spaces"></span><span class="nottickedoff">isValid (RDif l r) = isValid l &amp;&amp; isValid r</span>
<span class="lineno">   93 </span><span class="spaces"></span><span class="nottickedoff">isValid (RCpl e)   = isValid e</span>
<span class="lineno">   94 </span><span class="spaces"></span><span class="nottickedoff">isValid (RDia l r) = isValid l &amp;&amp; isValid r</span>
<span class="lineno">   95 </span><span class="spaces"></span><span class="nottickedoff">isValid (RLrs l r) = isValid l &amp;&amp; isValid r</span>
<span class="lineno">   96 </span><span class="spaces"></span><span class="nottickedoff">isValid (RRrs l r) = isValid l &amp;&amp; isValid r</span>
<span class="lineno">   97 </span><span class="spaces"></span><span class="nottickedoff">isValid (RRad ls)  = and [not (isRRad e) &amp;&amp; isValid e &amp;&amp; length ls&gt;1 | e&lt;-ls]</span>
<span class="lineno">   98 </span><span class="spaces"></span><span class="nottickedoff">isValid (RCps ls)  = and [not (isRCps e) &amp;&amp; isValid e &amp;&amp; length ls&gt;1 | e&lt;-ls]</span>
<span class="lineno">   99 </span><span class="spaces"></span><span class="nottickedoff">isValid (RPrd ls)  = and [not (isRPrd e) &amp;&amp; isValid e &amp;&amp; length ls&gt;1 | e&lt;-ls]</span>
<span class="lineno">  100 </span><span class="spaces"></span><span class="nottickedoff">isValid (RKl0 e)   = isValid e</span>
<span class="lineno">  101 </span><span class="spaces"></span><span class="nottickedoff">isValid (RKl1 e)   = isValid e</span>
<span class="lineno">  102 </span><span class="spaces"></span><span class="nottickedoff">isValid (RFlp e)   = isValid e</span>
<span class="lineno">  103 </span><span class="spaces"></span><span class="nottickedoff">isValid _          = True</span></span>
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>-- normRT exists to make an arbitrary term satisfy isValid.
<span class="lineno">  106 </span>-- So isValid (normRT term) is True, whil term and (normRT term) have the same meaning.
<span class="lineno">  107 </span>normRT :: RTerm -&gt; RTerm
<span class="lineno">  108 </span><span class="decl"><span class="nottickedoff">normRT (RIsc s)   = (combSet RIsc . Set.fromList . flat isRIsc . map normRT . Set.toList) s</span>
<span class="lineno">  109 </span><span class="spaces"></span><span class="nottickedoff">normRT (RUni s)   = (combSet RUni . Set.fromList . flat isRUni . map normRT . Set.toList) s</span>
<span class="lineno">  110 </span><span class="spaces"></span><span class="nottickedoff">normRT (RDif l r) = RDif (normRT l) (normRT r)</span>
<span class="lineno">  111 </span><span class="spaces"></span><span class="nottickedoff">normRT (RCpl e)   = RCpl (normRT e)</span>
<span class="lineno">  112 </span><span class="spaces"></span><span class="nottickedoff">normRT (RDia l r) = RDia (normRT l) (normRT r)</span>
<span class="lineno">  113 </span><span class="spaces"></span><span class="nottickedoff">normRT (RLrs l r) = RLrs (normRT l) (normRT r)</span>
<span class="lineno">  114 </span><span class="spaces"></span><span class="nottickedoff">normRT (RRrs l r) = RRrs (normRT l) (normRT r)</span>
<span class="lineno">  115 </span><span class="spaces"></span><span class="nottickedoff">normRT (RRad ls)  = (combLst RRad . flat isRRad . map normRT) ls</span>
<span class="lineno">  116 </span><span class="spaces"></span><span class="nottickedoff">normRT (RCps ls)  = (combLst RCps . flat isRCps . map normRT) ls</span>
<span class="lineno">  117 </span><span class="spaces"></span><span class="nottickedoff">normRT (RPrd ls)  = (combLst RPrd . flat isRPrd . map normRT) ls</span>
<span class="lineno">  118 </span><span class="spaces"></span><span class="nottickedoff">normRT (RKl0 e)   = RKl0 (normRT e)</span>
<span class="lineno">  119 </span><span class="spaces"></span><span class="nottickedoff">normRT (RKl1 e)   = RKl1 (normRT e)</span>
<span class="lineno">  120 </span><span class="spaces"></span><span class="nottickedoff">normRT (RFlp e)   = RFlp (normRT e)</span>
<span class="lineno">  121 </span><span class="spaces"></span><span class="nottickedoff">normRT term       = term</span></span>
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>isRIsc, isRUni, isRDif, isRCpl, isRDia, isRLrs, isRRrs, isRRad, isRCps, isRPrd, isRKl0, isRKl1, isRFlp, isRVar :: RTerm -&gt; Bool
<span class="lineno">  124 </span><span class="decl"><span class="nottickedoff">isRIsc (RIsc{}) = True</span>
<span class="lineno">  125 </span><span class="spaces"></span><span class="nottickedoff">isRIsc _        = False</span></span>
<span class="lineno">  126 </span><span class="decl"><span class="nottickedoff">isRUni (RUni{}) = True</span>
<span class="lineno">  127 </span><span class="spaces"></span><span class="nottickedoff">isRUni _        = False</span></span>
<span class="lineno">  128 </span><span class="decl"><span class="nottickedoff">isRDif (RDif{}) = True</span>
<span class="lineno">  129 </span><span class="spaces"></span><span class="nottickedoff">isRDif _        = False</span></span>
<span class="lineno">  130 </span><span class="decl"><span class="nottickedoff">isRCpl (RCpl{}) = True</span>
<span class="lineno">  131 </span><span class="spaces"></span><span class="nottickedoff">isRCpl _        = False</span></span>
<span class="lineno">  132 </span><span class="decl"><span class="nottickedoff">isRDia (RDia{}) = True</span>
<span class="lineno">  133 </span><span class="spaces"></span><span class="nottickedoff">isRDia _        = False</span></span>
<span class="lineno">  134 </span><span class="decl"><span class="nottickedoff">isRLrs (RLrs{}) = True</span>
<span class="lineno">  135 </span><span class="spaces"></span><span class="nottickedoff">isRLrs _        = False</span></span>
<span class="lineno">  136 </span><span class="decl"><span class="nottickedoff">isRRrs (RRrs{}) = True</span>
<span class="lineno">  137 </span><span class="spaces"></span><span class="nottickedoff">isRRrs _        = False</span></span>
<span class="lineno">  138 </span><span class="decl"><span class="nottickedoff">isRRad (RRad{}) = True</span>
<span class="lineno">  139 </span><span class="spaces"></span><span class="nottickedoff">isRRad _        = False</span></span>
<span class="lineno">  140 </span><span class="decl"><span class="nottickedoff">isRCps (RCps{}) = True</span>
<span class="lineno">  141 </span><span class="spaces"></span><span class="nottickedoff">isRCps _        = False</span></span>
<span class="lineno">  142 </span><span class="decl"><span class="nottickedoff">isRPrd (RPrd{}) = True</span>
<span class="lineno">  143 </span><span class="spaces"></span><span class="nottickedoff">isRPrd _        = False</span></span>
<span class="lineno">  144 </span><span class="decl"><span class="nottickedoff">isRKl0 (RKl0{}) = True</span>
<span class="lineno">  145 </span><span class="spaces"></span><span class="nottickedoff">isRKl0 _        = False</span></span>
<span class="lineno">  146 </span><span class="decl"><span class="nottickedoff">isRKl1 (RKl1{}) = True</span>
<span class="lineno">  147 </span><span class="spaces"></span><span class="nottickedoff">isRKl1 _        = False</span></span>
<span class="lineno">  148 </span><span class="decl"><span class="nottickedoff">isRFlp (RFlp{}) = True</span>
<span class="lineno">  149 </span><span class="spaces"></span><span class="nottickedoff">isRFlp _        = False</span></span>
<span class="lineno">  150 </span><span class="decl"><span class="nottickedoff">isRVar (RVar{}) = True</span>
<span class="lineno">  151 </span><span class="spaces"></span><span class="nottickedoff">isRVar _        = False</span></span>
<span class="lineno">  152 </span>
<span class="lineno">  153 </span>{- dSteps computes the expressions that can be obtained in one rewrite step.
<span class="lineno">  154 </span>   It yields the steps, for the purpose of constructing the entire proof.
<span class="lineno">  155 </span>   The idea is that the environment picks one of the steps produced by dSteps.
<span class="lineno">  156 </span>-}
<span class="lineno">  157 </span>dSteps :: [DerivRule] -&gt; RTerm -&gt; [DerivStep]
<span class="lineno">  158 </span><span class="decl"><span class="nottickedoff">dSteps drs x = dStps x</span>
<span class="lineno">  159 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="nottickedoff">dStps :: RTerm -&gt; [DerivStep]</span>
<span class="lineno">  161 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RIsc s)     = dStepSets isRIsc RIsc s</span>
<span class="lineno">  162 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RUni s)     = dStepSets isRUni RUni s</span>
<span class="lineno">  163 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RDif a b)   = dStepBin isRDif RDif a b</span>
<span class="lineno">  164 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RCpl a)     = dStepUny isRCpl RCpl a</span>
<span class="lineno">  165 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RDia a b)   = dStepBin isRDia RDia a b</span>
<span class="lineno">  166 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RLrs a b)   = dStepBin isRLrs RLrs a b</span>
<span class="lineno">  167 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RRrs a b)   = dStepBin isRRrs RRrs a b</span>
<span class="lineno">  168 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RRad ls)    = dStepLists isRRad RRad ls</span>
<span class="lineno">  169 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RCps ls)    = dStepLists isRCps RCps ls</span>
<span class="lineno">  170 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RPrd ls)    = dStepLists isRPrd RPrd ls</span>
<span class="lineno">  171 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RKl0 a)     = dStepUny isRKl0 RKl0 a</span>
<span class="lineno">  172 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RKl1 a)     = dStepUny isRKl1 RKl1 a</span>
<span class="lineno">  173 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RFlp a)     = dStepUny isRFlp RFlp a</span>
<span class="lineno">  174 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RId _)      = [ DStep { lhs = x                                       -- derivs gives the top level rewrites.</span>
<span class="lineno">  175 </span><span class="spaces">                               </span><span class="nottickedoff">, rul = (term, unif, term')                     -- only one rewrite is done in parallel in the top level.</span>
<span class="lineno">  176 </span><span class="spaces">                               </span><span class="nottickedoff">, rhs = substitute rd unif term'                -- so rest is left alone, if partition can be rewritten.</span>
<span class="lineno">  177 </span><span class="spaces">                               </span><span class="nottickedoff">}</span>
<span class="lineno">  178 </span><span class="spaces">                       </span><span class="nottickedoff">| (term@(RId a'), rewriteTerms)&lt;-matchableRules          -- select rewrite rules with the proper combinator</span>
<span class="lineno">  179 </span><span class="spaces">                       </span><span class="nottickedoff">, let unif = Set.fromList [(name a',x)]                  -- find unifiers such that: substitute &quot;&quot; unif term==rCombinator a</span>
<span class="lineno">  180 </span><span class="spaces">                       </span><span class="nottickedoff">, term'&lt;-rewriteTerms                                    -- enumerate right hand side RTerms in order to construct:  substitute &quot;&quot; unif term'</span>
<span class="lineno">  181 </span><span class="spaces">                       </span><span class="nottickedoff">, let rd = showADL term++&quot; -&gt; &quot;++showADL term'           -- rule documentation for fatals in 'substitute'</span>
<span class="lineno">  182 </span><span class="spaces">                       </span><span class="nottickedoff">, if substitute rd unif term==x then True else</span>
<span class="lineno">  183 </span><span class="spaces">                         </span><span class="nottickedoff">fatal 122 (&quot;When analysing rule &quot;++rd++&quot; with unifier &quot;++showADL unif++&quot;\nsubstitute rd unif term:  &quot;++showADL (substitute rd unif term)++&quot;\ndiffers from:  &quot;++showADL x)</span>
<span class="lineno">  184 </span><span class="spaces">                       </span><span class="nottickedoff">]</span>
<span class="lineno">  185 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RVee a b)   = [ DStep { lhs = x                                       -- derivs gives the top level rewrites.</span>
<span class="lineno">  186 </span><span class="spaces">                               </span><span class="nottickedoff">, rul = (term, unif, term')                     -- only one rewrite is done in parallel in the top level.</span>
<span class="lineno">  187 </span><span class="spaces">                               </span><span class="nottickedoff">, rhs = substitute rd unif term'                -- so rest is left alone, if partition can be rewritten.</span>
<span class="lineno">  188 </span><span class="spaces">                               </span><span class="nottickedoff">}</span>
<span class="lineno">  189 </span><span class="spaces">                       </span><span class="nottickedoff">| (term@(RVee a' b'), rewriteTerms)&lt;-matchableRules      -- select rewrite rules with the proper combinator</span>
<span class="lineno">  190 </span><span class="spaces">                       </span><span class="nottickedoff">, let unif = Set.fromList [(name a',RId a), (name b',RId b)] -- find unifiers such that: substitute &quot;&quot; unif term==rCombinator a</span>
<span class="lineno">  191 </span><span class="spaces">                       </span><span class="nottickedoff">, noDoubles unif                                         -- if one variable is bound to more than one different expressions, the deal is off.</span>
<span class="lineno">  192 </span><span class="spaces">                       </span><span class="nottickedoff">, term'&lt;-rewriteTerms                                    -- enumerate right hand side RTerms in order to construct:  substitute &quot;&quot; unif term'</span>
<span class="lineno">  193 </span><span class="spaces">                       </span><span class="nottickedoff">, let rd = showADL term++&quot; -&gt; &quot;++showADL term'           -- rule documentation for fatals in 'substitute'</span>
<span class="lineno">  194 </span><span class="spaces">                       </span><span class="nottickedoff">, if substitute rd unif term==x then True else</span>
<span class="lineno">  195 </span><span class="spaces">                         </span><span class="nottickedoff">fatal 134 (&quot;When analysing rule &quot;++rd++&quot; with unifier &quot;++showADL unif++&quot;\nsubstitute rd unif term:  &quot;++showADL (substitute rd unif term)++&quot;\ndiffers from:  &quot;++showADL x)</span>
<span class="lineno">  196 </span><span class="spaces">                       </span><span class="nottickedoff">]</span>
<span class="lineno">  197 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RAtm a c)   = [ DStep { lhs = x                                       -- derivs gives the top level rewrites.</span>
<span class="lineno">  198 </span><span class="spaces">                               </span><span class="nottickedoff">, rul = (term, unif, term')                     -- only one rewrite is done in parallel in the top level.</span>
<span class="lineno">  199 </span><span class="spaces">                               </span><span class="nottickedoff">, rhs = substitute rd unif term'                -- so rest is left alone, if partition can be rewritten.</span>
<span class="lineno">  200 </span><span class="spaces">                               </span><span class="nottickedoff">}</span>
<span class="lineno">  201 </span><span class="spaces">                       </span><span class="nottickedoff">| (term@(RAtm a' c'), rewriteTerms)&lt;-matchableRules      -- select rewrite rules with the proper combinator</span>
<span class="lineno">  202 </span><span class="spaces">                       </span><span class="nottickedoff">, a==a'</span>
<span class="lineno">  203 </span><span class="spaces">                       </span><span class="nottickedoff">, let unif = Set.fromList [(name c',RId c)]              -- find unifiers such that: substitute &quot;&quot; unif term==rCombinator a</span>
<span class="lineno">  204 </span><span class="spaces">                       </span><span class="nottickedoff">, term'&lt;-rewriteTerms                                    -- enumerate right hand side RTerms in order to construct:  substitute &quot;&quot; unif term'</span>
<span class="lineno">  205 </span><span class="spaces">                       </span><span class="nottickedoff">, let rd = showADL term++&quot; -&gt; &quot;++showADL term'            -- rule documentation for fatals in 'substitute'</span>
<span class="lineno">  206 </span><span class="spaces">                       </span><span class="nottickedoff">, if substitute rd unif term==x then True else</span>
<span class="lineno">  207 </span><span class="spaces">                         </span><span class="nottickedoff">fatal 146 (&quot;When analysing rule &quot;++rd++&quot; with unifier &quot;++showADL unif++&quot;\nsubstitute rd unif term:  &quot;++showADL (substitute rd unif term)++&quot;\ndiffers from:  &quot;++showADL x)</span>
<span class="lineno">  208 </span><span class="spaces">                       </span><span class="nottickedoff">]</span>
<span class="lineno">  209 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RVar _ _ _) = fatal 147 &quot;Cannot rewrite a term with a variable in it.&quot; -- This should become a haskell type-error when RTerm is polymorphic</span>
<span class="lineno">  210 </span><span class="spaces">  </span><span class="nottickedoff">dStps (RConst _)   = [] -- the only possibly matching rule has a single variable on the lhs, which we assume does not exist. SJ to SJC: Why? is there a reason why we don't want to include that situation?</span>
<span class="lineno">  211 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  212 </span><span class="spaces">  </span><span class="nottickedoff">dStepUny :: (RTerm -&gt; Bool)    -- a predicate, isrComb, which tests whether some RTerm r has rCombinator as its root.</span>
<span class="lineno">  213 </span><span class="spaces">           </span><span class="nottickedoff">-&gt; (RTerm -&gt; RTerm)   -- the combinator</span>
<span class="lineno">  214 </span><span class="spaces">           </span><span class="nottickedoff">-&gt; RTerm              -- its argument  (So, we are working with the RTerm   rCombinator a)</span>
<span class="lineno">  215 </span><span class="spaces">           </span><span class="nottickedoff">-&gt; [DerivStep]        -- all derivation steps that start at  rCombinator a, which can be made using the available ruleset</span>
<span class="lineno">  216 </span><span class="spaces"></span><span class="nottickedoff">{- We are trying to find steps in case an expression (rCombinator a) has a unary operator (i.e. RCpl, RKl0, RKl1, RFlp) as its root.</span>
<span class="lineno">  217 </span><span class="spaces">   </span><span class="nottickedoff">First, we try to find a rewrite step on the root level of the expression. The resulting steps are called &quot;derivs&quot;.</span>
<span class="lineno">  218 </span><span class="spaces">   </span><span class="nottickedoff">When that fails, we try to find the steps from subexpression a recursively.</span>
<span class="lineno">  219 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno">  220 </span><span class="spaces">  </span><span class="nottickedoff">dStepUny isrComb rCombinator a</span>
<span class="lineno">  221 </span><span class="spaces">   </span><span class="nottickedoff">= if (not . isValid . rCombinator) a</span>
<span class="lineno">  222 </span><span class="spaces">     </span><span class="nottickedoff">then fatal 180 (&quot;Invalid expression in dStepLists: &quot;++showADL (rCombinator a))</span>
<span class="lineno">  223 </span><span class="spaces">     </span><span class="nottickedoff">else</span>
<span class="lineno">  224 </span><span class="spaces">     </span><span class="nottickedoff">derivs ++</span>
<span class="lineno">  225 </span><span class="spaces">     </span><span class="nottickedoff">[ DStep { lhs = rCombinator a                                     -- try to find steps recursively</span>
<span class="lineno">  226 </span><span class="spaces">             </span><span class="nottickedoff">, rul = rul step</span>
<span class="lineno">  227 </span><span class="spaces">             </span><span class="nottickedoff">, rhs = rCombinator (rhs step)</span>
<span class="lineno">  228 </span><span class="spaces">             </span><span class="nottickedoff">}</span>
<span class="lineno">  229 </span><span class="spaces">     </span><span class="nottickedoff">| step&lt;-dStps a ]</span>
<span class="lineno">  230 </span><span class="spaces">     </span><span class="nottickedoff">where derivs = [ DStep { lhs = rCombinator a                           -- derivs gives the top level rewrites.</span>
<span class="lineno">  231 </span><span class="spaces">                            </span><span class="nottickedoff">, rul = (term, unif, term')                     -- only one rewrite is done in parallel in the top level.</span>
<span class="lineno">  232 </span><span class="spaces">                            </span><span class="nottickedoff">, rhs = substitute rd unif term'                -- so rest is left alone, if partition can be rewritten.</span>
<span class="lineno">  233 </span><span class="spaces">                            </span><span class="nottickedoff">}</span>
<span class="lineno">  234 </span><span class="spaces">                    </span><span class="nottickedoff">| (term, rewriteTerms)&lt;-matchableRules, isrComb term     -- select rewrite rules with the proper combinator</span>
<span class="lineno">  235 </span><span class="spaces">                    </span><span class="nottickedoff">, let subTerm = rTermUny term                            -- now:   rCombinator subTerm = term</span>
<span class="lineno">  236 </span><span class="spaces">                    </span><span class="nottickedoff">, unif&lt;-matches subTerm a                                -- find unifiers such that: substitute &quot;&quot; unif term==rCombinator a</span>
<span class="lineno">  237 </span><span class="spaces">                    </span><span class="nottickedoff">, term'&lt;-rewriteTerms                                    -- enumerate right hand side RTerms in order to construct:  substitute &quot;&quot; unif term'</span>
<span class="lineno">  238 </span><span class="spaces">                    </span><span class="nottickedoff">, let rd = showADL term++&quot; -&gt; &quot;++showADL term'            -- rule documentation for fatals in 'substitute'</span>
<span class="lineno">  239 </span><span class="spaces">                    </span><span class="nottickedoff">, if substitute rd unif term==rCombinator a then True else</span>
<span class="lineno">  240 </span><span class="spaces">                      </span><span class="nottickedoff">fatal 177 (&quot;When analysing rule &quot;++rd++&quot; with unifier &quot;++showADL unif++&quot;\nsubstitute rd unif term:  &quot;++showADL (substitute rd unif term)++&quot;\ndiffers from\nrCombinator a:  &quot;++showADL (rCombinator a))</span>
<span class="lineno">  241 </span><span class="spaces">                    </span><span class="nottickedoff">]</span>
<span class="lineno">  242 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  243 </span><span class="spaces"></span><span class="nottickedoff">-- dStepBin follows the same pattern as dStepUny, but for binary RTerms</span>
<span class="lineno">  244 </span><span class="spaces">  </span><span class="nottickedoff">dStepBin :: (RTerm -&gt; Bool) -&gt; (RTerm -&gt; RTerm -&gt; RTerm) -&gt; RTerm -&gt; RTerm -&gt; [DerivStep]</span>
<span class="lineno">  245 </span><span class="spaces">  </span><span class="nottickedoff">dStepBin isrComb rCombinator a b</span>
<span class="lineno">  246 </span><span class="spaces">   </span><span class="nottickedoff">= if (not . isValid) (rCombinator a b)</span>
<span class="lineno">  247 </span><span class="spaces">     </span><span class="nottickedoff">then fatal 202 (&quot;Invalid expression in dStepLists: &quot;++showADL (rCombinator a b))</span>
<span class="lineno">  248 </span><span class="spaces">     </span><span class="nottickedoff">else</span>
<span class="lineno">  249 </span><span class="spaces">     </span><span class="nottickedoff">derivs ++</span>
<span class="lineno">  250 </span><span class="spaces">     </span><span class="nottickedoff">[ DStep { lhs = rCombinator a b</span>
<span class="lineno">  251 </span><span class="spaces">             </span><span class="nottickedoff">, rul = rul rStp</span>
<span class="lineno">  252 </span><span class="spaces">             </span><span class="nottickedoff">, rhs = rCombinator a (rhs rStp)</span>
<span class="lineno">  253 </span><span class="spaces">             </span><span class="nottickedoff">}</span>
<span class="lineno">  254 </span><span class="spaces">     </span><span class="nottickedoff">| rStp&lt;-dStps b ] ++</span>
<span class="lineno">  255 </span><span class="spaces">     </span><span class="nottickedoff">[ DStep { lhs = rCombinator a b</span>
<span class="lineno">  256 </span><span class="spaces">             </span><span class="nottickedoff">, rul = rul lStp</span>
<span class="lineno">  257 </span><span class="spaces">             </span><span class="nottickedoff">, rhs = rCombinator (rhs lStp) b</span>
<span class="lineno">  258 </span><span class="spaces">             </span><span class="nottickedoff">}</span>
<span class="lineno">  259 </span><span class="spaces">     </span><span class="nottickedoff">| lStp&lt;-dStps a ]</span>
<span class="lineno">  260 </span><span class="spaces">     </span><span class="nottickedoff">where derivs = [ DStep { lhs = rCombinator a b             -- derivs gives the top level rewrites.</span>
<span class="lineno">  261 </span><span class="spaces">                            </span><span class="nottickedoff">, rul = (term, unif, term')         -- only one rewrite is done in parallel in the top level.</span>
<span class="lineno">  262 </span><span class="spaces">                            </span><span class="nottickedoff">, rhs = substitute rd unif term'    -- so rest is left alone, if partition can be rewritten.</span>
<span class="lineno">  263 </span><span class="spaces">                            </span><span class="nottickedoff">}</span>
<span class="lineno">  264 </span><span class="spaces">                    </span><span class="nottickedoff">| (term, rewriteTerms)&lt;-matchableRules, isrComb term    -- select rewrite rules with the proper combinator</span>
<span class="lineno">  265 </span><span class="spaces">                    </span><span class="nottickedoff">, let subLft = rTermLft term; subRht = rTermRht term    -- now:   rCombinator subTerm = term</span>
<span class="lineno">  266 </span><span class="spaces">                    </span><span class="nottickedoff">, unif1 &lt;- matches subLft a</span>
<span class="lineno">  267 </span><span class="spaces">                    </span><span class="nottickedoff">, unif2 &lt;- matches subRht b    -- find unifiers such that: substitute &quot;&quot; unif term==rCombinator a</span>
<span class="lineno">  268 </span><span class="spaces">                    </span><span class="nottickedoff">, let unif = Set.union unif1 unif2</span>
<span class="lineno">  269 </span><span class="spaces">                    </span><span class="nottickedoff">, noDoubles unif                          -- if one variable is bound to more than one different expressions, the deal is off.</span>
<span class="lineno">  270 </span><span class="spaces">                    </span><span class="nottickedoff">, term'&lt;-rewriteTerms                     -- enumerate right hand side RTerms in order to construct:  substitute &quot;&quot; unif term'</span>
<span class="lineno">  271 </span><span class="spaces">                    </span><span class="nottickedoff">, let rd = showADL term++&quot; -&gt; &quot;++showADL term'        -- rule documentation for fatals in 'substitute'</span>
<span class="lineno">  272 </span><span class="spaces">                    </span><span class="nottickedoff">, if substitute rd unif term==rCombinator a b then True else</span>
<span class="lineno">  273 </span><span class="spaces">                      </span><span class="nottickedoff">fatal 207 (&quot;When analysing rule &quot;++rd++&quot; with unifier &quot;++showADL unif++&quot;\nsubstitute rd unif term:  &quot;++showADL (substitute rd unif term)++&quot;\ndiffers from\nrCombinator a b:  &quot;++showADL (rCombinator a b))</span>
<span class="lineno">  274 </span><span class="spaces">                    </span><span class="nottickedoff">]</span>
<span class="lineno">  275 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  276 </span><span class="spaces">  </span><span class="nottickedoff">dStepLists :: (RTerm -&gt; Bool) -&gt; ([RTerm] -&gt; RTerm) -&gt; [RTerm] -&gt; [DerivStep] -- Note: a and b are both RTerm</span>
<span class="lineno">  277 </span><span class="spaces">  </span><span class="nottickedoff">dStepLists isrComb rCombinator ls</span>
<span class="lineno">  278 </span><span class="spaces">   </span><span class="nottickedoff">= if (not . isValid . rCombinator) ls</span>
<span class="lineno">  279 </span><span class="spaces">     </span><span class="nottickedoff">then fatal 231 (&quot;Invalid expression in dStepLists: &quot;++showADL (rCombinator ls))</span>
<span class="lineno">  280 </span><span class="spaces">     </span><span class="nottickedoff">else</span>
<span class="lineno">  281 </span><span class="spaces">     </span><span class="nottickedoff">[ DStep { lhs = rCombinator ls       -- The original expression</span>
<span class="lineno">  282 </span><span class="spaces">             </span><span class="nottickedoff">, rul = (term, unif, term')  -- only one rewrite step is done without parallelism.</span>
<span class="lineno">  283 </span><span class="spaces">             </span><span class="nottickedoff">, rhs = result</span>
<span class="lineno">  284 </span><span class="spaces">             </span><span class="nottickedoff">}</span>
<span class="lineno">  285 </span><span class="spaces">     </span><span class="nottickedoff">| (term, rewriteTerms)&lt;-matchableRules, isrComb term</span>
<span class="lineno">  286 </span><span class="spaces">     </span><span class="nottickedoff">, let subTerms = rTermList term</span>
<span class="lineno">  287 </span><span class="spaces">     </span><span class="nottickedoff">, let n=length subTerms</span>
<span class="lineno">  288 </span><span class="spaces">     </span><span class="nottickedoff">, (pre,segmentList,post) &lt;- segments n</span>
<span class="lineno">  289 </span><span class="spaces">     </span><span class="nottickedoff">, unif &lt;- mix [ matches l r | (l,r)&lt;-safezip subTerms (map (combLst rCombinator) segmentList) ]</span>
<span class="lineno">  290 </span><span class="spaces">     </span><span class="nottickedoff">, noDoubles unif                                      -- if one variable is bound to more than one different expressions, the deal is off.</span>
<span class="lineno">  291 </span><span class="spaces">     </span><span class="nottickedoff">, term'&lt;-rewriteTerms</span>
<span class="lineno">  292 </span><span class="spaces">     </span><span class="nottickedoff">, let rd = showADL term++&quot; -&gt; &quot;++showADL term'        -- rule documentation for fatals in 'substitute'</span>
<span class="lineno">  293 </span><span class="spaces">     </span><span class="nottickedoff">, let original=flatLst (pre ++ substitute rd unif term :post)  -- is equal to rCombinator ls</span>
<span class="lineno">  294 </span><span class="spaces">     </span><span class="nottickedoff">, let result  =flatLst (pre ++ substitute rd unif term':post)</span>
<span class="lineno">  295 </span><span class="spaces">     </span><span class="nottickedoff">, if original==rCombinator ls then True else</span>
<span class="lineno">  296 </span><span class="spaces">       </span><span class="nottickedoff">fatal 228 (&quot;When analysing rule &quot;++rd++&quot; with unifier &quot;++showADL unif++&quot; on:  &quot;++showADL (rCombinator ls)++</span>
<span class="lineno">  297 </span><span class="spaces">                  </span><span class="nottickedoff">&quot;\nWe substitute:  &quot;++showADL (substitute rd unif term)++</span>
<span class="lineno">  298 </span><span class="spaces">                  </span><span class="nottickedoff">&quot;\nby:             &quot;++showADL (substitute rd unif term')++</span>
<span class="lineno">  299 </span><span class="spaces">                  </span><span class="nottickedoff">&quot;.\nHowever, the original RTerm:  &quot;++showADL (rCombinator ls)++</span>
<span class="lineno">  300 </span><span class="spaces">                  </span><span class="nottickedoff">&quot;\ndiffers from flatLst (pre ++ substitute rd unif term :post):\n  &quot;++</span>
<span class="lineno">  301 </span><span class="spaces">                  </span><span class="nottickedoff">showADL original</span>
<span class="lineno">  302 </span><span class="spaces">                 </span><span class="nottickedoff">)</span>
<span class="lineno">  303 </span><span class="spaces">     </span><span class="nottickedoff">] ++</span>
<span class="lineno">  304 </span><span class="spaces">     </span><span class="nottickedoff">[ DStep { lhs = rCombinator ls -- is equal to: (pre++lhs dstep:post)</span>
<span class="lineno">  305 </span><span class="spaces">             </span><span class="nottickedoff">, rul = rul dstep</span>
<span class="lineno">  306 </span><span class="spaces">             </span><span class="nottickedoff">, rhs = flatLst (pre++rhs dstep:post)</span>
<span class="lineno">  307 </span><span class="spaces">             </span><span class="nottickedoff">}</span>
<span class="lineno">  308 </span><span class="spaces">     </span><span class="nottickedoff">| (pre,l,post) &lt;- splitList ls</span>
<span class="lineno">  309 </span><span class="spaces">     </span><span class="nottickedoff">, dstep &lt;- dStps l]</span>
<span class="lineno">  310 </span><span class="spaces">     </span><span class="nottickedoff">where dist :: Int -&gt; [RTerm] -&gt; [[[RTerm]]]</span>
<span class="lineno">  311 </span><span class="spaces">           </span><span class="nottickedoff">dist 1 es = [[es]]</span>
<span class="lineno">  312 </span><span class="spaces">           </span><span class="nottickedoff">dist 2 es = [ [ take i es , drop i es ] | i&lt;-[1..length es-1] ]</span>
<span class="lineno">  313 </span><span class="spaces">           </span><span class="nottickedoff">dist n es = [ init ds++st | ds&lt;-dist (n-1) es, let staart=last ds, length staart&gt;=2, st&lt;-dist 2 staart ]</span>
<span class="lineno">  314 </span><span class="spaces">           </span><span class="nottickedoff">segments :: Int -&gt; [([RTerm],[[RTerm]],[RTerm])]</span>
<span class="lineno">  315 </span><span class="spaces">           </span><span class="nottickedoff">segments n</span>
<span class="lineno">  316 </span><span class="spaces">            </span><span class="nottickedoff">= [ ([], ds, []) | ds&lt;-dist n ls] ++</span>
<span class="lineno">  317 </span><span class="spaces">              </span><span class="nottickedoff">[ (head ds, tail ds, []) | ds&lt;-dist (n+1) ls ] ++</span>
<span class="lineno">  318 </span><span class="spaces">              </span><span class="nottickedoff">[ ([], init ds, last ds) | ds&lt;-dist (n+1) ls ] ++</span>
<span class="lineno">  319 </span><span class="spaces">              </span><span class="nottickedoff">[ (head ds, (init.tail) ds, last ds) | ds&lt;-dist (n+2) ls ]</span>
<span class="lineno">  320 </span><span class="spaces">           </span><span class="nottickedoff">flatLst :: [RTerm] -&gt; RTerm</span>
<span class="lineno">  321 </span><span class="spaces">           </span><span class="nottickedoff">flatLst = combLst rCombinator . flat isrComb</span>
<span class="lineno">  322 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  323 </span><span class="spaces">  </span><span class="nottickedoff">dStepSets ::  (RTerm -&gt; Bool) -&gt; (Set RTerm -&gt; RTerm) -&gt; Set RTerm -&gt; [DerivStep]</span>
<span class="lineno">  324 </span><span class="spaces">  </span><span class="nottickedoff">dStepSets isrComb rCombinator s</span>
<span class="lineno">  325 </span><span class="spaces">  </span><span class="nottickedoff">-- We try to perform a rewrite on the top level, i.e. on some subset of RTerms from s.</span>
<span class="lineno">  326 </span><span class="spaces">  </span><span class="nottickedoff">-- Then, we add rewrites on any of the subexpressins in s.</span>
<span class="lineno">  327 </span><span class="spaces">  </span><span class="nottickedoff">-- Example rCombinator s  = RUni { '1', aap, aap\noot, 'Piet', mies;vuur}</span>
<span class="lineno">  328 </span><span class="spaces">   </span><span class="nottickedoff">= [ DStep { lhs = rCombinator s            -- derivs gives the top level rewrites.</span>
<span class="lineno">  329 </span><span class="spaces">             </span><span class="nottickedoff">, rul = (term, unif, term')      -- only one rewrite is done in parallel in the top level.</span>
<span class="lineno">  330 </span><span class="spaces">             </span><span class="nottickedoff">, rhs = result                   -- so rest is left alone, if partition can be rewritten.</span>
<span class="lineno">  331 </span><span class="spaces">             </span><span class="nottickedoff">}</span>
<span class="lineno">  332 </span><span class="spaces">     </span><span class="nottickedoff">| null [ () | e&lt;-Set.toList s, not (isValid e), fatal 313 (&quot;Invalid subexpr: &quot;++showADL e) ]</span>
<span class="lineno">  333 </span><span class="spaces">     </span><span class="nottickedoff">-- s = { foo;foo~ , -(bar;bar~) , I[C]}</span>
<span class="lineno">  334 </span><span class="spaces">     </span><span class="nottickedoff">, (term, rewriteTerms)&lt;-matchableRules, isrComb term       -- e.g. term = 'Piet' \/ r \/ p\q</span>
<span class="lineno">  335 </span><span class="spaces">     </span><span class="nottickedoff">, let subTerms = rTermSet term                             -- e.g. subTerms = { 'Piet', r, p\q }</span>
<span class="lineno">  336 </span><span class="spaces">     </span><span class="nottickedoff">, let termVars = Set.filter isRVar subTerms                -- e.g. termVars = { r }</span>
<span class="lineno">  337 </span><span class="spaces">     </span><span class="nottickedoff">, let sameTrms = subTerms `Set.intersection` s             -- e.g. sameTrms = { 'Piet' }</span>
<span class="lineno">  338 </span><span class="spaces">     </span><span class="nottickedoff">, let subExprs = s `Set.difference` sameTrms               -- { '1', aap, aap\noot, mies;vuur }</span>
<span class="lineno">  339 </span><span class="spaces">     </span><span class="nottickedoff">, let toMatchs = (subTerms `Set.difference` sameTrms) `Set.difference` termVars -- e.g. toMatchs = { p\q }</span>
<span class="lineno">  340 </span><span class="spaces">     </span><span class="nottickedoff">, let n=Set.size toMatchs -- each element of toMatchs can be matched to one subTerm from subExprs.</span>
<span class="lineno">  341 </span><span class="spaces">     </span><span class="nottickedoff">, (matchCandidates,rest)&lt;-separate n subExprs              -- e.g. matchCandidates = {aap\noot} and rest={ '1', aap, mies;vuur }</span>
<span class="lineno">  342 </span><span class="spaces">     </span><span class="nottickedoff">, let m=Set.size termVars -- each variable in subTerms must be matched to one subset from rest.</span>
<span class="lineno">  343 </span><span class="spaces">     </span><span class="nottickedoff">, (restSets,remainder)&lt;-partsplus m rest                   -- e.g. restSets={ {'1', aap, mies;vuur} }</span>
<span class="lineno">  344 </span><span class="spaces">     </span><span class="nottickedoff">, let restTerms = (Set.map (flatSet . Set.toList)) restSets   -- e.g. restTerms={ RUni {'1', aap, mies;vuur} }</span>
<span class="lineno">  345 </span><span class="spaces">     </span><span class="nottickedoff">, if Set.null restTerms then True else</span>
<span class="lineno">  346 </span><span class="spaces">       </span><span class="nottickedoff">if (isValid . flatSet . Set.toList) restTerms then True else fatal 305 (&quot;Invalid restTerms: &quot;++showADL (rCombinator restTerms))</span>
<span class="lineno">  347 </span><span class="spaces">     </span><span class="nottickedoff">, let remTerm   = let remT = combSet rCombinator remainder in</span>
<span class="lineno">  348 </span><span class="spaces">                       </span><span class="nottickedoff">if Set.null remainder</span>
<span class="lineno">  349 </span><span class="spaces">                       </span><span class="nottickedoff">then fatal 308 &quot;empty remTerm&quot;</span>
<span class="lineno">  350 </span><span class="spaces">                       </span><span class="nottickedoff">else if isValid remT then remT else fatal 309 (&quot;Invalid remTerm: &quot;++showADL remT)            -- e.g. restTerms={ RUni {'1', aap, mies;vuur} }</span>
<span class="lineno">  351 </span><span class="spaces">     </span><span class="nottickedoff">, unif0 &lt;- if Set.null toMatchs then [Set.empty] else</span>
<span class="lineno">  352 </span><span class="spaces">                </span><span class="nottickedoff">if (not.isValid.combSet rCombinator) toMatchs        then fatal 311 (&quot;Invalid toMatchs: &quot;++showADL (rCombinator toMatchs)) else</span>
<span class="lineno">  353 </span><span class="spaces">                </span><span class="nottickedoff">if (not.isValid.combSet rCombinator) matchCandidates then fatal 312 (&quot;Invalid matchCandidates: &quot;++showADL (rCombinator matchCandidates)) else</span>
<span class="lineno">  354 </span><span class="spaces">                </span><span class="nottickedoff">matchSets rCombinator toMatchs matchCandidates  -- e.g. unif0={ p-&gt;aap, q-&gt;noot }</span>
<span class="lineno">  355 </span><span class="spaces">     </span><span class="nottickedoff">, unif1 &lt;- if Set.null termVars then [Set.empty] else</span>
<span class="lineno">  356 </span><span class="spaces">                </span><span class="nottickedoff">matchSets rCombinator termVars restTerms        -- e.g. unif1={ r-&gt;RUni {'1', aap, mies;vuur} }</span>
<span class="lineno">  357 </span><span class="spaces">     </span><span class="nottickedoff">, let unif = unif0 `Set.union` unif1                       -- e.g. unif={ p-&gt;aap, q-&gt;noot, r-&gt;RUni {'1', aap, mies;vuur} }</span>
<span class="lineno">  358 </span><span class="spaces">     </span><span class="nottickedoff">, noDoubles unif</span>
<span class="lineno">  359 </span><span class="spaces">     </span><span class="nottickedoff">, term'&lt;-rewriteTerms</span>
<span class="lineno">  360 </span><span class="spaces">     </span><span class="nottickedoff">, let rd = showADL term++&quot; -&gt; &quot;++showADL term'             -- rule documentation for fatals in 'substitute'</span>
<span class="lineno">  361 </span><span class="spaces">     </span><span class="nottickedoff">, let original = if Set.null remainder</span>
<span class="lineno">  362 </span><span class="spaces">                      </span><span class="nottickedoff">then substitute rd unif term              -- is equal to rCombinator ls</span>
<span class="lineno">  363 </span><span class="spaces">                      </span><span class="nottickedoff">else flatSet [substitute rd unif term,  remTerm]</span>
<span class="lineno">  364 </span><span class="spaces">     </span><span class="nottickedoff">, let result   = if Set.null remainder</span>
<span class="lineno">  365 </span><span class="spaces">                      </span><span class="nottickedoff">then substitute rd unif term'</span>
<span class="lineno">  366 </span><span class="spaces">                      </span><span class="nottickedoff">else flatSet [substitute rd unif term', remTerm]</span>
<span class="lineno">  367 </span><span class="spaces">     </span><span class="nottickedoff">, if original==rCombinator s then True else</span>
<span class="lineno">  368 </span><span class="spaces">       </span><span class="nottickedoff">fatal 327 (&quot;When analysing rule &quot;++rd++&quot; with unifier &quot;++showADL unif++&quot; on:  &quot;++showADL (rCombinator s)++</span>
<span class="lineno">  369 </span><span class="spaces">                  </span><span class="nottickedoff">&quot;\nWe substitute:  &quot;++showADL original++</span>
<span class="lineno">  370 </span><span class="spaces">                  </span><span class="nottickedoff">&quot;\nby:             &quot;++showADL result++</span>
<span class="lineno">  371 </span><span class="spaces">                  </span><span class="nottickedoff">&quot;\nHowever, the original RTerm:  &quot;++showADL (rCombinator s)++</span>
<span class="lineno">  372 </span><span class="spaces">                  </span><span class="nottickedoff">&quot;\ndiffers from subs term:       &quot;++showADL original</span>
<span class="lineno">  373 </span><span class="spaces">                 </span><span class="nottickedoff">)</span>
<span class="lineno">  374 </span><span class="spaces">     </span><span class="nottickedoff">] ++</span>
<span class="lineno">  375 </span><span class="spaces">     </span><span class="nottickedoff">[ DStep { lhs = rCombinator s -- is equal to: (pre \/ lhs dstep)</span>
<span class="lineno">  376 </span><span class="spaces">             </span><span class="nottickedoff">, rul = rul dstep</span>
<span class="lineno">  377 </span><span class="spaces">             </span><span class="nottickedoff">, rhs = flatSet (pre++rhs dstep:post)</span>
<span class="lineno">  378 </span><span class="spaces">             </span><span class="nottickedoff">}</span>
<span class="lineno">  379 </span><span class="spaces">     </span><span class="nottickedoff">| (pre,l,post) &lt;- splitList (Set.toList s)</span>
<span class="lineno">  380 </span><span class="spaces">     </span><span class="nottickedoff">, dstep &lt;- dStps l]</span>
<span class="lineno">  381 </span><span class="spaces">     </span><span class="nottickedoff">where partsplus :: Ord a =&gt; Int -&gt; Set a -&gt; [(Set (Set a), Set a)]</span>
<span class="lineno">  382 </span><span class="spaces">           </span><span class="nottickedoff">partsplus n ss = [ (p,Set.empty) | p&lt;-parts n ss ] ++ [ (Set.delete p prt, p) | prt&lt;-parts (n+1) ss, p&lt;-Set.toList prt ]</span>
<span class="lineno">  383 </span><span class="spaces">           </span><span class="nottickedoff">flatSet :: [RTerm] -&gt; RTerm</span>
<span class="lineno">  384 </span><span class="spaces">           </span><span class="nottickedoff">flatSet = normRT . rCombinator . Set.fromList . flat isrComb</span>
<span class="lineno">  385 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  386 </span><span class="spaces">  </span><span class="nottickedoff">matchableRules :: [(RTerm,[RTerm])]</span>
<span class="lineno">  387 </span><span class="spaces">  </span><span class="nottickedoff">matchableRules</span>
<span class="lineno">  388 </span><span class="spaces">   </span><span class="nottickedoff">= [ (template, rewriteTerms )     -- each tuple may represent multiple rules.</span>
<span class="lineno">  389 </span><span class="spaces">     </span><span class="nottickedoff">| cl&lt;-eqCl lTerm (concatMap f drs)  -- divide into classes to save a little on the number of matches.</span>
<span class="lineno">  390 </span><span class="spaces">     </span><span class="nottickedoff">, let template = lTerm (head cl)   -- This is the template against which to match full expressions.</span>
<span class="lineno">  391 </span><span class="spaces">     </span><span class="nottickedoff">, let rewriteTerms = stepTerms template cl</span>
<span class="lineno">  392 </span><span class="spaces">     </span><span class="nottickedoff">, not (null rewriteTerms)</span>
<span class="lineno">  393 </span><span class="spaces">     </span><span class="nottickedoff">]</span>
<span class="lineno">  394 </span><span class="spaces">     </span><span class="nottickedoff">where f (DEquR l r) = [DImpR l r, DImpR r l]</span>
<span class="lineno">  395 </span><span class="spaces">           </span><span class="nottickedoff">f implication = [implication]</span>
<span class="lineno">  396 </span><span class="spaces">           </span><span class="nottickedoff">stepTerms :: RTerm -&gt; [DerivRule] -&gt; [RTerm]</span>
<span class="lineno">  397 </span><span class="spaces">           </span><span class="nottickedoff">stepTerms template cl  -- Only select rules with bindings within the template. Otherwise, we would have to &quot;invent&quot; bindings.</span>
<span class="lineno">  398 </span><span class="spaces">            </span><span class="nottickedoff">= [term' | rule&lt;-cl, let term' = rTerm rule, vars term' `Set.isSubsetOf` vars template ]</span></span>
<span class="lineno">  399 </span>
<span class="lineno">  400 </span>{-
<span class="lineno">  401 </span>     showMatchableRules :: [(RTerm,[RTerm])] -&gt; String
<span class="lineno">  402 </span>     showMatchableRules rs
<span class="lineno">  403 </span>      = concat [&quot;\n   &quot;++showADL l++&quot; = &quot;++showADL t | (l,tms) &lt;- rs, t&lt;-tms ]
<span class="lineno">  404 </span>-}
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>splitList :: [a] -&gt; [([a],a,[a])]
<span class="lineno">  407 </span><span class="decl"><span class="nottickedoff">splitList lst = [(take i lst,l,drop (i+1) lst) | (i,l) &lt;- zip [0..] lst]</span></span>
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>instance Association RTerm where
<span class="lineno">  410 </span>  <span class="decl"><span class="nottickedoff">sign (RIsc a)      = sign$ Set.findMin a</span>
<span class="lineno">  411 </span><span class="spaces">  </span><span class="nottickedoff">sign (RUni a)      = sign$ Set.findMin a</span>
<span class="lineno">  412 </span><span class="spaces">  </span><span class="nottickedoff">sign (RDif a _)    = sign a</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="nottickedoff">sign (RCpl a)      = sign a</span>
<span class="lineno">  414 </span><span class="spaces">  </span><span class="nottickedoff">sign (RDia a b)    = Sign (source a) (target b)</span>
<span class="lineno">  415 </span><span class="spaces">  </span><span class="nottickedoff">sign (RLrs a b)    = Sign (source a) (source b)</span>
<span class="lineno">  416 </span><span class="spaces">  </span><span class="nottickedoff">sign (RRrs a b)    = Sign (target a) (target b)</span>
<span class="lineno">  417 </span><span class="spaces">  </span><span class="nottickedoff">sign (RRad as)     = Sign (source (head as)) (target (last as))</span>
<span class="lineno">  418 </span><span class="spaces">  </span><span class="nottickedoff">sign (RCps as)     = Sign (source (head as)) (target (last as))</span>
<span class="lineno">  419 </span><span class="spaces">  </span><span class="nottickedoff">sign (RPrd as)     = Sign (source (head as)) (target (last as))</span>
<span class="lineno">  420 </span><span class="spaces">  </span><span class="nottickedoff">sign (RKl0 a)      = sign a</span>
<span class="lineno">  421 </span><span class="spaces">  </span><span class="nottickedoff">sign (RKl1 a)      = sign a</span>
<span class="lineno">  422 </span><span class="spaces">  </span><span class="nottickedoff">sign (RFlp a)      = Sign (target a) (source a)</span>
<span class="lineno">  423 </span><span class="spaces">  </span><span class="nottickedoff">sign (RId  a)      = Sign a a</span>
<span class="lineno">  424 </span><span class="spaces">  </span><span class="nottickedoff">sign (RVee a b)    = Sign a b</span>
<span class="lineno">  425 </span><span class="spaces">  </span><span class="nottickedoff">sign (RAtm _ b)    = Sign b b</span>
<span class="lineno">  426 </span><span class="spaces">  </span><span class="nottickedoff">sign (RVar _ _ _)  = fatal 324 &quot;Cannot determine the sign of an RVar.&quot; -- This should become a haskell type-error when RTerm is polymorphic</span>
<span class="lineno">  427 </span><span class="spaces">  </span><span class="nottickedoff">sign (RConst e)    = sign e</span></span>
<span class="lineno">  428 </span>
<span class="lineno">  429 </span>-- In order to write deriviation rules in the Ampersand syntax, RTerms are obtained by means of the (already available) Ampersand parser.
<span class="lineno">  430 </span>-- For that reason, we need a function term2rTerm to translate a term obtained by parsing (type: Term TermPrim) to a RTerm.
<span class="lineno">  431 </span>term2rTerm :: Term TermPrim -&gt; RTerm
<span class="lineno">  432 </span><span class="decl"><span class="nottickedoff">term2rTerm term</span>
<span class="lineno">  433 </span><span class="spaces">   </span><span class="nottickedoff">= if isValid result then result else fatal 385 (&quot;term2rTerm has produced an invalid result: &quot;++showADL result)</span>
<span class="lineno">  434 </span><span class="spaces">     </span><span class="nottickedoff">where</span>
<span class="lineno">  435 </span><span class="spaces">      </span><span class="nottickedoff">result</span>
<span class="lineno">  436 </span><span class="spaces">       </span><span class="nottickedoff">= case term of</span>
<span class="lineno">  437 </span><span class="spaces">           </span><span class="nottickedoff">PEqu o l r               -&gt; term2rTerm (PIsc o (PImp o l r) (PImp o r l))</span>
<span class="lineno">  438 </span><span class="spaces">           </span><span class="nottickedoff">PImp o l r               -&gt; term2rTerm (PUni o (PCpl o l) r)</span>
<span class="lineno">  439 </span><span class="spaces">           </span><span class="nottickedoff">PIsc _ l r               -&gt; combSet RIsc (lSet `Set.union` rSet)</span>
<span class="lineno">  440 </span><span class="spaces">                                       </span><span class="nottickedoff">where lSet = case term2rTerm l of</span>
<span class="lineno">  441 </span><span class="spaces">                                                      </span><span class="nottickedoff">RIsc terms -&gt; terms</span>
<span class="lineno">  442 </span><span class="spaces">                                                      </span><span class="nottickedoff">trm        -&gt; Set.singleton trm</span>
<span class="lineno">  443 </span><span class="spaces">                                             </span><span class="nottickedoff">rSet = case term2rTerm r of</span>
<span class="lineno">  444 </span><span class="spaces">                                                      </span><span class="nottickedoff">RIsc terms -&gt; terms</span>
<span class="lineno">  445 </span><span class="spaces">                                                      </span><span class="nottickedoff">trm        -&gt; Set.singleton trm</span>
<span class="lineno">  446 </span><span class="spaces">           </span><span class="nottickedoff">PUni _ l r               -&gt; combSet RUni (lSet `Set.union` rSet)</span>
<span class="lineno">  447 </span><span class="spaces">                                       </span><span class="nottickedoff">where lSet = case term2rTerm l of</span>
<span class="lineno">  448 </span><span class="spaces">                                                      </span><span class="nottickedoff">RUni terms -&gt; terms</span>
<span class="lineno">  449 </span><span class="spaces">                                                      </span><span class="nottickedoff">trm        -&gt; Set.singleton trm</span>
<span class="lineno">  450 </span><span class="spaces">                                             </span><span class="nottickedoff">rSet = case term2rTerm r of</span>
<span class="lineno">  451 </span><span class="spaces">                                                      </span><span class="nottickedoff">RUni terms -&gt; terms</span>
<span class="lineno">  452 </span><span class="spaces">                                                      </span><span class="nottickedoff">trm        -&gt; Set.singleton trm</span>
<span class="lineno">  453 </span><span class="spaces">           </span><span class="nottickedoff">PDif _ l r               -&gt; RDif (term2rTerm l) (term2rTerm r)</span>
<span class="lineno">  454 </span><span class="spaces">           </span><span class="nottickedoff">PCpl _ e                 -&gt; RCpl (term2rTerm e)</span>
<span class="lineno">  455 </span><span class="spaces">           </span><span class="nottickedoff">PDia _ l r               -&gt; RDia (term2rTerm l) (term2rTerm r)</span>
<span class="lineno">  456 </span><span class="spaces">           </span><span class="nottickedoff">PLrs _ l r               -&gt; RLrs (term2rTerm l) (term2rTerm r)</span>
<span class="lineno">  457 </span><span class="spaces">           </span><span class="nottickedoff">PRrs _ l r               -&gt; RRrs (term2rTerm l) (term2rTerm r)</span>
<span class="lineno">  458 </span><span class="spaces">           </span><span class="nottickedoff">PRad _ l r               -&gt; RRad (lLst++rLst)</span>
<span class="lineno">  459 </span><span class="spaces">                                       </span><span class="nottickedoff">where lLst = case term2rTerm l of</span>
<span class="lineno">  460 </span><span class="spaces">                                                      </span><span class="nottickedoff">RRad terms -&gt; terms</span>
<span class="lineno">  461 </span><span class="spaces">                                                      </span><span class="nottickedoff">trm        -&gt; [trm]</span>
<span class="lineno">  462 </span><span class="spaces">                                             </span><span class="nottickedoff">rLst = case term2rTerm r of</span>
<span class="lineno">  463 </span><span class="spaces">                                                      </span><span class="nottickedoff">RRad terms -&gt; terms</span>
<span class="lineno">  464 </span><span class="spaces">                                                      </span><span class="nottickedoff">trm        -&gt; [trm]</span>
<span class="lineno">  465 </span><span class="spaces">           </span><span class="nottickedoff">PCps _ l r               -&gt; RCps (lLst++rLst)</span>
<span class="lineno">  466 </span><span class="spaces">                                       </span><span class="nottickedoff">where lLst = case term2rTerm l of</span>
<span class="lineno">  467 </span><span class="spaces">                                                      </span><span class="nottickedoff">RCps terms -&gt; terms</span>
<span class="lineno">  468 </span><span class="spaces">                                                      </span><span class="nottickedoff">trm        -&gt; [trm]</span>
<span class="lineno">  469 </span><span class="spaces">                                             </span><span class="nottickedoff">rLst = case term2rTerm r of</span>
<span class="lineno">  470 </span><span class="spaces">                                                      </span><span class="nottickedoff">RCps terms -&gt; terms</span>
<span class="lineno">  471 </span><span class="spaces">                                                      </span><span class="nottickedoff">trm        -&gt; [trm]</span>
<span class="lineno">  472 </span><span class="spaces">           </span><span class="nottickedoff">PPrd _ l r               -&gt; RPrd (lLst++rLst)</span>
<span class="lineno">  473 </span><span class="spaces">                                       </span><span class="nottickedoff">where lLst = case term2rTerm l of</span>
<span class="lineno">  474 </span><span class="spaces">                                                      </span><span class="nottickedoff">RPrd terms -&gt; terms</span>
<span class="lineno">  475 </span><span class="spaces">                                                      </span><span class="nottickedoff">trm        -&gt; [trm]</span>
<span class="lineno">  476 </span><span class="spaces">                                             </span><span class="nottickedoff">rLst = case term2rTerm r of</span>
<span class="lineno">  477 </span><span class="spaces">                                                      </span><span class="nottickedoff">RPrd terms -&gt; terms</span>
<span class="lineno">  478 </span><span class="spaces">                                                      </span><span class="nottickedoff">trm        -&gt; [trm]</span>
<span class="lineno">  479 </span><span class="spaces">           </span><span class="nottickedoff">PKl0 _ e                 -&gt; RKl0 (term2rTerm e)</span>
<span class="lineno">  480 </span><span class="spaces">           </span><span class="nottickedoff">PKl1 _ e                 -&gt; RKl1 (term2rTerm e)</span>
<span class="lineno">  481 </span><span class="spaces">           </span><span class="nottickedoff">PFlp _ e                 -&gt; RFlp (term2rTerm e)</span>
<span class="lineno">  482 </span><span class="spaces">           </span><span class="nottickedoff">PBrk _ e                 -&gt; term2rTerm e</span>
<span class="lineno">  483 </span><span class="spaces">           </span><span class="nottickedoff">Prim (PNamedR (PNamedRel _ str (Just sgn))) -&gt; RVar str (name (pSrc sgn)) (name (pTgt sgn))</span>
<span class="lineno">  484 </span><span class="spaces">           </span><span class="nottickedoff">Prim (Pid _ c)           -&gt; RId  (pCpt2aCpt c)</span>
<span class="lineno">  485 </span><span class="spaces">           </span><span class="nottickedoff">Prim (Pfull _ s t)       -&gt; RVee (pCpt2aCpt s) (pCpt2aCpt t)</span>
<span class="lineno">  486 </span><span class="spaces">           </span><span class="nottickedoff">Prim (Patm _ a (Just c)) -&gt; RAtm a (pCpt2aCpt c)</span>
<span class="lineno">  487 </span><span class="spaces">           </span><span class="nottickedoff">_                        -&gt; fatal 381 (&quot;Cannot cope with untyped &quot;++showADL term++&quot; in a dRule inside the normalizer.&quot;)</span></span>
<span class="lineno">  488 </span>
<span class="lineno">  489 </span>expr2RTerm :: Expression -&gt; RTerm
<span class="lineno">  490 </span><span class="decl"><span class="nottickedoff">expr2RTerm expr</span>
<span class="lineno">  491 </span><span class="spaces">   </span><span class="nottickedoff">= if isValid result then result else fatal 443 (&quot;expr2RTerm has produced an invalid result: &quot;++showADL result)</span>
<span class="lineno">  492 </span><span class="spaces">     </span><span class="nottickedoff">where</span>
<span class="lineno">  493 </span><span class="spaces">      </span><span class="nottickedoff">result</span>
<span class="lineno">  494 </span><span class="spaces">       </span><span class="nottickedoff">= case expr of</span>
<span class="lineno">  495 </span><span class="spaces">          </span><span class="nottickedoff">EEqu (l,r)           -&gt; expr2RTerm (EIsc (EImp (l,r), EImp (r,l)))</span>
<span class="lineno">  496 </span><span class="spaces">          </span><span class="nottickedoff">EImp (l,r)           -&gt; expr2RTerm (EUni (ECpl l, r))</span>
<span class="lineno">  497 </span><span class="spaces">          </span><span class="nottickedoff">EIsc (l,r)           -&gt; combSet RIsc (lSet `Set.union` rSet)</span>
<span class="lineno">  498 </span><span class="spaces">                                  </span><span class="nottickedoff">where lSet = case expr2RTerm l of</span>
<span class="lineno">  499 </span><span class="spaces">                                                 </span><span class="nottickedoff">RIsc terms -&gt; terms</span>
<span class="lineno">  500 </span><span class="spaces">                                                 </span><span class="nottickedoff">trm        -&gt; Set.singleton trm</span>
<span class="lineno">  501 </span><span class="spaces">                                        </span><span class="nottickedoff">rSet = case expr2RTerm r of</span>
<span class="lineno">  502 </span><span class="spaces">                                                 </span><span class="nottickedoff">RIsc terms -&gt; terms</span>
<span class="lineno">  503 </span><span class="spaces">                                                 </span><span class="nottickedoff">trm        -&gt; Set.singleton trm</span>
<span class="lineno">  504 </span><span class="spaces">          </span><span class="nottickedoff">EUni (l,r)           -&gt; combSet RUni (lSet `Set.union` rSet)</span>
<span class="lineno">  505 </span><span class="spaces">                                  </span><span class="nottickedoff">where lSet = case expr2RTerm l of</span>
<span class="lineno">  506 </span><span class="spaces">                                                 </span><span class="nottickedoff">RUni terms -&gt; terms</span>
<span class="lineno">  507 </span><span class="spaces">                                                 </span><span class="nottickedoff">trm        -&gt; Set.singleton trm</span>
<span class="lineno">  508 </span><span class="spaces">                                        </span><span class="nottickedoff">rSet = case expr2RTerm r of</span>
<span class="lineno">  509 </span><span class="spaces">                                                 </span><span class="nottickedoff">RUni terms -&gt; terms</span>
<span class="lineno">  510 </span><span class="spaces">                                                 </span><span class="nottickedoff">trm        -&gt; Set.singleton trm</span>
<span class="lineno">  511 </span><span class="spaces">          </span><span class="nottickedoff">EDif (l,r)           -&gt; RDif (expr2RTerm l) (expr2RTerm r)</span>
<span class="lineno">  512 </span><span class="spaces">          </span><span class="nottickedoff">ECpl e               -&gt; RCpl (expr2RTerm e)</span>
<span class="lineno">  513 </span><span class="spaces">          </span><span class="nottickedoff">EDia (l,r)           -&gt; RDia (expr2RTerm l) (expr2RTerm r)</span>
<span class="lineno">  514 </span><span class="spaces">          </span><span class="nottickedoff">ELrs (l,r)           -&gt; RLrs (expr2RTerm l) (expr2RTerm r)</span>
<span class="lineno">  515 </span><span class="spaces">          </span><span class="nottickedoff">ERrs (l,r)           -&gt; RRrs (expr2RTerm l) (expr2RTerm r)</span>
<span class="lineno">  516 </span><span class="spaces">          </span><span class="nottickedoff">ERad (l,r)           -&gt; RRad (lLst++rLst)</span>
<span class="lineno">  517 </span><span class="spaces">                                  </span><span class="nottickedoff">where lLst = case expr2RTerm l of</span>
<span class="lineno">  518 </span><span class="spaces">                                                 </span><span class="nottickedoff">RRad terms -&gt; terms</span>
<span class="lineno">  519 </span><span class="spaces">                                                 </span><span class="nottickedoff">trm        -&gt; [trm]</span>
<span class="lineno">  520 </span><span class="spaces">                                        </span><span class="nottickedoff">rLst = case expr2RTerm r of</span>
<span class="lineno">  521 </span><span class="spaces">                                                 </span><span class="nottickedoff">RRad terms -&gt; terms</span>
<span class="lineno">  522 </span><span class="spaces">                                                 </span><span class="nottickedoff">trm        -&gt; [trm]</span>
<span class="lineno">  523 </span><span class="spaces">          </span><span class="nottickedoff">ECps (l,r)           -&gt; RCps (lLst++rLst)</span>
<span class="lineno">  524 </span><span class="spaces">                                  </span><span class="nottickedoff">where lLst = case expr2RTerm l of</span>
<span class="lineno">  525 </span><span class="spaces">                                                 </span><span class="nottickedoff">RCps terms -&gt; terms</span>
<span class="lineno">  526 </span><span class="spaces">                                                 </span><span class="nottickedoff">trm        -&gt; [trm]</span>
<span class="lineno">  527 </span><span class="spaces">                                        </span><span class="nottickedoff">rLst = case expr2RTerm r of</span>
<span class="lineno">  528 </span><span class="spaces">                                                 </span><span class="nottickedoff">RCps terms -&gt; terms</span>
<span class="lineno">  529 </span><span class="spaces">                                                 </span><span class="nottickedoff">trm        -&gt; [trm]</span>
<span class="lineno">  530 </span><span class="spaces">          </span><span class="nottickedoff">EPrd (l,r)           -&gt; RPrd (lLst++rLst)</span>
<span class="lineno">  531 </span><span class="spaces">                                  </span><span class="nottickedoff">where lLst = case expr2RTerm l of</span>
<span class="lineno">  532 </span><span class="spaces">                                                 </span><span class="nottickedoff">RPrd terms -&gt; terms</span>
<span class="lineno">  533 </span><span class="spaces">                                                 </span><span class="nottickedoff">trm        -&gt; [trm]</span>
<span class="lineno">  534 </span><span class="spaces">                                        </span><span class="nottickedoff">rLst = case expr2RTerm r of</span>
<span class="lineno">  535 </span><span class="spaces">                                                 </span><span class="nottickedoff">RPrd terms -&gt; terms</span>
<span class="lineno">  536 </span><span class="spaces">                                                 </span><span class="nottickedoff">trm        -&gt; [trm]</span>
<span class="lineno">  537 </span><span class="spaces">          </span><span class="nottickedoff">EKl0 e               -&gt; RKl0 (expr2RTerm e)</span>
<span class="lineno">  538 </span><span class="spaces">          </span><span class="nottickedoff">EKl1 e               -&gt; RKl1 (expr2RTerm e)</span>
<span class="lineno">  539 </span><span class="spaces">          </span><span class="nottickedoff">EFlp e               -&gt; RFlp (expr2RTerm e)</span>
<span class="lineno">  540 </span><span class="spaces">          </span><span class="nottickedoff">EBrk e               -&gt; expr2RTerm e</span>
<span class="lineno">  541 </span><span class="spaces">          </span><span class="nottickedoff">EDcD{}               -&gt; RConst expr</span>
<span class="lineno">  542 </span><span class="spaces">          </span><span class="nottickedoff">EDcI c               -&gt; RId c</span>
<span class="lineno">  543 </span><span class="spaces">          </span><span class="nottickedoff">EEps{}               -&gt; RConst expr</span>
<span class="lineno">  544 </span><span class="spaces">          </span><span class="nottickedoff">EDcV sgn             -&gt; RVee (source sgn) (target sgn)</span>
<span class="lineno">  545 </span><span class="spaces">          </span><span class="nottickedoff">EMp1 a c             -&gt; RAtm a c</span></span>
<span class="lineno">  546 </span>--   --      _                    -&gt; RConst expr   -- This alternative has been commented out to avoid an &quot;overlapping patterns&quot; warning from Haskell.
<span class="lineno">  547 </span>
<span class="lineno">  548 </span>rTerm2expr :: RTerm -&gt; Expression
<span class="lineno">  549 </span>-- implementation note: because RTerms contain variables, it is cumbersome to reconstruct the type. So we don't.
<span class="lineno">  550 </span>-- Once the variables have been replaced (by means of substitutions) by real expressions, we get a type correct expression again.
<span class="lineno">  551 </span>-- As a consequence, we cannot use ./\., .\/., etc. in this code.
<span class="lineno">  552 </span><span class="decl"><span class="nottickedoff">rTerm2expr term</span>
<span class="lineno">  553 </span><span class="spaces"> </span><span class="nottickedoff">= case term of</span>
<span class="lineno">  554 </span><span class="spaces">     </span><span class="nottickedoff">RIsc rs    -&gt; case Set.toList (Set.map rTerm2expr rs) of</span>
<span class="lineno">  555 </span><span class="spaces">                    </span><span class="nottickedoff">[e] -&gt; e</span>
<span class="lineno">  556 </span><span class="spaces">                    </span><span class="nottickedoff">[]  -&gt; fatal 445 &quot;empty set in RIsc is illegal.&quot;</span>
<span class="lineno">  557 </span><span class="spaces">                    </span><span class="nottickedoff">es  -&gt; let oper l r = EIsc (l,r) in foldr1 oper es</span>
<span class="lineno">  558 </span><span class="spaces">     </span><span class="nottickedoff">RUni rs    -&gt; case Set.toList (Set.map rTerm2expr rs) of</span>
<span class="lineno">  559 </span><span class="spaces">                    </span><span class="nottickedoff">[e] -&gt; e</span>
<span class="lineno">  560 </span><span class="spaces">                    </span><span class="nottickedoff">[]  -&gt; fatal 449 &quot;empty set in RUni is illegal.&quot;</span>
<span class="lineno">  561 </span><span class="spaces">                    </span><span class="nottickedoff">es  -&gt; let oper l r = EUni (l,r) in foldr1 oper es</span>
<span class="lineno">  562 </span><span class="spaces">     </span><span class="nottickedoff">RDif l r   -&gt; EDif (rTerm2expr l, rTerm2expr r)</span>
<span class="lineno">  563 </span><span class="spaces">     </span><span class="nottickedoff">RCpl e     -&gt; ECpl (rTerm2expr e)</span>
<span class="lineno">  564 </span><span class="spaces">     </span><span class="nottickedoff">RDia l r   -&gt; EDia (rTerm2expr l, rTerm2expr r)</span>
<span class="lineno">  565 </span><span class="spaces">     </span><span class="nottickedoff">RLrs l r   -&gt; ELrs (rTerm2expr l, rTerm2expr r)</span>
<span class="lineno">  566 </span><span class="spaces">     </span><span class="nottickedoff">RRrs l r   -&gt; ERrs (rTerm2expr l, rTerm2expr r)</span>
<span class="lineno">  567 </span><span class="spaces">     </span><span class="nottickedoff">RRad rs    -&gt; case map rTerm2expr rs of</span>
<span class="lineno">  568 </span><span class="spaces">                    </span><span class="nottickedoff">[e] -&gt; e</span>
<span class="lineno">  569 </span><span class="spaces">                    </span><span class="nottickedoff">[]  -&gt; fatal 458 &quot;empty set in RRad is illegal.&quot;</span>
<span class="lineno">  570 </span><span class="spaces">                    </span><span class="nottickedoff">es  -&gt; let oper l r = ERad (l,r) in foldr1 oper es</span>
<span class="lineno">  571 </span><span class="spaces">     </span><span class="nottickedoff">RCps rs    -&gt; case map rTerm2expr rs of</span>
<span class="lineno">  572 </span><span class="spaces">                    </span><span class="nottickedoff">[e] -&gt; e</span>
<span class="lineno">  573 </span><span class="spaces">                    </span><span class="nottickedoff">[]  -&gt; fatal 462 &quot;empty set in RCps is illegal.&quot;</span>
<span class="lineno">  574 </span><span class="spaces">                    </span><span class="nottickedoff">es  -&gt; let oper l r = ECps (l,r) in foldr1 oper es</span>
<span class="lineno">  575 </span><span class="spaces">     </span><span class="nottickedoff">RPrd rs    -&gt; case map rTerm2expr rs of</span>
<span class="lineno">  576 </span><span class="spaces">                    </span><span class="nottickedoff">[e] -&gt; e</span>
<span class="lineno">  577 </span><span class="spaces">                    </span><span class="nottickedoff">[]  -&gt; fatal 466 &quot;empty set in RPrd is illegal.&quot;</span>
<span class="lineno">  578 </span><span class="spaces">                    </span><span class="nottickedoff">es  -&gt; let oper l r = EPrd (l,r) in foldr1 oper es</span>
<span class="lineno">  579 </span><span class="spaces">     </span><span class="nottickedoff">RKl0 e     -&gt; EKl0$ rTerm2expr e</span>
<span class="lineno">  580 </span><span class="spaces">     </span><span class="nottickedoff">RKl1 e     -&gt; EKl1$ rTerm2expr e</span>
<span class="lineno">  581 </span><span class="spaces">     </span><span class="nottickedoff">RFlp e     -&gt; EFlp$ rTerm2expr e</span>
<span class="lineno">  582 </span><span class="spaces">     </span><span class="nottickedoff">RVar r s t -&gt; EDcD (makeDecl r (Sign (makeConcept s) (makeConcept t)))</span>
<span class="lineno">  583 </span><span class="spaces">     </span><span class="nottickedoff">RId  c     -&gt; EDcI c</span>
<span class="lineno">  584 </span><span class="spaces">     </span><span class="nottickedoff">RVee s t   -&gt; EDcV (Sign s t)</span>
<span class="lineno">  585 </span><span class="spaces">     </span><span class="nottickedoff">RAtm a c   -&gt; EMp1 a c</span>
<span class="lineno">  586 </span><span class="spaces">     </span><span class="nottickedoff">RConst e   -&gt; e</span>
<span class="lineno">  587 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno">  588 </span><span class="spaces">     </span><span class="nottickedoff">makeDecl nm sgn</span>
<span class="lineno">  589 </span><span class="spaces">      </span><span class="nottickedoff">= Sgn { decnm   = nm</span>
<span class="lineno">  590 </span><span class="spaces">            </span><span class="nottickedoff">, decsgn  = sgn</span>
<span class="lineno">  591 </span><span class="spaces">            </span><span class="nottickedoff">, decprps = fatal 480 &quot;Illegal RTerm in rTerm2expr&quot;</span>
<span class="lineno">  592 </span><span class="spaces">            </span><span class="nottickedoff">, decprps_calc = Nothing</span>
<span class="lineno">  593 </span><span class="spaces">            </span><span class="nottickedoff">, decprL  = fatal 482 &quot;Illegal RTerm in rTerm2expr&quot;</span>
<span class="lineno">  594 </span><span class="spaces">            </span><span class="nottickedoff">, decprM  = fatal 483 &quot;Illegal RTerm in rTerm2expr&quot;</span>
<span class="lineno">  595 </span><span class="spaces">            </span><span class="nottickedoff">, decprR  = fatal 484 &quot;Illegal RTerm in rTerm2expr&quot;</span>
<span class="lineno">  596 </span><span class="spaces">            </span><span class="nottickedoff">, decMean = fatal 485 &quot;Illegal RTerm in rTerm2expr&quot;</span>
<span class="lineno">  597 </span><span class="spaces">            </span><span class="nottickedoff">, decfpos = fatal 486 &quot;Illegal RTerm in rTerm2expr&quot;</span>
<span class="lineno">  598 </span><span class="spaces">            </span><span class="nottickedoff">, deciss  = fatal 487 &quot;Illegal RTerm in rTerm2expr&quot;</span>
<span class="lineno">  599 </span><span class="spaces">            </span><span class="nottickedoff">, decusr  = fatal 488 &quot;Illegal RTerm in rTerm2expr&quot;</span>
<span class="lineno">  600 </span><span class="spaces">            </span><span class="nottickedoff">, decpat  = fatal 489 &quot;Illegal RTerm in rTerm2expr&quot;</span>
<span class="lineno">  601 </span><span class="spaces">            </span><span class="nottickedoff">, decplug = fatal 490 &quot;Illegal RTerm in rTerm2expr&quot;</span>
<span class="lineno">  602 </span><span class="spaces">            </span><span class="nottickedoff">}</span>
<span class="lineno">  603 </span><span class="spaces">     </span><span class="nottickedoff">makeConcept &quot;ONE&quot; = ONE</span>
<span class="lineno">  604 </span><span class="spaces">     </span><span class="nottickedoff">makeConcept  str  = </span>
<span class="lineno">  605 </span><span class="spaces">        </span><span class="nottickedoff">PlainConcept { cptnm = str</span>
<span class="lineno">  606 </span><span class="spaces">                     </span><span class="nottickedoff">}</span></span>
<span class="lineno">  607 </span>
<span class="lineno">  608 </span>instance ShowADL RTerm where
<span class="lineno">  609 </span> <span class="decl"><span class="nottickedoff">showADL = showExpr 0</span>
<span class="lineno">  610 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno">  611 </span><span class="spaces">     </span><span class="nottickedoff">(   inter,   union',  diff,  lresi, rresi,  rDia,   rMul,rAdd,rPrd,closK0,closK1,flp',compl,   lpar, rpar, lbr, star,  rbr)</span>
<span class="lineno">  612 </span><span class="spaces">      </span><span class="nottickedoff">= (&quot; /\\ &quot;, &quot; \\/ &quot;, &quot; - &quot;, &quot; / &quot;, &quot; \\ &quot;, &quot; &lt;&gt; &quot;, &quot;;&quot;, &quot;!&quot;, &quot;*&quot;, &quot;*&quot;  , &quot;+&quot;,   &quot;~&quot;, (&quot;-&quot;++), &quot;(&quot;,  &quot;)&quot;,  &quot;[&quot;, &quot;*&quot;,   &quot;]&quot;)</span>
<span class="lineno">  613 </span><span class="spaces">     </span><span class="nottickedoff">showExpr :: Int -&gt; RTerm -&gt; String</span>
<span class="lineno">  614 </span><span class="spaces">     </span><span class="nottickedoff">showExpr i expr</span>
<span class="lineno">  615 </span><span class="spaces">      </span><span class="nottickedoff">= case expr of</span>
<span class="lineno">  616 </span><span class="spaces">          </span><span class="nottickedoff">RIsc ls    -&gt; wrap i 2 (intercalate inter  [showExpr 3 e | e&lt;-Set.toList ls ])</span>
<span class="lineno">  617 </span><span class="spaces">          </span><span class="nottickedoff">RUni ls    -&gt; wrap i 2 (intercalate union' [showExpr 3 e | e&lt;-Set.toList ls ])</span>
<span class="lineno">  618 </span><span class="spaces">          </span><span class="nottickedoff">RDif l r   -&gt; wrap i 4 (showExpr 5 l++diff++showExpr 5 r)</span>
<span class="lineno">  619 </span><span class="spaces">          </span><span class="nottickedoff">RLrs l r   -&gt; wrap i 6 (showExpr 7 l++lresi++showExpr 7 r)</span>
<span class="lineno">  620 </span><span class="spaces">          </span><span class="nottickedoff">RRrs l r   -&gt; wrap i 6 (showExpr 7 l++rresi++showExpr 7 r)</span>
<span class="lineno">  621 </span><span class="spaces">          </span><span class="nottickedoff">RDia l r   -&gt; wrap i 6 (showExpr 7 l++rDia ++showExpr 7 r)</span>
<span class="lineno">  622 </span><span class="spaces">          </span><span class="nottickedoff">RCps ls    -&gt; wrap i 2 (intercalate rMul [showExpr 3 e | e&lt;-ls ])</span>
<span class="lineno">  623 </span><span class="spaces">          </span><span class="nottickedoff">RRad ls    -&gt; wrap i 2 (intercalate rAdd [showExpr 3 e | e&lt;-ls ])</span>
<span class="lineno">  624 </span><span class="spaces">          </span><span class="nottickedoff">RPrd ls    -&gt; wrap i 2 (intercalate rPrd [showExpr 3 e | e&lt;-ls ])</span>
<span class="lineno">  625 </span><span class="spaces">          </span><span class="nottickedoff">RKl0 e     -&gt; wrap i 9 (showExpr 9 e++closK0)</span>
<span class="lineno">  626 </span><span class="spaces">          </span><span class="nottickedoff">RKl1 e     -&gt; wrap i 9 (showExpr 9 e++closK1)</span>
<span class="lineno">  627 </span><span class="spaces">          </span><span class="nottickedoff">RFlp e     -&gt; wrap i 9 (showExpr 9 e++flp')</span>
<span class="lineno">  628 </span><span class="spaces">          </span><span class="nottickedoff">RCpl e     -&gt; wrap i 9 (compl (showExpr 10 e))</span>
<span class="lineno">  629 </span><span class="spaces">          </span><span class="nottickedoff">RVar r s t -&gt; r++lbr++s++star++t++rbr</span>
<span class="lineno">  630 </span><span class="spaces">          </span><span class="nottickedoff">RConst e   -&gt; wrap i i (showADL e)</span>
<span class="lineno">  631 </span><span class="spaces">          </span><span class="nottickedoff">RId c      -&gt; &quot;I&quot;++lbr++name c++rbr</span>
<span class="lineno">  632 </span><span class="spaces">          </span><span class="nottickedoff">RVee s t   -&gt; &quot;V&quot;++lbr++name s++star++name t++rbr</span>
<span class="lineno">  633 </span><span class="spaces">          </span><span class="nottickedoff">RAtm a c   -&gt; &quot;'&quot;++a++&quot;'&quot;++lbr++name c++rbr</span>
<span class="lineno">  634 </span><span class="spaces">     </span><span class="nottickedoff">wrap :: Int -&gt; Int -&gt; String -&gt; String</span>
<span class="lineno">  635 </span><span class="spaces">     </span><span class="nottickedoff">wrap i j e' = if i&lt;=j then e' else lpar++e'++rpar</span></span>
<span class="lineno">  636 </span>
<span class="lineno">  637 </span>{- momentarily redundant
<span class="lineno">  638 </span>   unVar :: RTerm -&gt; String
<span class="lineno">  639 </span>   unVar (RVar r _ _) = r
<span class="lineno">  640 </span>   unVar _ = fatal 501 &quot;Illegal call on unVar&quot;
<span class="lineno">  641 </span>-}
<span class="lineno">  642 </span>
<span class="lineno">  643 </span>vars :: RTerm -&gt; Set String
<span class="lineno">  644 </span><span class="decl"><span class="nottickedoff">vars (RIsc rs)     = (Set.unions . map vars . Set.toList) rs</span>
<span class="lineno">  645 </span><span class="spaces"></span><span class="nottickedoff">vars (RUni rs)     = (Set.unions . map vars . Set.toList) rs</span>
<span class="lineno">  646 </span><span class="spaces"></span><span class="nottickedoff">vars (RDif l r)    = vars l `Set.union` vars r</span>
<span class="lineno">  647 </span><span class="spaces"></span><span class="nottickedoff">vars (RCpl e)      = vars e</span>
<span class="lineno">  648 </span><span class="spaces"></span><span class="nottickedoff">vars (RDia l r)    = vars l `Set.union` vars r</span>
<span class="lineno">  649 </span><span class="spaces"></span><span class="nottickedoff">vars (RLrs l r)    = vars l `Set.union` vars r</span>
<span class="lineno">  650 </span><span class="spaces"></span><span class="nottickedoff">vars (RRrs l r)    = vars l `Set.union` vars r</span>
<span class="lineno">  651 </span><span class="spaces"></span><span class="nottickedoff">vars (RRad rs)     = foldr Set.union Set.empty (map vars rs)</span>
<span class="lineno">  652 </span><span class="spaces"></span><span class="nottickedoff">vars (RCps rs)     = foldr Set.union Set.empty (map vars rs)</span>
<span class="lineno">  653 </span><span class="spaces"></span><span class="nottickedoff">vars (RPrd rs)     = foldr Set.union Set.empty (map vars rs)</span>
<span class="lineno">  654 </span><span class="spaces"></span><span class="nottickedoff">vars (RKl0 e)      = vars e</span>
<span class="lineno">  655 </span><span class="spaces"></span><span class="nottickedoff">vars (RKl1 e)      = vars e</span>
<span class="lineno">  656 </span><span class="spaces"></span><span class="nottickedoff">vars (RFlp e)      = vars e</span>
<span class="lineno">  657 </span><span class="spaces"></span><span class="nottickedoff">vars (RId  c)      = Set.fromList [name c]</span>
<span class="lineno">  658 </span><span class="spaces"></span><span class="nottickedoff">vars (RVee s t)    = Set.fromList [name s, name t]</span>
<span class="lineno">  659 </span><span class="spaces"></span><span class="nottickedoff">vars (RVar r s t)  = Set.fromList [r, s, t]</span>
<span class="lineno">  660 </span><span class="spaces"></span><span class="nottickedoff">vars (RConst{})    = Set.empty</span>
<span class="lineno">  661 </span><span class="spaces"></span><span class="nottickedoff">vars  RAtm{}       = Set.empty</span></span>
<span class="lineno">  662 </span>
<span class="lineno">  663 </span>data DerivRule = DEquR { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lTerm</span></span></span> :: RTerm
<span class="lineno">  664 </span>                       , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">rTerm</span></span></span> :: RTerm
<span class="lineno">  665 </span>                       }
<span class="lineno">  666 </span>               | DImpR { lTerm :: RTerm
<span class="lineno">  667 </span>                       , rTerm :: RTerm
<span class="lineno">  668 </span>                       }
<span class="lineno">  669 </span>
<span class="lineno">  670 </span>instance Show DerivRule where
<span class="lineno">  671 </span>  <span class="decl"><span class="nottickedoff">showsPrec _ r@DEquR{}  = showString (showADL (lTerm r)++&quot; = &quot; ++showADL (rTerm r))</span>
<span class="lineno">  672 </span><span class="spaces">  </span><span class="nottickedoff">showsPrec _ r@DImpR{}  = showString (showADL (lTerm r)++&quot; |- &quot;++showADL (rTerm r))</span></span>
<span class="lineno">  673 </span>
<span class="lineno">  674 </span>-- For documentation purposes, the derivation rule which proves the step is included.
<span class="lineno">  675 </span>
<span class="lineno">  676 </span>data DerivStep = DStep { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lhs</span></span></span> :: RTerm
<span class="lineno">  677 </span>                       , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">rul</span></span></span> :: (RTerm,Unifier,RTerm)
<span class="lineno">  678 </span>                       , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">rhs</span></span></span> :: RTerm
<span class="lineno">  679 </span>                       }
<span class="lineno">  680 </span>
<span class="lineno">  681 </span>-- instance Show DerivStep where
<span class="lineno">  682 </span>--  showsPrec _ r@DStep{}  = showString (&quot;    &quot;++showADL (lhs r)++&quot;\n =  {&quot; ++show (rul r)++&quot;}\n    &quot; ++showADL (rhs r))
<span class="lineno">  683 </span>
<span class="lineno">  684 </span>
<span class="lineno">  685 </span>
<span class="lineno">  686 </span>dRule :: Term TermPrim -&gt; [DerivRule]
<span class="lineno">  687 </span><span class="decl"><span class="nottickedoff">dRule (PEqu _ l r) = [DEquR { lTerm=term2rTerm l, rTerm=term2rTerm r }]</span>
<span class="lineno">  688 </span><span class="spaces"></span><span class="nottickedoff">dRule (PImp _ l r) = [DImpR { lTerm=term2rTerm l, rTerm=term2rTerm r }]</span>
<span class="lineno">  689 </span><span class="spaces"></span><span class="nottickedoff">dRule term         = fatal 279 (&quot;Illegal use of dRule with term &quot;++show term)</span></span>
<span class="lineno">  690 </span>
<span class="lineno">  691 </span>slideDown :: (RTerm -&gt; Integer) -&gt; RTerm -&gt; [(Integer,DerivStep)]
<span class="lineno">  692 </span><span class="decl"><span class="nottickedoff">slideDown weight term</span>
<span class="lineno">  693 </span><span class="spaces"> </span><span class="nottickedoff">= let w = weight term in</span>
<span class="lineno">  694 </span><span class="spaces">   </span><span class="nottickedoff">case [dstep | dstep&lt;-dSteps tceDerivRules term, weight (rhs dstep)&lt;w] of</span>
<span class="lineno">  695 </span><span class="spaces">     </span><span class="nottickedoff">dstep: _ -&gt; (w,dstep): (slideDown weight) (rhs dstep)</span>
<span class="lineno">  696 </span><span class="spaces">     </span><span class="nottickedoff">_        -&gt; []</span></span>
<span class="lineno">  697 </span>
<span class="lineno">  698 </span>weightNF :: Bool -&gt; RTerm -&gt; Integer
<span class="lineno">  699 </span><span class="decl"><span class="nottickedoff">weightNF dnf term = w term</span>
<span class="lineno">  700 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno">  701 </span><span class="spaces">  </span><span class="nottickedoff">w :: RTerm -&gt; Integer</span>
<span class="lineno">  702 </span><span class="spaces">  </span><span class="nottickedoff">w trm</span>
<span class="lineno">  703 </span><span class="spaces">   </span><span class="nottickedoff">= case trm of</span>
<span class="lineno">  704 </span><span class="spaces">       </span><span class="nottickedoff">RIsc ls  -&gt; (sum (map w (Set.toList ls))) * if dnf then 1 else 2</span>
<span class="lineno">  705 </span><span class="spaces">       </span><span class="nottickedoff">RUni ls  -&gt; (sum (map w (Set.toList ls))) * if dnf then 2 else 1</span>
<span class="lineno">  706 </span><span class="spaces">       </span><span class="nottickedoff">RDif l r -&gt; (w l+w r+10) * 4</span>
<span class="lineno">  707 </span><span class="spaces">       </span><span class="nottickedoff">RCpl e   -&gt; (w e + 1) * 4</span>
<span class="lineno">  708 </span><span class="spaces">       </span><span class="nottickedoff">RDia l r -&gt; (w l+w r+10) * 4</span>
<span class="lineno">  709 </span><span class="spaces">       </span><span class="nottickedoff">RLrs l r -&gt; (w l+w r+10) * 4</span>
<span class="lineno">  710 </span><span class="spaces">       </span><span class="nottickedoff">RRrs l r -&gt; (w l+w r+10) * 4</span>
<span class="lineno">  711 </span><span class="spaces">       </span><span class="nottickedoff">RRad ls  -&gt; (sum (map w ls)+1)*4</span>
<span class="lineno">  712 </span><span class="spaces">       </span><span class="nottickedoff">RCps ls  -&gt; (sum (map w ls)+1)*4</span>
<span class="lineno">  713 </span><span class="spaces">       </span><span class="nottickedoff">RPrd ls  -&gt; (sum (map w ls)+1)*4</span>
<span class="lineno">  714 </span><span class="spaces">       </span><span class="nottickedoff">RKl0 e   -&gt; (w e + 1) * 4</span>
<span class="lineno">  715 </span><span class="spaces">       </span><span class="nottickedoff">RKl1 e   -&gt; (w e + 1) * 4</span>
<span class="lineno">  716 </span><span class="spaces">       </span><span class="nottickedoff">RFlp e   -&gt; (w e + 1) * 8</span>
<span class="lineno">  717 </span><span class="spaces">       </span><span class="nottickedoff">_        -&gt; 1</span></span>
<span class="lineno">  718 </span>
<span class="lineno">  719 </span>-- If  'matches d expr'  yields  'Just ss', then  'substitute anything ss (lTerm d) == expr'
<span class="lineno">  720 </span>
<span class="lineno">  721 </span>type Unifier = Set (String, RTerm)
<span class="lineno">  722 </span>
<span class="lineno">  723 </span>instance ShowADL Unifier where
<span class="lineno">  724 </span>  <span class="decl"><span class="nottickedoff">showADL s = &quot;{&quot;++intercalate &quot;, &quot; [ str++&quot;-&gt;&quot;++showADL t | (str,t)&lt;-Set.toList s ]++&quot;}&quot;</span></span>
<span class="lineno">  725 </span>
<span class="lineno">  726 </span>substitute :: String    -- A string to document fatals
<span class="lineno">  727 </span>           -&gt; Unifier   -- the substitution, which in reality is a set of string/expression pairs.
<span class="lineno">  728 </span>           -&gt; RTerm     -- The term to be transformed to an expression, with all variables replaced by subexpressions
<span class="lineno">  729 </span>           -&gt; RTerm
<span class="lineno">  730 </span><span class="decl"><span class="nottickedoff">substitute ruleDoc unifier term</span>
<span class="lineno">  731 </span><span class="spaces"> </span><span class="nottickedoff">= if isValid result then result else fatal 713 (&quot;substitute has produced an invalid result: &quot;++showADL result)</span>
<span class="lineno">  732 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno">  733 </span><span class="spaces">    </span><span class="nottickedoff">result = subs term</span>
<span class="lineno">  734 </span><span class="spaces">    </span><span class="nottickedoff">subs :: RTerm -&gt; RTerm</span>
<span class="lineno">  735 </span><span class="spaces">    </span><span class="nottickedoff">subs t | not (isValid t) = fatal 680 (&quot;Substituting an invalid term &quot;++showADL t)</span>
<span class="lineno">  736 </span><span class="spaces">    </span><span class="nottickedoff">subs (RIsc s)     = (combSet RIsc . Set.fromList . flat isRIsc . map subs . Set.toList) s</span>
<span class="lineno">  737 </span><span class="spaces">    </span><span class="nottickedoff">subs (RUni s)     = (combSet RUni . Set.fromList . flat isRUni . map subs . Set.toList) s</span>
<span class="lineno">  738 </span><span class="spaces">    </span><span class="nottickedoff">subs (RDif l r)   = RDif (subs l) (subs r)</span>
<span class="lineno">  739 </span><span class="spaces">    </span><span class="nottickedoff">subs (RLrs l r)   = RLrs (subs l) (subs r)</span>
<span class="lineno">  740 </span><span class="spaces">    </span><span class="nottickedoff">subs (RRrs l r)   = RRrs (subs l) (subs r)</span>
<span class="lineno">  741 </span><span class="spaces">    </span><span class="nottickedoff">subs (RDia l r)   = RDia (subs l) (subs r)</span>
<span class="lineno">  742 </span><span class="spaces">    </span><span class="nottickedoff">subs (RCps ls)    = (RCps . flat isRCps . map subs) ls</span>
<span class="lineno">  743 </span><span class="spaces">    </span><span class="nottickedoff">subs (RRad ls)    = (RRad . flat isRRad . map subs) ls</span>
<span class="lineno">  744 </span><span class="spaces">    </span><span class="nottickedoff">subs (RPrd ls)    = (RPrd . flat isRPrd . map subs) ls</span>
<span class="lineno">  745 </span><span class="spaces">    </span><span class="nottickedoff">subs (RKl0 e  )   = RKl0 (subs e)</span>
<span class="lineno">  746 </span><span class="spaces">    </span><span class="nottickedoff">subs (RKl1 e  )   = RKl1 (subs e)</span>
<span class="lineno">  747 </span><span class="spaces">    </span><span class="nottickedoff">subs (RFlp e  )   = RFlp (subs e)</span>
<span class="lineno">  748 </span><span class="spaces">    </span><span class="nottickedoff">subs (RCpl e  )   = RCpl (subs e)</span>
<span class="lineno">  749 </span><span class="spaces">    </span><span class="nottickedoff">subs (RVar r _ _) = case [ e | (v,e)&lt;-Set.toList unifier, v==r] of</span>
<span class="lineno">  750 </span><span class="spaces">                           </span><span class="nottickedoff">[e] -&gt; e</span>
<span class="lineno">  751 </span><span class="spaces">                           </span><span class="nottickedoff">[] -&gt;  fatal 378 (&quot;Rule:  &quot;++ruleDoc++&quot;\nVariable &quot;++r++&quot; is not in term &quot;++showADL term++ &quot; using unifier &quot;++show unifier)</span>
<span class="lineno">  752 </span><span class="spaces">                           </span><span class="nottickedoff">-- e.g. Variable r is not in term -V[A*B] /\ r[A*B] using unifier fromList [(&quot;A&quot;,RId Verzoek),(&quot;B&quot;,RId Persoon)]</span>
<span class="lineno">  753 </span><span class="spaces">                           </span><span class="nottickedoff">es -&gt;  fatal 379 (&quot;Rule:  &quot;++ruleDoc++&quot;\nVariable &quot;++r++&quot; in term &quot;++showADL term++&quot; has been bound to multiple expressions:\n   &quot;++intercalate &quot;\n   &quot; [showADL e | e&lt;-es])</span>
<span class="lineno">  754 </span><span class="spaces">    </span><span class="nottickedoff">subs (RId c)      = case [ e | (v,e)&lt;-Set.toList unifier, v==name c] of</span>
<span class="lineno">  755 </span><span class="spaces">                           </span><span class="nottickedoff">[e] -&gt; e  -- This is e@(RId c')</span>
<span class="lineno">  756 </span><span class="spaces">                           </span><span class="nottickedoff">[]  -&gt; fatal 382 (&quot;Rule:  &quot;++ruleDoc++&quot;\nVariable &quot;++name c++&quot; is not in term &quot;++showADL term)</span>
<span class="lineno">  757 </span><span class="spaces">                           </span><span class="nottickedoff">es  -&gt; fatal 383 (&quot;Rule:  &quot;++ruleDoc++&quot;\nVariable &quot;++name c++&quot; in term &quot;++showADL term++&quot; has been bound to multiple expressions:\n   &quot;++intercalate &quot;\n   &quot; [showADL e | e&lt;-es])</span>
<span class="lineno">  758 </span><span class="spaces">    </span><span class="nottickedoff">subs (RVee s t)   = case ([ e | (v,e)&lt;-Set.toList unifier, v==name s], [ e | (v,e)&lt;-Set.toList unifier, v==name t]) of</span>
<span class="lineno">  759 </span><span class="spaces">                           </span><span class="nottickedoff">([RId s'], [RId t']) -&gt; RVee s' t'</span>
<span class="lineno">  760 </span><span class="spaces">                           </span><span class="nottickedoff">(_,_)  -&gt; fatal 386 (&quot;Rule:  &quot;++ruleDoc++&quot;\nSomething wrong with RVee in term &quot;++showADL term++&quot; with unifier &quot;++show unifier)</span>
<span class="lineno">  761 </span><span class="spaces">    </span><span class="nottickedoff">subs (RAtm a c)   = case [ e | (v,e)&lt;-Set.toList unifier, v==name c] of</span>
<span class="lineno">  762 </span><span class="spaces">                           </span><span class="nottickedoff">[RId c'] -&gt; RAtm a c'</span>
<span class="lineno">  763 </span><span class="spaces">                           </span><span class="nottickedoff">[]  -&gt; fatal 389 (&quot;Rule:  &quot;++ruleDoc++&quot;\nVariable &quot;++name c++&quot; is not in term &quot;++showADL term)</span>
<span class="lineno">  764 </span><span class="spaces">                           </span><span class="nottickedoff">es  -&gt; fatal 390 (&quot;Rule:  &quot;++ruleDoc++&quot;\nVariable &quot;++name c++&quot; in term &quot;++showADL term++&quot; has been bound to multiple expressions:\n   &quot;++intercalate &quot;\n   &quot; [showADL e | e&lt;-es])</span>
<span class="lineno">  765 </span><span class="spaces">    </span><span class="nottickedoff">subs e@RConst{}   = e</span></span>
<span class="lineno">  766 </span>--     subs t            = fatal 392 (&quot;Rule:  &quot;++ruleDoc++&quot;\nError: &quot;++showADL t++&quot;is not a variable.&quot;)  -- commented out, because it causes Haskell to emit an overlapping pattern warning.
<span class="lineno">  767 </span>
<span class="lineno">  768 </span>flat :: (RTerm -&gt; Bool) -&gt; [RTerm] -&gt; [RTerm]
<span class="lineno">  769 </span><span class="decl"><span class="nottickedoff">flat isrComb ls</span>
<span class="lineno">  770 </span><span class="spaces"> </span><span class="nottickedoff">= case ls of</span>
<span class="lineno">  771 </span><span class="spaces">    </span><span class="nottickedoff">[]  -&gt; fatal 689 &quot;Illegal empty list&quot;</span>
<span class="lineno">  772 </span><span class="spaces">    </span><span class="nottickedoff">es  -&gt; concat [ if isrComb e then rTermListForSets e else [e] | e&lt;-es]</span></span>
<span class="lineno">  773 </span>--     es  -&gt; if or [isrComb e | e&lt;-es]   -- SJ: Apparently, the recursion in 'flat' is required. Without it, Misc/Kernmodel.adl did fail on 18 aug 2014.
<span class="lineno">  774 </span>--            then (flat isrComb . concat) [ if isrComb e then rTermListForSets e else [e] | e&lt;-es]
<span class="lineno">  775 </span>--            else es
<span class="lineno">  776 </span>rTermListForSets :: RTerm -&gt; [RTerm]
<span class="lineno">  777 </span><span class="decl"><span class="nottickedoff">rTermListForSets (RIsc s) = Set.toList s</span>
<span class="lineno">  778 </span><span class="spaces"></span><span class="nottickedoff">rTermListForSets (RUni s) = Set.toList s</span>
<span class="lineno">  779 </span><span class="spaces"></span><span class="nottickedoff">rTermListForSets x = rTermList x</span></span>
<span class="lineno">  780 </span>
<span class="lineno">  781 </span>matches :: RTerm -&gt; RTerm -&gt; [Unifier]
<span class="lineno">  782 </span><span class="decl"><span class="nottickedoff">matches term expr</span>
<span class="lineno">  783 </span><span class="spaces">  </span><span class="nottickedoff">= if not (isValid term) then fatal 719 (&quot;Invalid term &quot;++showADL term++&quot;\nbeing matched to expression &quot;++showADL expr) else</span>
<span class="lineno">  784 </span><span class="spaces">    </span><span class="nottickedoff">if not (isValid expr) then fatal 720 (&quot;Matching term &quot;++showADL term++&quot;\nto invalid expression &quot;++showADL expr) else</span>
<span class="lineno">  785 </span><span class="spaces">    </span><span class="nottickedoff">case (term,expr) of</span>
<span class="lineno">  786 </span><span class="spaces">     </span><span class="nottickedoff">(RIsc es,        RIsc es')   -&gt; matchSets RIsc es es'</span>
<span class="lineno">  787 </span><span class="spaces">     </span><span class="nottickedoff">(RUni es,        RUni es')   -&gt; matchSets RUni es es'</span>
<span class="lineno">  788 </span><span class="spaces">     </span><span class="nottickedoff">(RDif l r,       RDif l' r') -&gt; matches l l' ++ matches r r'</span>
<span class="lineno">  789 </span><span class="spaces">     </span><span class="nottickedoff">(RLrs l r,       RLrs l' r') -&gt; matches l l' ++ matches r r'</span>
<span class="lineno">  790 </span><span class="spaces">     </span><span class="nottickedoff">(RRrs l r,       RRrs l' r') -&gt; matches l l' ++ matches r r'</span>
<span class="lineno">  791 </span><span class="spaces">     </span><span class="nottickedoff">(RDia l r,       RDia l' r') -&gt; matches l l' ++ matches r r'</span>
<span class="lineno">  792 </span><span class="spaces">     </span><span class="nottickedoff">(RCps ls,        RCps ls')   -&gt; matchLists RCps ls ls'</span>
<span class="lineno">  793 </span><span class="spaces">     </span><span class="nottickedoff">(RRad ls,        RRad ls')   -&gt; matchLists RRad ls ls'</span>
<span class="lineno">  794 </span><span class="spaces">     </span><span class="nottickedoff">(RPrd ls,        RPrd ls')   -&gt; matchLists RPrd ls ls'</span>
<span class="lineno">  795 </span><span class="spaces">     </span><span class="nottickedoff">(RKl0 e,         RKl0 e')    -&gt; matches e e'</span>
<span class="lineno">  796 </span><span class="spaces">     </span><span class="nottickedoff">(RKl1 e,         RKl1 e')    -&gt; matches e e'</span>
<span class="lineno">  797 </span><span class="spaces">     </span><span class="nottickedoff">(RFlp e,         RFlp e')    -&gt; matches e e'</span>
<span class="lineno">  798 </span><span class="spaces">     </span><span class="nottickedoff">(RCpl e,         RCpl e')    -&gt; matches e e'</span>
<span class="lineno">  799 </span><span class="spaces">     </span><span class="nottickedoff">(RId  c,         RId _     ) -&gt; [Set.fromList [(name c,expr)]]</span>
<span class="lineno">  800 </span><span class="spaces">     </span><span class="nottickedoff">(RVee s t,       RVee s' t') -&gt; [Set.fromList [(name s,RId s'), (name t,RId t')]]</span>
<span class="lineno">  801 </span><span class="spaces">     </span><span class="nottickedoff">(RVar v s t,     _         ) -&gt; [Set.fromList [(v,expr),(s,RId (source expr)),(t,RId (target expr))]]</span>
<span class="lineno">  802 </span><span class="spaces">     </span><span class="nottickedoff">(RAtm a c,       RAtm a' c') -&gt; [Set.singleton (name c,RId c') | a==a']</span>
<span class="lineno">  803 </span><span class="spaces">     </span><span class="nottickedoff">(RConst e,       RConst e' ) -&gt; [Set.empty | e==e']</span>
<span class="lineno">  804 </span><span class="spaces">     </span><span class="nottickedoff">(_, _)                       -&gt; []</span></span>
<span class="lineno">  805 </span>
<span class="lineno">  806 </span>matchLists :: ([RTerm] -&gt; RTerm) -&gt; [RTerm] -&gt; [RTerm] -&gt; [Unifier]
<span class="lineno">  807 </span><span class="decl"><span class="nottickedoff">matchLists rCombinator es es'</span>
<span class="lineno">  808 </span><span class="spaces"> </span><span class="nottickedoff">= if not (isValid (combLst rCombinator es) ) then fatal 754 (&quot;Invalid term &quot; ++showADL (rCombinator es)++&quot;\nbeing matched to expression &quot;++showADL (rCombinator es')) else</span>
<span class="lineno">  809 </span><span class="spaces">   </span><span class="nottickedoff">if not (isValid (combLst rCombinator es')) then fatal 755 (&quot;Matching term &quot;++showADL (rCombinator es)++&quot;\nto invalid expression &quot; ++showADL (rCombinator es')) else</span>
<span class="lineno">  810 </span><span class="spaces">   </span><span class="nottickedoff">[ unif</span>
<span class="lineno">  811 </span><span class="spaces">   </span><span class="nottickedoff">| let n = length es              -- the length of the template, which contains variables</span>
<span class="lineno">  812 </span><span class="spaces">   </span><span class="nottickedoff">, if n==0 then fatal 681 &quot;n equals 0&quot; else True</span>
<span class="lineno">  813 </span><span class="spaces">   </span><span class="nottickedoff">, ms &lt;- dist n es'     -- determine segments from es' (which is variable free) that have the same length as the template es</span>
<span class="lineno">  814 </span><span class="spaces">   </span><span class="nottickedoff">, if or [null m | m&lt;-ms]</span>
<span class="lineno">  815 </span><span class="spaces">     </span><span class="nottickedoff">then fatal 683 (concat [&quot;\nms:  [&quot;++intercalate &quot;, &quot; (map showADL m)++&quot;]&quot; | m&lt;-ms])</span>
<span class="lineno">  816 </span><span class="spaces">     </span><span class="nottickedoff">else True</span>
<span class="lineno">  817 </span><span class="spaces">   </span><span class="nottickedoff">, let subTerms = map (combLst rCombinator) ms     -- make an RTerm from each sublist in ms</span>
<span class="lineno">  818 </span><span class="spaces">   </span><span class="nottickedoff">, unif&lt;-mix [ matches l r | (l,r)&lt;-safezip es subTerms ]</span>
<span class="lineno">  819 </span><span class="spaces">   </span><span class="nottickedoff">, noDoubles unif                 -- if one variable, v, is bound to more than one different expressions, the deal is off.</span>
<span class="lineno">  820 </span><span class="spaces">   </span><span class="nottickedoff">]</span>
<span class="lineno">  821 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno">  822 </span><span class="spaces">     </span><span class="nottickedoff">dist :: Int -&gt; [a] -&gt; [[[a]]]</span>
<span class="lineno">  823 </span><span class="spaces">     </span><span class="nottickedoff">dist 1 ls = [[ls]]</span>
<span class="lineno">  824 </span><span class="spaces">     </span><span class="nottickedoff">dist 2 ls = [ [ take i ls , drop i ls ] | i&lt;-[1..length ls-1] ]</span>
<span class="lineno">  825 </span><span class="spaces">     </span><span class="nottickedoff">dist n ls = [ init ds++st | ds&lt;-dist (n-1) ls, let staart=last ds, length staart&gt;=2, st&lt;-dist 2 staart ]</span></span>
<span class="lineno">  826 </span>     {- examples:
<span class="lineno">  827 </span>     dist 1 &quot;abcd&quot; = [[&quot;abcd&quot;]]
<span class="lineno">  828 </span>     dist 2 &quot;abcd&quot; = [[&quot;a&quot;,&quot;bcd&quot;],[&quot;ab&quot;,&quot;cd&quot;],[&quot;abc&quot;,&quot;d&quot;]]
<span class="lineno">  829 </span>     dist 3 &quot;abcd&quot; = [[&quot;a&quot;,&quot;b&quot;,&quot;cd&quot;],[&quot;a&quot;,&quot;bc&quot;,&quot;d&quot;],[&quot;ab&quot;,&quot;c&quot;,&quot;d&quot;]]
<span class="lineno">  830 </span>     dist 3 &quot;abcdef&quot; =
<span class="lineno">  831 </span>        [ [&quot;a&quot;,&quot;b&quot;,&quot;cdef&quot;]
<span class="lineno">  832 </span>        , [&quot;a&quot;,&quot;bc&quot;,&quot;def&quot;]
<span class="lineno">  833 </span>        , [&quot;a&quot;,&quot;bcd&quot;,&quot;ef&quot;]
<span class="lineno">  834 </span>        , [&quot;a&quot;,&quot;bcde&quot;,&quot;f&quot;]
<span class="lineno">  835 </span>        , [&quot;ab&quot;,&quot;c&quot;,&quot;def&quot;]
<span class="lineno">  836 </span>        , [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]
<span class="lineno">  837 </span>        , [&quot;ab&quot;,&quot;cde&quot;,&quot;f&quot;]
<span class="lineno">  838 </span>        , [&quot;abc&quot;,&quot;d&quot;,&quot;ef&quot;]
<span class="lineno">  839 </span>        , [&quot;abc&quot;,&quot;de&quot;,&quot;f&quot;]
<span class="lineno">  840 </span>        , [&quot;abcd&quot;,&quot;e&quot;,&quot;f&quot;]
<span class="lineno">  841 </span>        ]
<span class="lineno">  842 </span>     -}
<span class="lineno">  843 </span>mix :: [[Unifier]] -&gt; [Unifier]
<span class="lineno">  844 </span><span class="decl"><span class="nottickedoff">mix (ls:lss) = [ Set.union e str | e&lt;-ls, str&lt;-mix lss ]</span>
<span class="lineno">  845 </span><span class="spaces"></span><span class="nottickedoff">mix []       = [Set.empty]</span></span>
<span class="lineno">  846 </span>{- example:
<span class="lineno">  847 </span>   mix [&quot;12&quot;,&quot;xyz&quot;,&quot;&quot;,&quot;p&quot;] = [] -- (because the fourth element did not match!)
<span class="lineno">  848 </span>   mix [&quot;12&quot;,&quot;xyz&quot;,&quot;p&quot;]    = [&quot;1xp&quot;,&quot;1yp&quot;,&quot;1zp&quot;,&quot;2xp&quot;,&quot;2yp&quot;,&quot;2zp&quot;]
<span class="lineno">  849 </span>-}
<span class="lineno">  850 </span>matchSets :: (Set RTerm -&gt; RTerm) -&gt; Set RTerm -&gt; Set RTerm -&gt; [Unifier]
<span class="lineno">  851 </span><span class="decl"><span class="nottickedoff">matchSets rCombinator es es'</span>
<span class="lineno">  852 </span><span class="spaces"> </span><span class="nottickedoff">= -- set sizes are not necessarily equal.</span>
<span class="lineno">  853 </span><span class="spaces">   </span><span class="nottickedoff">if Set.null es || Set.null es' then fatal 858 &quot;cannot match empty sets&quot; else</span>
<span class="lineno">  854 </span><span class="spaces">   </span><span class="nottickedoff">if or [ not (isValid e) | e&lt;-Set.toList es ] then fatal 859 (&quot;Invalid subterm(s): &quot;++intercalate &quot;, &quot; [ showADL e | e&lt;-Set.toList es,  not (isValid e) ]) else</span>
<span class="lineno">  855 </span><span class="spaces">   </span><span class="nottickedoff">if or [ not (isValid e) | e&lt;-Set.toList es'] then fatal 860 (&quot;Invalid subexpr(s): &quot;++intercalate &quot;, &quot; [ showADL e | e&lt;-Set.toList es', not (isValid e) ]) else</span>
<span class="lineno">  856 </span><span class="spaces">   </span><span class="nottickedoff">[ unif</span>
<span class="lineno">  857 </span><span class="spaces">   </span><span class="nottickedoff">| let n = Set.size cdes                      -- the length of the template, which contains variables</span>
<span class="lineno">  858 </span><span class="spaces">   </span><span class="nottickedoff">, partition &lt;- parts n cdes'                 -- determine segments from the expression with the same length. partition :: Set (Set RTerm)</span>
<span class="lineno">  859 </span><span class="spaces">   </span><span class="nottickedoff">, let subTerms = Set.map (combSet rCombinator) partition      -- make an RTerm from each subset in ms. subTerms :: Set RTerm</span>
<span class="lineno">  860 </span><span class="spaces">   </span><span class="nottickedoff">, template &lt;- permutations (Set.toList cdes)</span>
<span class="lineno">  861 </span><span class="spaces">   </span><span class="nottickedoff">, unif &lt;- mix [ matches l r | (l,r) &lt;- safezip template (Set.toList subTerms) ]</span>
<span class="lineno">  862 </span><span class="spaces">   </span><span class="nottickedoff">, noDoubles unif                 -- if one variable, v, is bound to more than one different expressions, the deal is off.</span>
<span class="lineno">  863 </span><span class="spaces">   </span><span class="nottickedoff">]</span>
<span class="lineno">  864 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno">  865 </span><span class="spaces">     </span><span class="nottickedoff">isct  = es `Set.intersection` es'            -- E.g.:  {'Piet'}</span>
<span class="lineno">  866 </span><span class="spaces">     </span><span class="nottickedoff">cdes  = es  `Set.difference` isct            -- the terms of es that are not in es' (a set of templates). E.g.: { r;s }</span>
<span class="lineno">  867 </span><span class="spaces">     </span><span class="nottickedoff">cdes' = es' `Set.difference` isct</span></span>            -- candidates for binding to a variable: { a\b , a;b;c , d , e;f }  (a set of expressions)
<span class="lineno">  868 </span>
<span class="lineno">  869 </span>separate :: Ord a =&gt; Int -&gt; Set a -&gt; [(Set a, Set a)]
<span class="lineno">  870 </span><span class="decl"><span class="nottickedoff">separate n s = [ (part, s `Set.difference` part) | part &lt;- subsetLength n (Set.toList s) ]</span>
<span class="lineno">  871 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno">  872 </span><span class="spaces">   </span><span class="nottickedoff">subsetLength :: Ord a =&gt; Int -&gt; [a] -&gt; [Set a]</span>
<span class="lineno">  873 </span><span class="spaces">   </span><span class="nottickedoff">subsetLength 0 _      = [Set.empty]</span>
<span class="lineno">  874 </span><span class="spaces">   </span><span class="nottickedoff">subsetLength i (x:xs) = map (Set.insert x) (subsetLength (i-1) xs) ++ subsetLength i xs</span>
<span class="lineno">  875 </span><span class="spaces">   </span><span class="nottickedoff">subsetLength _ []     = []</span></span>
<span class="lineno">  876 </span>
<span class="lineno">  877 </span> -- parts produces a fixed number of subsets
<span class="lineno">  878 </span>parts :: Ord a =&gt; Int -&gt; Set a -&gt; [Set (Set a)]  -- ,   but within this where clause we must make it more specific.
<span class="lineno">  879 </span><span class="decl"><span class="nottickedoff">parts n xsss = (Set.toList . Set.fromList . map Set.fromList . map (map Set.fromList) . p n . Set.toList) xsss</span>
<span class="lineno">  880 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno">  881 </span><span class="spaces">   </span><span class="nottickedoff">p :: Eq a =&gt; Int -&gt; [a] -&gt; [[[a]]]</span>
<span class="lineno">  882 </span><span class="spaces">   </span><span class="nottickedoff">p 0 _  = []</span>
<span class="lineno">  883 </span><span class="spaces">   </span><span class="nottickedoff">p 1 xs = [ [xs] ]</span>
<span class="lineno">  884 </span><span class="spaces">   </span><span class="nottickedoff">p 2 xs = [ [ss,rest] | ss&lt;-init (subsets xs), let rest=[ e | e&lt;-xs, e `notElem` ss ], not (null rest) ]</span>
<span class="lineno">  885 </span><span class="spaces">   </span><span class="nottickedoff">p i xs = [ twoSets++tl | (hd:tl)&lt;-p (i-1) xs, twoSets&lt;-p 2 hd ]</span>
<span class="lineno">  886 </span><span class="spaces"></span><span class="nottickedoff">{- examples:</span>
<span class="lineno">  887 </span><span class="spaces">   </span><span class="nottickedoff">parts 1 &quot;abcd&quot; = {{&quot;abcd&quot;}}</span>
<span class="lineno">  888 </span><span class="spaces">   </span><span class="nottickedoff">parts 2 &quot;abcd&quot; = {{&quot;a&quot;,&quot;bcd&quot;},{&quot;ab&quot;,&quot;cd&quot;},{&quot;abc&quot;,&quot;d&quot;},{&quot;abd&quot;,&quot;c&quot;},{&quot;ac&quot;,&quot;bd&quot;},{&quot;acd&quot;,&quot;b&quot;},{&quot;ad&quot;,&quot;bc&quot;}}</span>
<span class="lineno">  889 </span><span class="spaces">   </span><span class="nottickedoff">parts 3 &quot;abcd&quot; = {{&quot;a&quot;,&quot;b&quot;,&quot;cd&quot;},{&quot;a&quot;,&quot;bc&quot;,&quot;d&quot;},{&quot;a&quot;,&quot;bd&quot;,&quot;c&quot;},{&quot;ab&quot;,&quot;c&quot;,&quot;d&quot;},{&quot;ac&quot;,&quot;b&quot;,&quot;d&quot;},{&quot;ad&quot;,&quot;b&quot;,&quot;c&quot;}}</span>
<span class="lineno">  890 </span><span class="spaces">   </span><span class="nottickedoff">parts 4 &quot;abcd&quot; = {{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;}}</span>
<span class="lineno">  891 </span><span class="spaces">   </span><span class="nottickedoff">parts 3 &quot;abcde&quot;</span>
<span class="lineno">  892 </span><span class="spaces">    </span><span class="nottickedoff">= { {&quot;a&quot;,&quot;b&quot;,&quot;cde&quot;},{&quot;a&quot;,&quot;bc&quot;,&quot;de&quot;},{&quot;a&quot;,&quot;bcd&quot;,&quot;e&quot;},{&quot;a&quot;,&quot;bce&quot;,&quot;d&quot;},{&quot;a&quot;,&quot;bd&quot;,&quot;ce&quot;},{&quot;a&quot;,&quot;bde&quot;,&quot;c&quot;}</span>
<span class="lineno">  893 </span><span class="spaces">      </span><span class="nottickedoff">, {&quot;a&quot;,&quot;be&quot;,&quot;cd&quot;},{&quot;ab&quot;,&quot;c&quot;,&quot;de&quot;},{&quot;ab&quot;,&quot;cd&quot;,&quot;e&quot;},{&quot;ab&quot;,&quot;ce&quot;,&quot;d&quot;},{&quot;abc&quot;,&quot;d&quot;,&quot;e&quot;},{&quot;abd&quot;,&quot;c&quot;,&quot;e&quot;}</span>
<span class="lineno">  894 </span><span class="spaces">      </span><span class="nottickedoff">, {&quot;abe&quot;,&quot;c&quot;,&quot;d&quot;},{&quot;ac&quot;,&quot;b&quot;,&quot;de&quot;},{&quot;ac&quot;,&quot;bd&quot;,&quot;e&quot;},{&quot;ac&quot;,&quot;be&quot;,&quot;d&quot;},{&quot;acd&quot;,&quot;b&quot;,&quot;e&quot;},{&quot;ace&quot;,&quot;b&quot;,&quot;d&quot;}</span>
<span class="lineno">  895 </span><span class="spaces">      </span><span class="nottickedoff">, {&quot;ad&quot;,&quot;b&quot;,&quot;ce&quot;},{&quot;ad&quot;,&quot;bc&quot;,&quot;e&quot;},{&quot;ad&quot;,&quot;be&quot;,&quot;c&quot;},{&quot;ade&quot;,&quot;b&quot;,&quot;c&quot;},{&quot;ae&quot;,&quot;b&quot;,&quot;cd&quot;},{&quot;ae&quot;,&quot;bc&quot;,&quot;d&quot;}</span>
<span class="lineno">  896 </span><span class="spaces">      </span><span class="nottickedoff">, {&quot;ae&quot;,&quot;bd&quot;,&quot;c&quot;}</span>
<span class="lineno">  897 </span><span class="spaces">      </span><span class="nottickedoff">}</span>
<span class="lineno">  898 </span><span class="spaces">   </span><span class="nottickedoff">parts 6 &quot;abcde&quot; = {}</span>
<span class="lineno">  899 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno">  900 </span><span class="spaces">   </span><span class="nottickedoff">subsets :: [a] -&gt; [[a]]</span>
<span class="lineno">  901 </span><span class="spaces">   </span><span class="nottickedoff">subsets []  = [[]]</span>
<span class="lineno">  902 </span><span class="spaces">   </span><span class="nottickedoff">subsets (x:xs) = map (x:) (subsets xs) ++ subsets xs</span></span>
<span class="lineno">  903 </span>
<span class="lineno">  904 </span>combLst :: ([RTerm] -&gt; RTerm) -&gt; [RTerm] -&gt; RTerm
<span class="lineno">  905 </span><span class="decl"><span class="nottickedoff">combLst rCombinator es</span>
<span class="lineno">  906 </span><span class="spaces"> </span><span class="nottickedoff">= case es of</span>
<span class="lineno">  907 </span><span class="spaces">        </span><span class="nottickedoff">[]  -&gt; fatal 791 &quot;Not allowed.&quot;</span>
<span class="lineno">  908 </span><span class="spaces">        </span><span class="nottickedoff">[e] -&gt; e</span>
<span class="lineno">  909 </span><span class="spaces">        </span><span class="nottickedoff">_   -&gt; rCombinator es</span></span>
<span class="lineno">  910 </span>
<span class="lineno">  911 </span>combSet :: (Set RTerm -&gt; RTerm) -&gt; Set RTerm -&gt; RTerm
<span class="lineno">  912 </span><span class="decl"><span class="nottickedoff">combSet rCombinator s</span>
<span class="lineno">  913 </span><span class="spaces"> </span><span class="nottickedoff">= case Set.toList s of</span>
<span class="lineno">  914 </span><span class="spaces">        </span><span class="nottickedoff">[]  -&gt; fatal 798 &quot;Not allowed.&quot;</span>
<span class="lineno">  915 </span><span class="spaces">        </span><span class="nottickedoff">[e] -&gt; e</span>
<span class="lineno">  916 </span><span class="spaces">        </span><span class="nottickedoff">_   -&gt; rCombinator s</span></span>
<span class="lineno">  917 </span>
<span class="lineno">  918 </span>-- Example: noDoubles { p-&gt;A;B, q-&gt;'Piet', p-&gt;'Z', r-&gt;A* } is False, because p binds two different expressions.
<span class="lineno">  919 </span>noDoubles :: Unifier -&gt; Bool
<span class="lineno">  920 </span><span class="decl"><span class="nottickedoff">noDoubles unif = and [ n==1 | n&lt;-(map length . eqCl fst . Set.toList) unif ]</span></span>
<span class="lineno">  921 </span>
<span class="lineno">  922 </span>safezip :: [a] -&gt; [b] -&gt; [(a,b)]
<span class="lineno">  923 </span><span class="decl"><span class="nottickedoff">safezip (a:as) (b:bs) = (a,b):safezip as bs</span>
<span class="lineno">  924 </span><span class="spaces"></span><span class="nottickedoff">safezip [] [] = []</span>
<span class="lineno">  925 </span><span class="spaces"></span><span class="nottickedoff">safezip _ _ = fatal 827 &quot;Zip of two lists with different lengths!&quot;</span></span>
<span class="lineno">  926 </span>
<span class="lineno">  927 </span>{-
<span class="lineno">  928 </span>   assignments {a,p} {2,3,4}
<span class="lineno">  929 </span>=
<span class="lineno">  930 </span>   { {(a,2), (p,3)}, {(a,2), (p,4)}, {(a,3), (p,4)}, {(a,3), (p,4)}, {(a,4), (p,4)}, {(a,4), (p,3)} }
<span class="lineno">  931 </span>
<span class="lineno">  932 </span>   assignments :: (Ord a, Ord b) =&gt; Set a -&gt; Set b -&gt; [Set (a,b)]
<span class="lineno">  933 </span>   assignments xs ys = map Set.fromList (recur (Set.toList xs) (Set.toList ys))
<span class="lineno">  934 </span>    where
<span class="lineno">  935 </span>      recur [] _ = [[]]
<span class="lineno">  936 </span>      recur (v:vs) es = [ (v,e):pairs | e&lt;-es, pairs&lt;-recur vs [e' | e'&lt;-es, e'/=e ] ]
<span class="lineno">  937 </span>
<span class="lineno">  938 </span>-- The function 'names' exists for the purpose of hashing.
<span class="lineno">  939 </span>   names :: RTerm -&gt; [String]
<span class="lineno">  940 </span>   names term = nub (nms term)
<span class="lineno">  941 </span>    where nms trm = case trm of
<span class="lineno">  942 </span>                        RIsc ls    -&gt; (nub . concatMap nms . Set.toList) ls
<span class="lineno">  943 </span>                        RUni ls    -&gt; (nub . concatMap nms . Set.toList) ls
<span class="lineno">  944 </span>                        RDif l r   -&gt; nms l++nms r
<span class="lineno">  945 </span>                        RLrs l r   -&gt; nms l++nms r
<span class="lineno">  946 </span>                        RRrs l r   -&gt; nms l++nms r
<span class="lineno">  947 </span>                        RDia l r   -&gt; nms l++nms r
<span class="lineno">  948 </span>                        RCps ls    -&gt; (nub . concatMap nms) ls
<span class="lineno">  949 </span>                        RRad ls    -&gt; (nub . concatMap nms) ls
<span class="lineno">  950 </span>                        RPrd ls    -&gt; (nub . concatMap nms) ls
<span class="lineno">  951 </span>                        RKl0 e     -&gt; nms e
<span class="lineno">  952 </span>                        RKl1 e     -&gt; nms e
<span class="lineno">  953 </span>                        RFlp e     -&gt; nms e
<span class="lineno">  954 </span>                        RCpl e     -&gt; nms e
<span class="lineno">  955 </span>                        RVar r s t -&gt; [r++&quot;:&quot;++s++&quot;*&quot;++t]
<span class="lineno">  956 </span>                        RId c      -&gt; [&quot;I[&quot;++name c++&quot;]&quot;]
<span class="lineno">  957 </span>                        RVee s t   -&gt; [&quot;V[&quot;++name s++&quot;*&quot;++name t++&quot;]&quot;]
<span class="lineno">  958 </span>                        RAtm a c   -&gt; [&quot;'&quot;++a++&quot;'[&quot;++name c++&quot;]&quot;]
<span class="lineno">  959 </span>                        RConst e   -&gt; [showADL e]
<span class="lineno">  960 </span>-}
<span class="lineno">  961 </span>
<span class="lineno">  962 </span>-- In order to write rules for the normalizer in a legible manner, I am using the Ampersand parser.
<span class="lineno">  963 </span>-- The terminal symbols, except I and V, are interpreted as variables in these rules.
<span class="lineno">  964 </span>-- As these rules may be used in two directions, all concept variables that are used on one side must be used on the other side as well.
<span class="lineno">  965 </span>-- relation names r, s, q are used as relation variables and A, B, C are used as concept variables.
<span class="lineno">  966 </span>-- If rules are ill formed, this will result in fatal errors.
<span class="lineno">  967 </span>
<span class="lineno">  968 </span>-- Type conserving equivalences: The following equivalences have an identical signature on either side.
<span class="lineno">  969 </span>tceDerivRules :: [DerivRule]
<span class="lineno">  970 </span><span class="decl"><span class="nottickedoff">tceDerivRules = concatMap (dRule.parseRule)</span>
<span class="lineno">  971 </span><span class="spaces"></span><span class="nottickedoff">--    [ &quot;r[A*B]\\/s[A*B] = s[A*B]\\/r[A*B]&quot;                         --  Commutativity of \/</span>
<span class="lineno">  972 </span><span class="spaces"></span><span class="nottickedoff">--    , &quot;r[A*B]/\\s[A*B] = s[A*B]/\\r[A*B]&quot;                         --  Commutativity of /\</span>
<span class="lineno">  973 </span><span class="spaces"></span><span class="nottickedoff">--    , &quot;(r[A*B]\\/s[A*B])\\/q[A*B] = r[A*B]\\/(s[A*B]\\/q[A*B])&quot;   --  Associativity of \/</span>
<span class="lineno">  974 </span><span class="spaces"></span><span class="nottickedoff">--    , &quot;(r[A*B]/\\s[A*B])/\\q[A*B] = r[A*B]/\\(s[A*B]/\\q[A*B])&quot;   --  Associativity of /\</span>
<span class="lineno">  975 </span><span class="spaces"></span><span class="nottickedoff">--    , &quot;(r[A*B];s[B*C]);q[C*D] = r[A*B];(s[B*C];q[C*D])&quot;           --  Associativity of ;</span>
<span class="lineno">  976 </span><span class="spaces"></span><span class="nottickedoff">--    , &quot;(r[A*B]#s[B*C])#q[C*D] = r[A*B]#(s[B*C]#q[C*D])&quot;           --  Associativity of #</span>
<span class="lineno">  977 </span><span class="spaces"></span><span class="nottickedoff">--    , &quot;(r[A*B]!s[B*C])!q[C*D] = r[A*B]!(s[B*C]!q[C*D])&quot;           --  Associativity of !</span>
<span class="lineno">  978 </span><span class="spaces"> </span><span class="nottickedoff">[ &quot;-(-r[A*B]) = r[A*B]&quot;                                       --  Double negation</span>
<span class="lineno">  979 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;(r[A*B]~)~ = r[A*B]&quot;                                       --  Double flip</span>
<span class="lineno">  980 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;-(r[A*B]~) = (-r[A*B])~&quot;                                   --  Peirce's[A*A] trick, which allows us to write -r[A*A]~</span>
<span class="lineno">  981 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;-r[A*B]/\\-s[A*B] = -(r[A*B]\\/s[A*B])&quot;                    --  De Morgan</span>
<span class="lineno">  982 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;-r[A*B]\\/-s[A*B] = -(r[A*B]/\\s[A*B])&quot;                    --  De Morgan</span>
<span class="lineno">  983 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;-r[B*A];-s[A*C] = -(r[B*A]!s[A*C])&quot;                        --  De Morgan</span>
<span class="lineno">  984 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;-r[B*A]!-s[A*C] = -(r[B*A];s[A*C])&quot;                        --  De Morgan</span>
<span class="lineno">  985 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*B]~/\\s[A*B]~ = (r[A*B]/\\s[A*B])~&quot;                    --  Distribute flip</span>
<span class="lineno">  986 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*B]~\\/s[A*B]~ = (r[A*B]\\/s[A*B])~&quot;                    --  Distribute flip</span>
<span class="lineno">  987 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;(r[A*A]\\r[A*A]);(r[A*A]\\r[A*A]) = r[A*A]\\r[A*A]&quot;        --  Jipsen&amp;Tsinakis</span>
<span class="lineno">  988 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;(r[A*A]/r[A*A]);(r[A*A]/r[A*A]) = r[A*A]/r[A*A]&quot;           --  Jipsen&amp;Tsinakis</span>
<span class="lineno">  989 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*A];(r[A*A]\\r[A*A]) = r[A*A]&quot;                          --  Jipsen&amp;Tsinakis</span>
<span class="lineno">  990 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;(r[A*A]/r[A*A]);r[A*A] = r[A*A]&quot;                           --  Jipsen&amp;Tsinakis</span>
<span class="lineno">  991 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;I[A];r[A*B] = r[A*B]&quot;</span>
<span class="lineno">  992 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*B];I[B] = r[A*B]&quot;</span>
<span class="lineno">  993 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;(r[A*B]\\/s[A*B]);q[B*C] = r[A*B];q[B*C]\\/s[A*B];q[B*C]&quot;  --  Distribution</span>
<span class="lineno">  994 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*B];(s[B*C]\\/q[B*C]) = r[A*B];s[B*C]\\/r[A*B];q[B*C]&quot;  --  Distribution</span>
<span class="lineno">  995 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;-r[A*B]~!s[A*C] = r[A*B]\\s[A*C]&quot;                          --  eliminate dagger</span>
<span class="lineno">  996 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;-r[A*B]!s[B*C] = r[A*B]~\\s[B*C]&quot;                          --  eliminate dagger</span>
<span class="lineno">  997 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*C]!-s[B*C]~ = r[A*C]/s[B*C]&quot;                           --  eliminate dagger</span>
<span class="lineno">  998 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*C]!-s[C*B] = r[A*C]/s[C*B]~&quot;                           --  eliminate dagger</span>
<span class="lineno">  999 </span><span class="spaces"></span><span class="nottickedoff">--  , &quot;r[A*B]#s[B*C]#q[C*D] = r[A*B]#q[C*D]&quot;                      --  eliminate middle in cartesian product -- conditie toevoegen: s[A*B] /= -V</span>
<span class="lineno"> 1000 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*B]/\\r[A*B] = r[A*B]&quot;                                  --  Absorb equals</span>
<span class="lineno"> 1001 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*B]\\/r[A*B] = r[A*B]&quot;                                  --  Absorb equals</span>
<span class="lineno"> 1002 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*B]/\\V[A*B] = r[A*B]&quot;                                  --  Absorb V</span>
<span class="lineno"> 1003 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;V[A*B]/\\r[A*B] = r[A*B]&quot;                                  --  Absorb V</span>
<span class="lineno"> 1004 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*B]/\\-V[A*B] = -V[A*B]&quot;                                --  Contradiction</span>
<span class="lineno"> 1005 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;-V[A*B]/\\r[A*B] = -V[A*B]&quot;                                --  Contradiction</span>
<span class="lineno"> 1006 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*B]\\/V[A*B] = V[A*B]&quot;                                  --  Tautology</span>
<span class="lineno"> 1007 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*B]\\/-V[A*B] = r[A*B]&quot;                                 --  Absorb -V</span>
<span class="lineno"> 1008 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*B]/\\-r[A*B] = -V[A*B]&quot;                                --  Contradiction</span>
<span class="lineno"> 1009 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*B]\\/-r[A*B] =  V[A*B]&quot;                                --  Tautology</span>
<span class="lineno"> 1010 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;-r[A*B]\\/r[A*B] = V[A*B]&quot;                                 --  Tautology</span>
<span class="lineno"> 1011 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;(r[A*B]\\/ s[A*B])/\\ s[A*B] = s[A*B]&quot;                      --  Absorption</span>
<span class="lineno"> 1012 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;(r[A*B]\\/-s[A*B])/\\ s[A*B] = s[A*B]-r[A*B]&quot;               --  Absorption</span>
<span class="lineno"> 1013 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;(r[A*B]/\\ s[A*B])\\/ s[A*B] = s[A*B]&quot;                      --  Absorption</span>
<span class="lineno"> 1014 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;(r[A*B]/\\-s[A*B])\\/ s[A*B] = r[A*B]\\/s[A*B]&quot;             --  Absorption</span>
<span class="lineno"> 1015 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;(r[A*B]/\\ s[A*B])\\/-s[A*B] = r[A*B]\\/-s[A*B]&quot;            --  Absorption</span>
<span class="lineno"> 1016 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*A]* = r[A*A];r[A*A]*&quot;</span>
<span class="lineno"> 1017 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*A]* = r[A*A]*;r[A*A]&quot;</span>
<span class="lineno"> 1018 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*A]+ = r[A*A];r[A*A]+&quot;</span>
<span class="lineno"> 1019 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;r[A*A]+ = r[A*A]+;r[A*A]&quot;</span>
<span class="lineno"> 1020 </span><span class="spaces"> </span><span class="nottickedoff">, &quot;I[A]\\/r[A*A]+ = r[A*A]*&quot;</span>
<span class="lineno"> 1021 </span><span class="spaces"> </span><span class="nottickedoff">]</span></span>
<span class="lineno"> 1022 </span>
<span class="lineno"> 1023 </span>{-
<span class="lineno"> 1024 </span>-- Type conserving implications: The following implications have an identical signature on either side.
<span class="lineno"> 1025 </span>tciDerivRules :: [DerivRule]
<span class="lineno"> 1026 </span>tciDerivRules = concatMap (dRule.parseRule)
<span class="lineno"> 1027 </span> [ &quot;(r[A*B]\\I[A]);s[A*C] |- r[A*B]\\s[A*C]&quot;                   --  T{r\\I[A]}=[B*A] ; T{(r\\I[A]);s}=[B*C] ; T{r\\s}=[B*C] ; Jipsen&amp;Tsinakis
<span class="lineno"> 1028 </span> , &quot;r[A*C];(I[C]/s[B*C]) |- r[A*C]/s[B*C]&quot;                     --  Jipsen&amp;Tsinakis
<span class="lineno"> 1029 </span> , &quot;(r[A*B]\\s[A*C]);q[C*D] |- r[A*B]\\(s[A*C];q[C*D])&quot;        --  Jipsen&amp;Tsinakis
<span class="lineno"> 1030 </span> , &quot;r[A*B];(s[B*C]/q[D*C]) |- (r[A*B];s[B*C])/q[D*C]&quot;          --  Jipsen&amp;Tsinakis
<span class="lineno"> 1031 </span> , &quot;(r[A*B]\\s[A*C]);(s[A*C]\\q[A*D]) |- r[A*B]\\q[A*D]&quot;       --  Jipsen&amp;Tsinakis
<span class="lineno"> 1032 </span> , &quot;(r[A*B]/s[A*C]);(s[A*C]/q[D*B]) |- r[A*B]/q[D*B]&quot;          --  Jipsen&amp;Tsinakis
<span class="lineno"> 1033 </span> , &quot;r[A*B];(s[B*C]!q[C*D]) |- (r[A*B];s[B*C])!q[C*D]&quot;          --  Peirce
<span class="lineno"> 1034 </span> , &quot;(r[A*B]!s[B*C]);q[C*D] |- r[A*B]!(s[B*C];q[C*D])&quot;          --  Peirce
<span class="lineno"> 1035 </span> , &quot;(r[A*B]/\\s[A*B]);q[B*C] |- r[A*B];q[B*C]/\\s[A*B];q[B*C]&quot; --  Distribution
<span class="lineno"> 1036 </span> , &quot;r[A*B];(s[B*C]/\\q[B*C]) |- r[A*B];s[B*C]/\\r[A*B];q[B*C]&quot; --  Distribution
<span class="lineno"> 1037 </span> , &quot;(r[A*B];s[B*C])/s[B*C] |- r[A*B]&quot;                          --  Absorption
<span class="lineno"> 1038 </span> , &quot;r[A*B]\\(r[A*B];s[B*C]) |- s[B*C]&quot;                         --  Absorption
<span class="lineno"> 1039 </span> , &quot;I[A] |- r[A*A]*&quot;
<span class="lineno"> 1040 </span> , &quot;r[A*B] |- V[A*B]&quot;
<span class="lineno"> 1041 </span> ]
<span class="lineno"> 1042 </span>-}
<span class="lineno"> 1043 </span>{-
<span class="lineno"> 1044 </span>-- Type altering equivalences: The following equivalences have an different signature on either side.
<span class="lineno"> 1045 </span>taeDerivRules :: [DerivRule]
<span class="lineno"> 1046 </span>taeDerivRules = concatMap (dRule.parseRule)
<span class="lineno"> 1047 </span> [ &quot;-r[A*B]\\/(q[A*C]/s[B*C]) = -(r[A*B];s[B*C])\\/q[A*C]&quot;     -- T{ -r\\/(q/s)} = [A*B] ;   T{ -(r;s)\\/q} = [A*C] ; remove left residual (/)
<span class="lineno"> 1048 </span> , &quot;(r[A*B]\\q[A*C])\\/-s[B*C] = -(r[A*B];s[B*C])\\/q[A*C]&quot;    -- T{ (r\\q)\\/-s)} = [B*C] ; T{ -(r;s)\\/q} = [A*C] ; remove right residual (\\)
<span class="lineno"> 1049 </span> ]
<span class="lineno"> 1050 </span>-}
<span class="lineno"> 1051 </span>
<span class="lineno"> 1052 </span>head :: [a] -&gt; a
<span class="lineno"> 1053 </span><span class="decl"><span class="nottickedoff">head [] = fatal 30 &quot;head must not be used on an empty list!&quot;</span>
<span class="lineno"> 1054 </span><span class="spaces"></span><span class="nottickedoff">head (a:_) = a</span></span>
<span class="lineno"> 1055 </span>
<span class="lineno"> 1056 </span>-- | This delta is meant to be used as a placeholder for inserting or removing links from expressions.
<span class="lineno"> 1057 </span>delta :: Sign -&gt; Expression
<span class="lineno"> 1058 </span><span class="decl"><span class="nottickedoff">delta sgn</span>
<span class="lineno"> 1059 </span><span class="spaces"> </span><span class="nottickedoff">= EDcD   Sgn { decnm   = &quot;Delta&quot;</span>
<span class="lineno"> 1060 </span><span class="spaces">              </span><span class="nottickedoff">, decsgn  = sgn</span>
<span class="lineno"> 1061 </span><span class="spaces">              </span><span class="nottickedoff">, decprps = []</span>
<span class="lineno"> 1062 </span><span class="spaces">              </span><span class="nottickedoff">, decprps_calc = Nothing</span>
<span class="lineno"> 1063 </span><span class="spaces">              </span><span class="nottickedoff">, decprL  = &quot;&quot;</span>
<span class="lineno"> 1064 </span><span class="spaces">              </span><span class="nottickedoff">, decprM  = &quot;&quot;</span>
<span class="lineno"> 1065 </span><span class="spaces">              </span><span class="nottickedoff">, decprR  = &quot;&quot;</span>
<span class="lineno"> 1066 </span><span class="spaces">              </span><span class="nottickedoff">, decMean = AMeaning [ --   A_Markup Dutch   ReST (string2Blocks ReST &quot;Delta is bedoeld als variabele, die de plaats in een expressie vasthoudt waar paren worden ingevoegd of verwijderd.&quot;)</span>
<span class="lineno"> 1067 </span><span class="spaces">                                     </span><span class="nottickedoff">-- , A_Markup English ReST (string2Blocks ReST &quot;Delta is meant as a variable, to be used as a placeholder for inserting or removing links from expressions.&quot;)</span>
<span class="lineno"> 1068 </span><span class="spaces">                                   </span><span class="nottickedoff">]</span>
<span class="lineno"> 1069 </span><span class="spaces">              </span><span class="nottickedoff">, decfpos = Origin (&quot;generated relation (Delta &quot;++show sgn++&quot;)&quot;)</span>
<span class="lineno"> 1070 </span><span class="spaces">              </span><span class="nottickedoff">, deciss  = True</span>
<span class="lineno"> 1071 </span><span class="spaces">              </span><span class="nottickedoff">, decusr  = False</span>
<span class="lineno"> 1072 </span><span class="spaces">              </span><span class="nottickedoff">, decpat  = &quot;&quot;</span>
<span class="lineno"> 1073 </span><span class="spaces">              </span><span class="nottickedoff">, decplug = True</span>
<span class="lineno"> 1074 </span><span class="spaces">              </span><span class="nottickedoff">}</span></span>
<span class="lineno"> 1075 </span>
<span class="lineno"> 1076 </span>{- Normalization of process algebra clauses -}
<span class="lineno"> 1077 </span>
<span class="lineno"> 1078 </span>normPA :: Options -&gt; PAclause -&gt; PAclause
<span class="lineno"> 1079 </span><span class="decl"><span class="nottickedoff">normPA opts pac = pac'</span>
<span class="lineno"> 1080 </span><span class="spaces">    </span><span class="nottickedoff">where (pac',_,_) = if null (proofPA opts pac) then fatal 21 &quot;last: empty list&quot; else last (proofPA opts pac)</span></span>
<span class="lineno"> 1081 </span>
<span class="lineno"> 1082 </span>type Proof a = [(a, [String], String)]
<span class="lineno"> 1083 </span>
<span class="lineno"> 1084 </span>proofPA :: Options -&gt; PAclause -&gt; Proof PAclause
<span class="lineno"> 1085 </span><span class="decl"><span class="nottickedoff">proofPA opts = {-reverse.take 3.reverse.-}pPA</span>
<span class="lineno"> 1086 </span><span class="spaces"> </span><span class="nottickedoff">where pPA pac' = case normstepPA opts pac' of</span>
<span class="lineno"> 1087 </span><span class="spaces">                    </span><span class="nottickedoff">( _ , []  ,equ) -&gt; [(pac',[]   ,equ)]    -- is dus (pac,[],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1088 </span><span class="spaces">                    </span><span class="nottickedoff">(res,steps,equ) -&gt; (pac',steps,equ):pPA res</span></span>
<span class="lineno"> 1089 </span>
<span class="lineno"> 1090 </span>{- The following rewriter is used to simplify the actions inside eca rules.
<span class="lineno"> 1091 </span>-- WHY? Stef, kan je uitleggen wat hier gebeurt? Enig commentaar is hier wel op zijn plaats.
<span class="lineno"> 1092 </span>-- Ook zou het helpen om bij de verschillende constructoren van PAclause een beschrijving te geven van het idee er achter.
<span class="lineno"> 1093 </span>-- BECAUSE! Kan ik wel uitleggen, maar het is een heel verhaal. Dat moet tzt in een wetenschappelijk artikel gebeuren, zodat het er goed staat.
<span class="lineno"> 1094 </span>-- Het idee is dat een procesalgebra is weergegeven in Haskell combinatoren (gedefinieerd als PAclause(..), zie ADL.ECArule).
<span class="lineno"> 1095 </span>-- Die kun je vervolgens normaliseren met herschrijfregels op basis van gelijkheden die gelden in de bewuste procesalgebra.
<span class="lineno"> 1096 </span>-- Helaas zijn de herschrijfregels nu nog hard gecodeerd, zodat ik voor PAclause een afzonderlijke Haskell functie moet schrijven.
<span class="lineno"> 1097 </span>-- Hierna volgt de normalisator voor relatiealgebra-expressies, genaamd normStep. Die heeft dezelfde structuur,
<span class="lineno"> 1098 </span>-- maar gebruikt herschrijfregels vanuit gelijkheden die gelden in relatiealgebra.
<span class="lineno"> 1099 </span>-}
<span class="lineno"> 1100 </span>normstepPA :: Options -&gt; PAclause -&gt; (PAclause,[String],String)
<span class="lineno"> 1101 </span><span class="decl"><span class="nottickedoff">normstepPA opts pac = (res,ss,&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1102 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno"> 1103 </span><span class="spaces">  </span><span class="nottickedoff">(res,ss) = norm pac</span>
<span class="lineno"> 1104 </span><span class="spaces">  </span><span class="nottickedoff">norm :: PAclause -&gt; (PAclause,[String])</span>
<span class="lineno"> 1105 </span><span class="spaces">  </span><span class="nottickedoff">norm (CHC [] ms)  = (Blk ms, [&quot;Run out of options&quot;])</span>
<span class="lineno"> 1106 </span><span class="spaces">  </span><span class="nottickedoff">norm (CHC [r] ms) = (r', [&quot;Flatten ONE&quot;])</span>
<span class="lineno"> 1107 </span><span class="spaces">                    </span><span class="nottickedoff">where r' = case r of</span>
<span class="lineno"> 1108 </span><span class="spaces">                                 </span><span class="nottickedoff">Blk{} -&gt; r</span>
<span class="lineno"> 1109 </span><span class="spaces">                                 </span><span class="nottickedoff">_     -&gt; r{paMotiv = ms}</span>
<span class="lineno"> 1110 </span><span class="spaces">  </span><span class="nottickedoff">norm (CHC ds ms)  | (not.null) msgs = (CHC ops ms, msgs)</span>
<span class="lineno"> 1111 </span><span class="spaces">                    </span><span class="nottickedoff">| (not.null) [d | d&lt;-ds, isCHC d] = (CHC (nub [ d' | d&lt;-ds, d'&lt;-if isCHC d then let CHC ops' _ = d in ops' else [d] ]) ms, [&quot;flatten CHC&quot;])  -- flatten</span>
<span class="lineno"> 1112 </span><span class="spaces">                    </span><span class="nottickedoff">| (not.null) [Nop | Nop{}&lt;-ops] = (Nop{paMotiv=ms}, [&quot;Choose to do nothing&quot;])</span>
<span class="lineno"> 1113 </span><span class="spaces">                    </span><span class="nottickedoff">| (not.null) [Blk | Blk{}&lt;-ops] = (CHC [op | op&lt;-ops, not (isBlk op)] ms, [&quot;Choose anything but block&quot;])</span>
<span class="lineno"> 1114 </span><span class="spaces">                    </span><span class="nottickedoff">| (not.null) doubles = (CHC [ head cl | cl&lt;-eqClass (==) ds ] ms, [&quot;remove double occurrences&quot;])</span>
<span class="lineno"> 1115 </span><span class="spaces">                    </span><span class="nottickedoff">| otherwise = (CHC ds ms, [])</span>
<span class="lineno"> 1116 </span><span class="spaces">                    </span><span class="nottickedoff">where nds  = map norm ds</span>
<span class="lineno"> 1117 </span><span class="spaces">                          </span><span class="nottickedoff">msgs = concatMap snd nds</span>
<span class="lineno"> 1118 </span><span class="spaces">                          </span><span class="nottickedoff">ops  = map fst nds</span>
<span class="lineno"> 1119 </span><span class="spaces">                          </span><span class="nottickedoff">doubles = [ d | cl&lt;-eqClass (==) ds, length cl&gt;1, d&lt;-cl ]</span>
<span class="lineno"> 1120 </span><span class="spaces">  </span><span class="nottickedoff">norm (GCH [] ms)  = (Blk ms, [&quot;Run out of options&quot;])</span>
<span class="lineno"> 1121 </span><span class="spaces">  </span><span class="nottickedoff">norm (GCH ds ms)  | (not.null) [() | (_,links,_)&lt;-normds, isFalse links] = (GCH [(tOp,links,p) | (tOp,links,p)&lt;-normds, not (isFalse links)] ms, [&quot;Remove provably empty guard(s).&quot;])</span>
<span class="lineno"> 1122 </span><span class="spaces">                    </span><span class="nottickedoff">| (not.null) [()          | (_,  _    ,p)&lt;-normds, isNop p]</span>
<span class="lineno"> 1123 </span><span class="spaces">                        </span><span class="nottickedoff">= (GCH [(tOp,links,p) | (tOp,links,p)&lt;-normds, not (isNop p)] ms, [&quot;Remove unneccessary SELECT.&quot;])</span>
<span class="lineno"> 1124 </span><span class="spaces">                    </span><span class="nottickedoff">| (not.null) doubles = (GCH [ (fst3 (head cl), foldr1 (.\/.) (map snd3 cl), thd3 (head cl)) | cl&lt;-eqCl (\(tOp,_,p)-&gt;(tOp,p)) ds ] ms, [&quot;remove double occurrences&quot;])</span>
<span class="lineno"> 1125 </span><span class="spaces">                    </span><span class="nottickedoff">| otherwise = (GCH ds ms, [])</span>
<span class="lineno"> 1126 </span><span class="spaces">                    </span><span class="nottickedoff">where normds = [ (tOp, conjNF opts links, let (p',_)=norm p in p') | (tOp,links,p)&lt;-ds]</span>
<span class="lineno"> 1127 </span><span class="spaces">                          </span><span class="nottickedoff">doubles = [ d | cl&lt;-eqCl (\(tOp,_,p)-&gt;(tOp,p)) ds, length cl&gt;1, d&lt;-cl ]</span>
<span class="lineno"> 1128 </span><span class="spaces">  </span><span class="nottickedoff">norm (ALL [] ms)  = (Nop ms, [&quot;ALL [] = No Operation&quot;])</span>
<span class="lineno"> 1129 </span><span class="spaces">  </span><span class="nottickedoff">norm (ALL [d] ms) = (d', [&quot;Flatten ONE&quot;])</span>
<span class="lineno"> 1130 </span><span class="spaces">                    </span><span class="nottickedoff">where d' = case d of</span>
<span class="lineno"> 1131 </span><span class="spaces">                                 </span><span class="nottickedoff">Blk{} -&gt; d</span>
<span class="lineno"> 1132 </span><span class="spaces">                                 </span><span class="nottickedoff">_     -&gt; d{paMotiv = ms}</span>
<span class="lineno"> 1133 </span><span class="spaces">  </span><span class="nottickedoff">norm (ALL ds ms)  | (not.null) msgs = (ALL ops ms, msgs)</span>
<span class="lineno"> 1134 </span><span class="spaces">                    </span><span class="nottickedoff">| (not.null) [d | d&lt;-ds, isAll d] = (ALL (nub [ d' | d&lt;-ds, d'&lt;-if isAll d then let ALL ops' _ = d in ops' else [d] ]) ms, [&quot;flatten ALL&quot;])  -- flatten</span>
<span class="lineno"> 1135 </span><span class="spaces">                    </span><span class="nottickedoff">| (not.null) [Blk | Blk{}&lt;-ops] = (Blk{paMotiv = [m | op@Blk{}&lt;-ops,m&lt;-paMotiv op]}, [&quot;Block all&quot;])</span>
<span class="lineno"> 1136 </span><span class="spaces">                    </span><span class="nottickedoff">| (not.null) [Nop | Nop{}&lt;-ops] = (ALL [op | op&lt;-ops, not (isNop op)] ms, [&quot;Ignore Nop&quot;])</span>
<span class="lineno"> 1137 </span><span class="spaces">                    </span><span class="nottickedoff">| (not.null) doubles = (CHC [ head cl | cl&lt;-eqClass (==) ds ] ms, [&quot;remove double occurrences&quot;])</span>
<span class="lineno"> 1138 </span><span class="spaces">                    </span><span class="nottickedoff">| (not.null) long    = (ALL ds' ms, [&quot;Take the expressions for &quot;++commaEng &quot;and&quot; [(name . paTo . head) cl |cl&lt;-long]++&quot;together&quot;])</span>
<span class="lineno"> 1139 </span><span class="spaces">                    </span><span class="nottickedoff">| otherwise = (ALL ds ms, [])</span>
<span class="lineno"> 1140 </span><span class="spaces">                    </span><span class="nottickedoff">where ds'     = [ let p=head cl in</span>
<span class="lineno"> 1141 </span><span class="spaces">                                        </span><span class="nottickedoff">if length cl==1 then p else p{paDelta=disjNF opts (foldr1 (.\/.) [paDelta c | c&lt;-cl]), paMotiv=concatMap paMotiv cl}</span>
<span class="lineno"> 1142 </span><span class="spaces">                                    </span><span class="nottickedoff">| cl&lt;-dCls {- not (null cl) is guaranteed by eqCl -} ]</span>
<span class="lineno"> 1143 </span><span class="spaces">                                    </span><span class="nottickedoff">++[d | d&lt;-ds, not (isDo d)]</span>
<span class="lineno"> 1144 </span><span class="spaces">                          </span><span class="nottickedoff">nds     = map norm ds</span>
<span class="lineno"> 1145 </span><span class="spaces">                          </span><span class="nottickedoff">msgs    = concatMap snd nds</span>
<span class="lineno"> 1146 </span><span class="spaces">                          </span><span class="nottickedoff">ops     = map fst nds</span>
<span class="lineno"> 1147 </span><span class="spaces">                          </span><span class="nottickedoff">doubles = [ d | cl&lt;-eqClass (==) ds, length cl&gt;1, d&lt;-cl ]</span>
<span class="lineno"> 1148 </span><span class="spaces">                          </span><span class="nottickedoff">dCls :: [[PAclause]]</span>
<span class="lineno"> 1149 </span><span class="spaces">                          </span><span class="nottickedoff">dCls = eqCl to [d | d&lt;-ds, isDo d]</span>
<span class="lineno"> 1150 </span><span class="spaces">                          </span><span class="nottickedoff">long :: [[PAclause]]</span>
<span class="lineno"> 1151 </span><span class="spaces">                          </span><span class="nottickedoff">long = [cl | cl&lt;-dCls, length cl&gt;1]</span>
<span class="lineno"> 1152 </span><span class="spaces">                          </span><span class="nottickedoff">to d = case d of</span>
<span class="lineno"> 1153 </span><span class="spaces">                                   </span><span class="nottickedoff">Do{} -&gt; (paSrt d, paTo d)</span>
<span class="lineno"> 1154 </span><span class="spaces">                                   </span><span class="nottickedoff">_    -&gt; fatal 74 &quot;illegal call of to(d)&quot;</span>
<span class="lineno"> 1155 </span><span class="spaces">  </span><span class="nottickedoff">norm (New c p ms)        = ( case p' of</span>
<span class="lineno"> 1156 </span><span class="spaces">                                </span><span class="nottickedoff">Blk{} -&gt; p'{paMotiv = ms}</span>
<span class="lineno"> 1157 </span><span class="spaces">                                </span><span class="nottickedoff">_     -&gt; New c (\x-&gt;let (p'', _) = norm (p x) in p'') ms</span>
<span class="lineno"> 1158 </span><span class="spaces">                             </span><span class="nottickedoff">, msgs)</span>
<span class="lineno"> 1159 </span><span class="spaces">                             </span><span class="nottickedoff">where (p', msgs) = norm (p &quot;x&quot;)</span>
<span class="lineno"> 1160 </span><span class="spaces">  </span><span class="nottickedoff">norm (Rmv c p ms)        = ( case p' of</span>
<span class="lineno"> 1161 </span><span class="spaces">                                </span><span class="nottickedoff">Blk{} -&gt; p'{paMotiv = ms}</span>
<span class="lineno"> 1162 </span><span class="spaces">                                </span><span class="nottickedoff">_     -&gt; Rmv c (\x-&gt;let (p'', _) = norm (p x) in p'') ms</span>
<span class="lineno"> 1163 </span><span class="spaces">                             </span><span class="nottickedoff">, msgs)</span>
<span class="lineno"> 1164 </span><span class="spaces">                             </span><span class="nottickedoff">where (p', msgs) = norm (p &quot;x&quot;)</span>
<span class="lineno"> 1165 </span><span class="spaces">  </span><span class="nottickedoff">norm p                   = (p, [])</span></span>
<span class="lineno"> 1166 </span>
<span class="lineno"> 1167 </span>{- Normalization of expressions -}
<span class="lineno"> 1168 </span>
<span class="lineno"> 1169 </span>simplify :: Expression -&gt; Expression
<span class="lineno"> 1170 </span><span class="decl"><span class="nottickedoff">simplify expr = expr'</span>
<span class="lineno"> 1171 </span><span class="spaces">    </span><span class="nottickedoff">where (expr',_,_) = if null (simpProof shw expr) then fatal 101 &quot;last: empty list&quot; else last (simpProof shw expr)</span>
<span class="lineno"> 1172 </span><span class="spaces">          </span><span class="nottickedoff">shw _ = &quot;&quot;</span></span>
<span class="lineno"> 1173 </span>
<span class="lineno"> 1174 </span>simpProof :: (Expression -&gt; String) -&gt; Expression -&gt; Proof Expression
<span class="lineno"> 1175 </span><span class="decl"><span class="nottickedoff">simpProof shw expr</span>
<span class="lineno"> 1176 </span><span class="spaces"> </span><span class="nottickedoff">= if expr==res</span>
<span class="lineno"> 1177 </span><span class="spaces">   </span><span class="nottickedoff">then [(expr,[],&quot;&lt;=&gt;&quot;)]</span>
<span class="lineno"> 1178 </span><span class="spaces">   </span><span class="nottickedoff">else (expr,steps,equ):simpProof shw res</span>
<span class="lineno"> 1179 </span><span class="spaces"> </span><span class="nottickedoff">where (res,steps,equ) = normStep shw True True True expr</span></span>
<span class="lineno"> 1180 </span>
<span class="lineno"> 1181 </span>-- | The purpose of &quot;normStep&quot; is to elaborate a single step in a rewrite process,
<span class="lineno"> 1182 </span>-- in which the expression is normalized by means of rewrite rules.
<span class="lineno"> 1183 </span>-- This function can be used for simplification, which means that an Expression is standardized
<span class="lineno"> 1184 </span>-- using associativity and other 'trivial' rules only.
<span class="lineno"> 1185 </span>-- These 'trivial' rules do not produce a step in the proof.
<span class="lineno"> 1186 </span>-- Use normstep shw eq True expr to do simplification only.
<span class="lineno"> 1187 </span>-- Use normstep shw eq False expr to obtain a single proof step or none when no rule is applicable.
<span class="lineno"> 1188 </span>-- This function returns a resulting expression that is closer to a normal form.
<span class="lineno"> 1189 </span>-- The normal form is not unique. This function simply uses the first rewrite rule it encounters.
<span class="lineno"> 1190 </span>normStep :: (Expression -&gt; String) -&gt; Bool -&gt; Bool -&gt; Bool -&gt;
<span class="lineno"> 1191 </span>            Expression -&gt; (Expression,[String],String) -- This might be generalized to &quot;Expression&quot; if it weren't for the fact that flip is embedded in the Relation type.
<span class="lineno"> 1192 </span><span class="decl"><span class="nottickedoff">normStep shw   -- a function to print an expression. Might be &quot;showADL&quot;</span>
<span class="lineno"> 1193 </span><span class="spaces">         </span><span class="nottickedoff">eq    -- If eq==True, only equivalences are used. Otherwise, implications are used as well.</span>
<span class="lineno"> 1194 </span><span class="spaces">         </span><span class="nottickedoff">dnf   -- If dnf==True, the result is in disjunctive normal form, otherwise in conjunctive normal form</span>
<span class="lineno"> 1195 </span><span class="spaces">         </span><span class="nottickedoff">simpl -- If True, only simplification rules are used, which is a subset of all rules. Consequently, simplification is implied by normalization.</span>
<span class="lineno"> 1196 </span><span class="spaces">         </span><span class="nottickedoff">expr = if sign expr==sign res then (res,ss,equ) else</span>
<span class="lineno"> 1197 </span><span class="spaces">                </span><span class="nottickedoff">fatal 166 (&quot;Violation of sign expr==sign res in the normalizer\n  expr: sign( &quot;++showADL expr++&quot; ) == &quot;++showSign res++&quot;\n  res:  sign( &quot;++showADL res++&quot; ) == &quot;++showSign res)</span>
<span class="lineno"> 1198 </span><span class="spaces"></span><span class="nottickedoff">{-SJ 20140720: You might wonder why we test sign expr==sign res, which was introduced as a result of ticket #409 (the residu bug)</span>
<span class="lineno"> 1199 </span><span class="spaces"></span><span class="nottickedoff">It turns out that many rewrite rules in the normalizer change the type of an expression; an aspect I have been overlooking all the time.</span>
<span class="lineno"> 1200 </span><span class="spaces"></span><span class="nottickedoff">Until the new normalizer works, we will have to work with this one. So I have inserted this test to ensure that the type remains constant during normalization.</span>
<span class="lineno"> 1201 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno"> 1202 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno"> 1203 </span><span class="spaces">  </span><span class="nottickedoff">(res,ss,equ) = nM True expr []</span>
<span class="lineno"> 1204 </span><span class="spaces">  </span><span class="nottickedoff">nM :: Bool -&gt; Expression -&gt; [Expression] -&gt; (Expression,[String],String)</span>
<span class="lineno"> 1205 </span><span class="spaces"></span><span class="nottickedoff">-- posCpl indicates whether the expression is positive under a complement. It is False when expr is inside a complemented expression.</span>
<span class="lineno"> 1206 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EEqu (l,r)) _     | simpl = (t .==. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1207 </span><span class="spaces">                                         </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []  -- TODO: the use of posCpl is erroneous</span>
<span class="lineno"> 1208 </span><span class="spaces">                                               </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r []  -- TODO: the use of posCpl is erroneous</span>
<span class="lineno"> 1209 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EImp (l,r)) _     | simpl = (t .|-. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1210 </span><span class="spaces">                                         </span><span class="nottickedoff">where (t,steps, equ')  = nM (not posCpl) l []</span>
<span class="lineno"> 1211 </span><span class="spaces">                                               </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r []</span>
<span class="lineno"> 1212 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EUni (EUni (l,k),r)) rs   = nM posCpl (l .\/. (k .\/. r)) rs  -- standardize, using associativity of .\/.</span>
<span class="lineno"> 1213 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EUni (l,r)) rs    | simpl = (t .\/. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1214 </span><span class="spaces">                                         </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []</span>
<span class="lineno"> 1215 </span><span class="spaces">                                               </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r (l:rs)</span>
<span class="lineno"> 1216 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EIsc (EIsc (l,k),r)) rs   = nM posCpl (l ./\. (k ./\. r)) rs  -- standardize, using associativity of ./\.</span>
<span class="lineno"> 1217 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EIsc (l,r)) rs    | simpl = (t ./\. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1218 </span><span class="spaces">                                         </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []</span>
<span class="lineno"> 1219 </span><span class="spaces">                                               </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r (l:rs)</span>
<span class="lineno"> 1220 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ECps (ECps (l,k),r)) rs   = nM posCpl (l .:. (k .:. r)) rs  -- standardize, using associativity of .:.</span>
<span class="lineno"> 1221 </span><span class="spaces">                                             </span><span class="nottickedoff">-- Note: function shiftL and shiftR make use of the fact that this normalizes to (l .:. (k .:. r))</span>
<span class="lineno"> 1222 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ECps (l,r)) rs    | simpl = (t .:. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1223 </span><span class="spaces">                                          </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []</span>
<span class="lineno"> 1224 </span><span class="spaces">                                                </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r (l:rs)</span>
<span class="lineno"> 1225 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ELrs (l,r)) _     | simpl = (t ./. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1226 </span><span class="spaces">                                         </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []</span>
<span class="lineno"> 1227 </span><span class="spaces">                                               </span><span class="nottickedoff">(f,steps',equ'') = nM (not posCpl) r []</span>
<span class="lineno"> 1228 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ERrs (l,r)) _     | simpl = (t .\. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1229 </span><span class="spaces">                                         </span><span class="nottickedoff">where (t,steps, equ')  = nM (not posCpl) l []</span>
<span class="lineno"> 1230 </span><span class="spaces">                                               </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r []</span>
<span class="lineno"> 1231 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EDia (l,r)) _     | simpl = (t .&lt;&gt;. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1232 </span><span class="spaces">                                         </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []  -- TODO: the use of posCpl is erroneous</span>
<span class="lineno"> 1233 </span><span class="spaces">                                               </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r []  -- TODO: the use of posCpl is erroneous</span>
<span class="lineno"> 1234 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ERad (ERad (l,k),r)) rs   = nM posCpl (l .!. (k .!. r)) rs  -- standardize, using associativity of .!.</span>
<span class="lineno"> 1235 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ERad (l,r)) rs    | simpl = (t .!. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1236 </span><span class="spaces">                                         </span><span class="nottickedoff">where (t,steps, equ')    = nM posCpl l []</span>
<span class="lineno"> 1237 </span><span class="spaces">                                               </span><span class="nottickedoff">(f,steps',equ'')   = nM posCpl r (l:rs)</span>
<span class="lineno"> 1238 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EPrd (EPrd (l,k),r)) rs   = nM posCpl (l .*. (k .*. r)) rs  -- standardize, using associativity of .*.</span>
<span class="lineno"> 1239 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EPrd (l,r)) _     | simpl = (t .*. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1240 </span><span class="spaces">                                         </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []</span>
<span class="lineno"> 1241 </span><span class="spaces">                                               </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r []</span>
<span class="lineno"> 1242 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EKl0 e)              _    = (EKl0 res', steps, equ')</span>
<span class="lineno"> 1243 </span><span class="spaces">                                         </span><span class="nottickedoff">where (res',steps,equ') = nM posCpl e []</span>
<span class="lineno"> 1244 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EKl1 e)              _    = (EKl1 res', steps, equ')</span>
<span class="lineno"> 1245 </span><span class="spaces">                                         </span><span class="nottickedoff">where (res',steps,equ') = nM posCpl e []</span>
<span class="lineno"> 1246 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ECpl (ECpl e))         rs = nM posCpl e rs</span>
<span class="lineno"> 1247 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ECpl e) _         | simpl = (notCpl res',steps,equ')</span>
<span class="lineno"> 1248 </span><span class="spaces">                                         </span><span class="nottickedoff">where (res',steps,equ') = nM (not posCpl) e []</span>
<span class="lineno"> 1249 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EBrk e)                _  = nM posCpl e []</span>
<span class="lineno"> 1250 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EFlp (ECpl e))         rs = nM posCpl (notCpl (flp e)) rs</span>
<span class="lineno"> 1251 </span><span class="spaces">  </span><span class="nottickedoff">nM _      x _                | simpl = (x,[],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1252 </span><span class="spaces"></span><span class="nottickedoff">-- up to here, simplification has been treated. The remaining rules can safely assume  simpl==False</span>
<span class="lineno"> 1253 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (EEqu (l,r)) _                            = ((l .|-. r) ./\. (r .|-. l), [&quot;remove =&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1254 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (EImp (x,r@(ELrs (z,y)))) _               = if sign x==sign z -- necessary to guarantee that sign expr is equal to sign of the result</span>
<span class="lineno"> 1255 </span><span class="spaces">                                                        </span><span class="nottickedoff">then (x .:. y .|-. z, [&quot;remove left residual (/)&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1256 </span><span class="spaces">                                                        </span><span class="nottickedoff">else (notCpl x .\/. r, [&quot;remove |-&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1257 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (EImp (y,r@(ERrs (x,z)))) _               = if sign y==sign z -- necessary to guarantee that sign expr is equal to sign of the result</span>
<span class="lineno"> 1258 </span><span class="spaces">                                                        </span><span class="nottickedoff">then (x .:. y .|-. z, [&quot;remove right residual (\\)&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1259 </span><span class="spaces">                                                        </span><span class="nottickedoff">else (notCpl y .\/. r, [&quot;remove |-&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1260 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (EImp (l,r)) _                            = (notCpl l .\/. r, [&quot;remove |-&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1261 </span><span class="spaces"></span><span class="nottickedoff">--   nM posCpl e@(ECpl EIsc{}) _           | posCpl==dnf = (deMorganEIsc e, [&quot;De Morgan&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1262 </span><span class="spaces"></span><span class="nottickedoff">--   nM posCpl e@(ECpl EUni{}) _           | posCpl/=dnf = (deMorganEUni e, [&quot;De Morgan&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1263 </span><span class="spaces">  </span><span class="nottickedoff">nM _      e@(ECpl EIsc{}) _                         = (deMorganEIsc e, [&quot;De Morgan&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1264 </span><span class="spaces">  </span><span class="nottickedoff">nM _      e@(ECpl EUni{}) _                         = (deMorganEUni e, [&quot;De Morgan&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1265 </span><span class="spaces">  </span><span class="nottickedoff">nM _      e@(ECpl (ERad (_,ECpl{}))) _              = (deMorganERad e, [&quot;De Morgan&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1266 </span><span class="spaces">  </span><span class="nottickedoff">nM _      e@(ECpl (ERad (ECpl{},_))) _              = (deMorganERad e, [&quot;De Morgan&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1267 </span><span class="spaces">  </span><span class="nottickedoff">nM _      e@(ECpl (ECps (ECpl{},ECpl{}))) _         = (deMorganECps e, [&quot;De Morgan&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1268 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ECpl e) _                                = (notCpl res',steps,equ')</span>
<span class="lineno"> 1269 </span><span class="spaces">                                                        </span><span class="nottickedoff">where (res',steps,equ') = nM (not posCpl) e []</span>
<span class="lineno"> 1270 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (EEps c (Sign s _),EEps c' (Sign _  t'))) _ | c ==c' = (EEps c  (Sign s t'), [], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1271 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (EEps c (Sign s t),EEps c' (Sign _  t'))) _ | c ==t  = (EEps c' (Sign s t'), [], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1272 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (EEps c (Sign s _),EEps c' (Sign s' t'))) _ | s'==c' = (EEps c  (Sign s t'), [], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1273 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (EEps c (Sign s _),ECps(EEps c' (Sign _  t'),r))) _ | c ==c' = (ECps (EEps c  (Sign s t'),r), [], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1274 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (EEps c (Sign s t),ECps(EEps c' (Sign _  t'),r))) _ | c ==t  = (ECps (EEps c' (Sign s t'),r), [], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1275 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (EEps c (Sign s _),ECps(EEps c' (Sign s' t'),r))) _ | s'==c' = (ECps (EEps c  (Sign s t'),r), [], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1276 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (ERrs (x,e),y)) _ | not eq &amp;&amp; isIdent e = (ERrs (x,y), [&quot;Jipsen&amp;Tsinakis: (x\\I);y |- x\\y&quot;], &quot;==&gt;&quot;)</span>
<span class="lineno"> 1277 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (x,ELrs (e,y))) _ | not eq &amp;&amp; isIdent e = (ELrs (x,y), [&quot;Jipsen&amp;Tsinakis: x;(I/y) |- x/y&quot;], &quot;==&gt;&quot;)</span>
<span class="lineno"> 1278 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (ERrs (x,y),z)) _          | not eq = (ERrs (x,ECps (y,z)), [&quot;Jipsen&amp;Tsinakis: (x\\y);z |- x\\(y;z)&quot;], &quot;==&gt;&quot;)</span>
<span class="lineno"> 1279 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (x,ELrs (y,z))) _          | not eq = (ERrs (x,ECps (y,z)), [&quot;Jipsen&amp;Tsinakis: x;(y/z) |- (x;y)/z&quot;], &quot;==&gt;&quot;)</span>
<span class="lineno"> 1280 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (ERrs (x,y),ERrs (y',z))) _ | not eq &amp;&amp; y==y' = (ERrs (x,z), [&quot;Jipsen&amp;Tsinakis: (x\\y);(y\\z) |- x\\z&quot;], &quot;==&gt;&quot;)</span>
<span class="lineno"> 1281 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (ELrs (x,y),ELrs (y',z))) _ | not eq &amp;&amp; y==y' = (ERrs (x,z), [&quot;Jipsen&amp;Tsinakis: (x/y);(y/z) |- x/z&quot;], &quot;==&gt;&quot;)</span>
<span class="lineno"> 1282 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (ERrs (x,y),ERrs (y',z))) _ | y==y' &amp;&amp; x==y &amp;&amp; x==z = (ERrs (x,z), [&quot;Jipsen&amp;Tsinakis: (x\\x);(x\\x) = x\\x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1283 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (ELrs (x,y),ELrs (y',z))) _ | y==y' &amp;&amp; x==y &amp;&amp; x==z = (ERrs (x,z), [&quot;Jipsen&amp;Tsinakis: (x/x);(x/x) = x/x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1284 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (x,ERrs (y,z))) _    | x==y &amp;&amp; x==z = (x, [&quot;Jipsen&amp;Tsinakis: x;(x\\x) = x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1285 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (ELrs (x,y),z)) _    | x==z &amp;&amp; y==z = (x, [&quot;Jipsen&amp;Tsinakis: (x/x);x = x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1286 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (l,r)) _                | isIdent l = (r, [&quot;I;x = x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1287 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (l,r)) _                | isIdent r = (l, [&quot;x;I = x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1288 </span><span class="spaces">  </span><span class="nottickedoff">nM True   (ECps (r,ERad (s,q))) _          | not eq = ((r.:.s).!.q, [&quot;Peirce: r;(s!q) |- (r;s)!q&quot;],&quot;==&gt;&quot;)</span>
<span class="lineno"> 1289 </span><span class="spaces">  </span><span class="nottickedoff">nM True   (ECps (ERad (r,s),q)) _          | not eq = (r.!.(s.:.q), [&quot;Peirce: (r!s);q |- r!(s;q)&quot;],&quot;==&gt;&quot;)</span>
<span class="lineno"> 1290 </span><span class="spaces">  </span><span class="nottickedoff">nM True   (ECps (EIsc (r,s),q)) _          | not eq = ((r.:.q)./\.(s.:.q), [&quot;distribute ; over /\\&quot;],&quot;==&gt;&quot;)</span>
<span class="lineno"> 1291 </span><span class="spaces">  </span><span class="nottickedoff">nM True   (ECps (r,EIsc (s,q))) _          | not eq = ((r.:.s)./\.(r.:.q), [&quot;distribute ; over /\\&quot;],&quot;==&gt;&quot;)</span>
<span class="lineno"> 1292 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (EUni (q,s),r)) _                   = ((q.:.r).\/.(s.:.r), [&quot;distribute ; over \\/&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1293 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ECps (l,EUni (q,s))) _                   = ((l.:.q).\/.(l.:.s), [&quot;distribute ; over \\/&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1294 </span><span class="spaces">  </span><span class="nottickedoff">nM _      x@(ECps (l@EFlp{},r)) _ | not eq &amp;&amp; flp l==r &amp;&amp; isInj l   = (EDcI (source x), [&quot;r~;r |- I (r is univalent)&quot;], &quot;==&gt;&quot;)</span>
<span class="lineno"> 1295 </span><span class="spaces">  </span><span class="nottickedoff">nM _      x@(ECps (l,       r)) _ | not eq &amp;&amp; l==flp r &amp;&amp; isInj l   = (EDcI (source x), [&quot;r;r~ |- I (r is injective)&quot;], &quot;==&gt;&quot;)</span>
<span class="lineno"> 1296 </span><span class="spaces">  </span><span class="nottickedoff">nM _      x@(ECps (l@EFlp{},r)) _ | flp l==r &amp;&amp; isInj l &amp;&amp; isTot l  = (EDcI (source x), [&quot;r~;r=I because r is univalent and surjective&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1297 </span><span class="spaces">  </span><span class="nottickedoff">nM _      x@(ECps (l,       r)) _ | l==flp r &amp;&amp; isInj l &amp;&amp; isTot l  = (EDcI (source x), [&quot;r;r~=I because r is injective and total&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1298 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ECps (l,r))           rs                 = (t .:. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1299 </span><span class="spaces">                                                          </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []</span>
<span class="lineno"> 1300 </span><span class="spaces">                                                                </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r (l:rs)</span>
<span class="lineno"> 1301 </span><span class="spaces">  </span><span class="nottickedoff">nM _      x@(EEps i sgn) _ | source sgn==i &amp;&amp; i==target sgn = (EDcI i, [&quot;source and target are equal to &quot;++name i++&quot;, so &quot;++showADL x++&quot;=&quot;++showADL (EDcI i)], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1302 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ELrs (ECps (x,y),z)) _ | not eq &amp;&amp; y==z  = (x,     [&quot;(x;y)/y |- x&quot;], &quot;==&gt;&quot;)</span>
<span class="lineno"> 1303 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ELrs (ECps (x,y),z)) _ | not eq &amp;&amp; flp x==z= (flp y, [case (x, y) of</span>
<span class="lineno"> 1304 </span><span class="spaces">                                                                        </span><span class="nottickedoff">(EFlp _, EFlp _) -&gt; &quot;(SJ) (x~;y~)/x |- y&quot;</span>
<span class="lineno"> 1305 </span><span class="spaces">                                                                        </span><span class="nottickedoff">(     _, EFlp _) -&gt; &quot;(SJ) (x;y~)/x~ |- y&quot;</span>
<span class="lineno"> 1306 </span><span class="spaces">                                                                        </span><span class="nottickedoff">(EFlp _,      _) -&gt; &quot;(SJ) (x~;y)/x |- y~&quot;</span>
<span class="lineno"> 1307 </span><span class="spaces">                                                                        </span><span class="nottickedoff">(     _,      _) -&gt; &quot;(SJ) (x;y)/x~ |- y~&quot;], &quot;==&gt;&quot;)</span>
<span class="lineno"> 1308 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ELrs (ELrs (x,z),y)) _                     = (ELrs (x,ECps (y,z)), [&quot;Jipsen&amp;Tsinakis: x/yz = (x/z)/y&quot;], &quot;&lt;=&gt;&quot;) -- note: sign (x/yz) == sign ((x/z)/y)</span>
<span class="lineno"> 1309 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ELrs (l,r)) _                              = (t ./. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1310 </span><span class="spaces">                                                          </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []</span>
<span class="lineno"> 1311 </span><span class="spaces">                                                                </span><span class="nottickedoff">(f,steps',equ'') = nM (not posCpl) r []</span>
<span class="lineno"> 1312 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ERrs (y,ERrs (x,z))) _                     = (ERrs (ECps (x,y),z), [&quot;Jipsen&amp;Tsinakis: xy\\z = y\\(x\\z)&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1313 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ERrs (x,ECps (y,z))) _ | not eq &amp;&amp; x==y    = (z,     [&quot;x\\(x;y) |- y&quot;], &quot;==&gt;&quot;)</span>
<span class="lineno"> 1314 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ERrs (l,r)) _                              = (t .\. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1315 </span><span class="spaces">                                                          </span><span class="nottickedoff">where (t,steps, equ')  = nM (not posCpl) l []</span>
<span class="lineno"> 1316 </span><span class="spaces">                                                                </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r []</span>
<span class="lineno"> 1317 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EDia (l,r)) _                              = (t .&lt;&gt;. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1318 </span><span class="spaces">                                                          </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []</span>
<span class="lineno"> 1319 </span><span class="spaces">                                                                </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r []</span>
<span class="lineno"> 1320 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ERad (l,r)) _                   | isImin l = (r, [&quot;-I!x = x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1321 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ERad (l,r)) _                   | isImin r = (l, [&quot;x!-I = x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1322 </span><span class="spaces"></span><span class="nottickedoff">--     nM False  (ERad (ECps (r,s),q)) _            | not eq = (r.:.(s.!.q), [&quot;Peirce: (r;s)!q |- r;(s!q)&quot;],&quot;==&gt;&quot;)  -- SJ 20131124 TODO: check this rule. It is wrong!</span>
<span class="lineno"> 1323 </span><span class="spaces"></span><span class="nottickedoff">--     nM False  (ERad (r,ECps (s,q))) _            | not eq = ((r.!.s).:.q, [&quot;Peirce: (r!s);q |- r!(s;q)&quot;],&quot;==&gt;&quot;)  -- SJ 20131124 TODO: check this rule. It is wrong!</span>
<span class="lineno"> 1324 </span><span class="spaces">  </span><span class="nottickedoff">nM False  (ERad (EUni (r,s),q)) _            | not eq = ((r.!.q).\/.(s.!.q), [&quot;distribute ! over \\/&quot;],&quot;==&gt;&quot;)</span>
<span class="lineno"> 1325 </span><span class="spaces">  </span><span class="nottickedoff">nM False  (ERad (r,EUni (s,q))) _            | not eq = ((r.!.s).\/.(r.!.q), [&quot;distribute ! over \\/&quot;],&quot;==&gt;&quot;)</span>
<span class="lineno"> 1326 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ERad (EIsc (q,s),r)) _                     = ((q.!.r)./\.(s.!.r), [&quot;distribute ! over /\\&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1327 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ERad (l,EIsc (q,s))) _                     = ((l.!.q)./\.(l.!.s), [&quot;distribute ! over /\\&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1328 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ERad(ECpl l,r))      _                     = (flp l .\. r, [case l of EFlp{} -&gt; &quot;-l~!r = l\\r&quot;; _ -&gt; &quot;-l!r = l~\\r&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1329 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (ERad(l,ECpl r))      _                     = (l ./. flp r, [case r of EFlp{} -&gt; &quot;l!-r~ = l/r&quot;; _ -&gt; &quot;l!-r = l/r~&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1330 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (ERad (l,r))         rs                     = (t .!. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1331 </span><span class="spaces">                                                              </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []</span>
<span class="lineno"> 1332 </span><span class="spaces">                                                                    </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r (l:rs)</span>
<span class="lineno"> 1333 </span><span class="spaces">  </span><span class="nottickedoff">nM _      (EPrd (l,EPrd (_,r))) _                     = (l .*. r, [&quot;eliminate middle in cartesian product&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1334 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EPrd (l,r)) _                              = (t .*. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1335 </span><span class="spaces">                                                              </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []</span>
<span class="lineno"> 1336 </span><span class="spaces">                                                                    </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r []</span>
<span class="lineno"> 1337 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EIsc (EUni (l,k),r)) _       | posCpl/=dnf = ((l./\.r) .\/. (k./\.r), [&quot;distribute /\\ over \\/&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1338 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EIsc (l,EUni (k,r))) _       | posCpl/=dnf = ((l./\.k) .\/. (l./\.r), [&quot;distribute /\\ over \\/&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1339 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl x@(EIsc (l,r)) rs</span>
<span class="lineno"> 1340 </span><span class="spaces"></span><span class="nottickedoff">-- Absorb equals:    r/\r  --&gt;  r</span>
<span class="lineno"> 1341 </span><span class="spaces">      </span><span class="nottickedoff">| or [length cl&gt;1 |cl&lt;-absorbClasses]</span>
<span class="lineno"> 1342 </span><span class="spaces">           </span><span class="nottickedoff">= ( case absorbClasses of [] -&gt; fatal 243 &quot;Going into foldr1 with empty absorbClasses&quot;; _ -&gt; foldr1 (./\.) [head cl | cl&lt;-absorbClasses]</span>
<span class="lineno"> 1343 </span><span class="spaces">             </span><span class="nottickedoff">, [shw e++&quot; /\\ &quot;++shw e++&quot; = &quot;++shw e | cl&lt;-absorbClasses, length cl&gt;1, let e=head cl]</span>
<span class="lineno"> 1344 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;&lt;=&gt;&quot;</span>
<span class="lineno"> 1345 </span><span class="spaces">             </span><span class="nottickedoff">)</span>
<span class="lineno"> 1346 </span><span class="spaces"></span><span class="nottickedoff">-- Absorb True:    r/\V  --&gt; r</span>
<span class="lineno"> 1347 </span><span class="spaces">      </span><span class="nottickedoff">| isTrue l                      = (r, [&quot;V/\\x = x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1348 </span><span class="spaces">      </span><span class="nottickedoff">| isTrue r                      = (l, [&quot;x/\\V = x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1349 </span><span class="spaces"></span><span class="nottickedoff">-- Inconsistency:    r/\-r   --&gt;  False</span>
<span class="lineno"> 1350 </span><span class="spaces">      </span><span class="nottickedoff">| not (null incons)</span>
<span class="lineno"> 1351 </span><span class="spaces">           </span><span class="nottickedoff">= let i = head incons in (notCpl (EDcV (sign i)), [shw (notCpl i)++&quot; /\\ &quot;++shw i++&quot; = V-&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1352 </span><span class="spaces"></span><span class="nottickedoff">-- Inconsistency:    x/\\V-  --&gt;  False</span>
<span class="lineno"> 1353 </span><span class="spaces">      </span><span class="nottickedoff">| isFalse l                     = (notCpl (EDcV (sign x)), [&quot;-V/\\x = -V&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1354 </span><span class="spaces">      </span><span class="nottickedoff">| isFalse r                     = (notCpl (EDcV (sign x)), [&quot;x/\\-V = -V&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1355 </span><span class="spaces"></span><span class="nottickedoff">-- Absorb if r is antisymmetric:    r/\r~ --&gt; I</span>
<span class="lineno"> 1356 </span><span class="spaces">      </span><span class="nottickedoff">| t/=l || f/=r</span>
<span class="lineno"> 1357 </span><span class="spaces">           </span><span class="nottickedoff">= (t ./\. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1358 </span><span class="spaces">      </span><span class="nottickedoff">| not eq &amp;&amp; or [length cl&gt;1 |cl&lt;-absorbAsy]</span>
<span class="lineno"> 1359 </span><span class="spaces">           </span><span class="nottickedoff">= ( foldr1 (./\.) [if length cl&gt;1 then EDcI (source e) else e | cl&lt;-absorbAsy, let e=head cl]</span>
<span class="lineno"> 1360 </span><span class="spaces">             </span><span class="nottickedoff">, [shw e++&quot; /\\ &quot;++shw (flp e)++&quot; |- I, because&quot;++shw e++&quot; is antisymmetric&quot; | cl&lt;-absorbAsy, let e=head cl]</span>
<span class="lineno"> 1361 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;==&gt;&quot;</span>
<span class="lineno"> 1362 </span><span class="spaces">             </span><span class="nottickedoff">)</span>
<span class="lineno"> 1363 </span><span class="spaces"></span><span class="nottickedoff">-- Absorb if r is antisymmetric and reflexive:    r/\r~ = I</span>
<span class="lineno"> 1364 </span><span class="spaces">      </span><span class="nottickedoff">| or [length cl&gt;1 |cl&lt;-absorbAsyRfx]</span>
<span class="lineno"> 1365 </span><span class="spaces">           </span><span class="nottickedoff">= ( foldr1 (./\.) [if length cl&gt;1 then EDcI (source e) else e | cl&lt;-absorbAsyRfx, let e=head cl]</span>
<span class="lineno"> 1366 </span><span class="spaces">             </span><span class="nottickedoff">, [shw e++&quot; /\\ &quot;++shw (flp e)++&quot; = I, because&quot;++shw e++&quot; is antisymmetric and reflexive&quot; | cl&lt;-absorbAsyRfx, let e=head cl]</span>
<span class="lineno"> 1367 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;&lt;=&gt;&quot;</span>
<span class="lineno"> 1368 </span><span class="spaces">             </span><span class="nottickedoff">)</span>
<span class="lineno"> 1369 </span><span class="spaces"></span><span class="nottickedoff">-- Absorb:    (x\\/y)/\\y  =  y</span>
<span class="lineno"> 1370 </span><span class="spaces">      </span><span class="nottickedoff">| isEUni l &amp;&amp; not (null absor0)</span>
<span class="lineno"> 1371 </span><span class="spaces">           </span><span class="nottickedoff">= let t'=head absor0  in (r, [&quot;absorb &quot;++shw l++&quot; because of &quot;++shw t'++&quot;, using law  (x\\/y)/\\y = y&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1372 </span><span class="spaces">      </span><span class="nottickedoff">| isEUni r &amp;&amp; not (null absor0')</span>
<span class="lineno"> 1373 </span><span class="spaces">           </span><span class="nottickedoff">= let t'=head absor0' in (r, [&quot;absorb &quot;++shw r++&quot; because of &quot;++shw t'++&quot;, using law  (x\\/y)/\\x = x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1374 </span><span class="spaces"></span><span class="nottickedoff">-- Absorb:    (x\\/-y)/\\y  =  y-x</span>
<span class="lineno"> 1375 </span><span class="spaces">      </span><span class="nottickedoff">| isEUni l &amp;&amp; not (null absor1)</span>
<span class="lineno"> 1376 </span><span class="spaces">           </span><span class="nottickedoff">= ( case head absor1 of</span>
<span class="lineno"> 1377 </span><span class="spaces">                 </span><span class="nottickedoff">(_,[]) -&gt; r</span>
<span class="lineno"> 1378 </span><span class="spaces">                 </span><span class="nottickedoff">(_,ts) -&gt; r .-. foldr1 (.\/.) ts</span>
<span class="lineno"> 1379 </span><span class="spaces">             </span><span class="nottickedoff">, [&quot;absorb &quot;++shw t'++&quot;, using law (x\\/-y)/\\y  =  y-x&quot; | (t',_)&lt;-absor1] -- this take 1 is necessary. See Ticket #398</span>
<span class="lineno"> 1380 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;&lt;=&gt;&quot;</span>
<span class="lineno"> 1381 </span><span class="spaces">             </span><span class="nottickedoff">)</span>
<span class="lineno"> 1382 </span><span class="spaces">      </span><span class="nottickedoff">| isEUni r &amp;&amp; not (null absor1')</span>
<span class="lineno"> 1383 </span><span class="spaces">           </span><span class="nottickedoff">= ( case head absor1' of</span>
<span class="lineno"> 1384 </span><span class="spaces">                 </span><span class="nottickedoff">(_,[]) -&gt; l</span>
<span class="lineno"> 1385 </span><span class="spaces">                 </span><span class="nottickedoff">(_,ts) -&gt; l .-. foldr1 (.\/.) ts</span>
<span class="lineno"> 1386 </span><span class="spaces">             </span><span class="nottickedoff">, [&quot;absorb &quot;++shw t'++&quot;, using law x/\\(y\\/-x)  =  x-y&quot; | (t',_)&lt;-absor1'] -- this take 1 is necessary. See Ticket #398</span>
<span class="lineno"> 1387 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;&lt;=&gt;&quot;</span>
<span class="lineno"> 1388 </span><span class="spaces">             </span><span class="nottickedoff">)</span>
<span class="lineno"> 1389 </span><span class="spaces">      </span><span class="nottickedoff">| otherwise = (t ./\. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1390 </span><span class="spaces">      </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []</span>
<span class="lineno"> 1391 </span><span class="spaces">            </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r (l:rs)</span>
<span class="lineno"> 1392 </span><span class="spaces">            </span><span class="nottickedoff">absorbClasses = eqClass (==) (exprIsc2list l++exprIsc2list r)</span>
<span class="lineno"> 1393 </span><span class="spaces">            </span><span class="nottickedoff">incons = [conjunct |conjunct&lt;-exprIsc2list r,conjunct==notCpl l]</span>
<span class="lineno"> 1394 </span><span class="spaces">            </span><span class="nottickedoff">absor0  = [disjunct | disjunct&lt;-exprUni2list l, f'&lt;-rs++exprIsc2list r, disjunct==f']</span>
<span class="lineno"> 1395 </span><span class="spaces">            </span><span class="nottickedoff">absor0' = [disjunct | disjunct&lt;-exprUni2list r, f'&lt;-rs++exprIsc2list l, disjunct==f']</span>
<span class="lineno"> 1396 </span><span class="spaces">            </span><span class="nottickedoff">absor1  = [(disjunct, exprUni2list l&gt;-[disjunct]) | disjunct&lt;-exprUni2list l, ECpl f'&lt;-rs++exprIsc2list r, disjunct==f']++</span>
<span class="lineno"> 1397 </span><span class="spaces">                      </span><span class="nottickedoff">[(disjunct, exprUni2list l&gt;-[disjunct]) | disjunct@(ECpl t')&lt;-exprUni2list l, f'&lt;-rs++exprIsc2list r, t'==f']</span>
<span class="lineno"> 1398 </span><span class="spaces">            </span><span class="nottickedoff">absor1' = [(disjunct, exprUni2list r&gt;-[disjunct]) | disjunct&lt;-exprUni2list r, ECpl f'&lt;-rs++exprIsc2list l, disjunct==f']++</span>
<span class="lineno"> 1399 </span><span class="spaces">                      </span><span class="nottickedoff">[(disjunct, exprUni2list r&gt;-[disjunct]) | disjunct@(ECpl t')&lt;-exprUni2list r, f'&lt;-rs++exprIsc2list l, t'==f']</span>
<span class="lineno"> 1400 </span><span class="spaces">            </span><span class="nottickedoff">absorbAsy = eqClass same eList where e `same` e' = isAsy e &amp;&amp; isAsy e' &amp;&amp; e == flp e'</span>
<span class="lineno"> 1401 </span><span class="spaces">            </span><span class="nottickedoff">absorbAsyRfx = eqClass same eList where e `same` e' = isRfx e &amp;&amp; isAsy e &amp;&amp; isRfx e' &amp;&amp; isAsy e' &amp;&amp; e == flp e'</span>
<span class="lineno"> 1402 </span><span class="spaces">            </span><span class="nottickedoff">eList  = rs++exprIsc2list l++exprIsc2list r</span>
<span class="lineno"> 1403 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EUni (EIsc (l,k),r)) _  | posCpl==dnf    = ((l.\/.r) ./\. (k.\/.r), [&quot;distribute \\/ over /\\&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1404 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EUni (l,EIsc (k,r))) _  | posCpl==dnf    = ((l.\/.k) ./\. (l.\/.r), [&quot;distribute \\/ over /\\&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1405 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EUni (ECpl x,r@(ELrs (z,y)))) _          = if sign x==sign z -- necessary to guarantee that sign expr is equal to sign of the result</span>
<span class="lineno"> 1406 </span><span class="spaces">                                                        </span><span class="nottickedoff">then (notCpl (x .:. y) .\/. z, [&quot;remove left residual (/)&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1407 </span><span class="spaces">                                                        </span><span class="nottickedoff">else (notCpl t .\/. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1408 </span><span class="spaces">                                                           </span><span class="nottickedoff">where (t,steps, equ')  = nM (not posCpl) x []</span>
<span class="lineno"> 1409 </span><span class="spaces">                                                                 </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r []</span>
<span class="lineno"> 1410 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EUni (l@(ELrs (z,y)),ECpl x)) _          = if sign x==sign z -- necessary to guarantee that sign expr is equal to sign of the result</span>
<span class="lineno"> 1411 </span><span class="spaces">                                                        </span><span class="nottickedoff">then (notCpl (x .:. y) .\/. z, [&quot;remove left residual (/)&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1412 </span><span class="spaces">                                                        </span><span class="nottickedoff">else (notCpl t .\/. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1413 </span><span class="spaces">                                                           </span><span class="nottickedoff">where (t,steps, equ')  = nM (not posCpl) x []</span>
<span class="lineno"> 1414 </span><span class="spaces">                                                                 </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl l []</span>
<span class="lineno"> 1415 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EUni (l@(ERrs (x,z)),ECpl y)) _          = if sign y==sign z -- necessary to guarantee that sign expr is equal to sign of the result</span>
<span class="lineno"> 1416 </span><span class="spaces">                                                        </span><span class="nottickedoff">then (notCpl (x .:. y) .\/. z, [&quot;remove right residual (\\)&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1417 </span><span class="spaces">                                                        </span><span class="nottickedoff">else (notCpl t .\/. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1418 </span><span class="spaces">                                                           </span><span class="nottickedoff">where (t,steps, equ')  = nM (not posCpl) y []</span>
<span class="lineno"> 1419 </span><span class="spaces">                                                                 </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl l []</span>
<span class="lineno"> 1420 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl (EUni (ECpl y,r@(ERrs (x,z)))) _          = if sign y==sign z -- necessary to guarantee that sign expr is equal to sign of the result</span>
<span class="lineno"> 1421 </span><span class="spaces">                                                        </span><span class="nottickedoff">then (notCpl (x .:. y) .\/. z, [&quot;remove right residual (\\)&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1422 </span><span class="spaces">                                                        </span><span class="nottickedoff">else (notCpl t .\/. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1423 </span><span class="spaces">                                                           </span><span class="nottickedoff">where (t,steps, equ')  = nM (not posCpl) y []</span>
<span class="lineno"> 1424 </span><span class="spaces">                                                                 </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r []</span>
<span class="lineno"> 1425 </span><span class="spaces">  </span><span class="nottickedoff">nM posCpl x@(EUni (l,r)) rs</span>
<span class="lineno"> 1426 </span><span class="spaces"></span><span class="nottickedoff">-- Absorb equals:    r\/r  --&gt;  r</span>
<span class="lineno"> 1427 </span><span class="spaces">      </span><span class="nottickedoff">| t/=l || f/=r</span>
<span class="lineno"> 1428 </span><span class="spaces">           </span><span class="nottickedoff">= (t .\/. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1429 </span><span class="spaces">      </span><span class="nottickedoff">| or [length cl&gt;1 |cl&lt;-absorbClasses]   -- yields False if absorbClasses is empty</span>
<span class="lineno"> 1430 </span><span class="spaces">           </span><span class="nottickedoff">= ( foldr1 (.\/.) [head cl | cl&lt;-absorbClasses]  -- cl cannot be empty, because it is made by eqClass</span>
<span class="lineno"> 1431 </span><span class="spaces">             </span><span class="nottickedoff">, [shw e++&quot; \\/ &quot;++shw e++&quot; = &quot;++shw e | cl&lt;-absorbClasses, length cl&gt;1, let e=head cl]</span>
<span class="lineno"> 1432 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;&lt;=&gt;&quot;</span>
<span class="lineno"> 1433 </span><span class="spaces">             </span><span class="nottickedoff">)</span>
<span class="lineno"> 1434 </span><span class="spaces"></span><span class="nottickedoff">-- Tautologies:</span>
<span class="lineno"> 1435 </span><span class="spaces">      </span><span class="nottickedoff">| (not.null) tauts               = (EDcV (sign x), [&quot;let e = &quot;++ shw (head tauts)++&quot;. Since -e\\/e = V we get&quot;], &quot;&lt;=&gt;&quot;)   -- r\/-r  --&gt;  V</span>
<span class="lineno"> 1436 </span><span class="spaces">      </span><span class="nottickedoff">| isTrue l                       = (EDcV (sign x), [&quot;V\\/x = V&quot;], &quot;&lt;=&gt;&quot;)                                                  -- r\/V   --&gt;  V</span>
<span class="lineno"> 1437 </span><span class="spaces">      </span><span class="nottickedoff">| isTrue r                       = (EDcV (sign x), [&quot;x\\/V = V&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1438 </span><span class="spaces"></span><span class="nottickedoff">-- Absorb -V:    r\/-V  --&gt; r</span>
<span class="lineno"> 1439 </span><span class="spaces">      </span><span class="nottickedoff">| isFalse l                      = (r, [&quot;-V\\/x = x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1440 </span><span class="spaces">      </span><span class="nottickedoff">| isFalse r                      = (l, [&quot;x\\/-V = x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1441 </span><span class="spaces"></span><span class="nottickedoff">-- Absorb:    (x/\\y)\\/y  =  y</span>
<span class="lineno"> 1442 </span><span class="spaces">      </span><span class="nottickedoff">| isEIsc l &amp;&amp; not (null absor0)  = let t'=head absor0  in (r, [&quot;absorb &quot;++shw l++&quot; because of &quot;++shw t'++&quot;, using law  (x/\\y)\\/y = y&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1443 </span><span class="spaces">      </span><span class="nottickedoff">| isEIsc r &amp;&amp; not (null absor0') = let t'=head absor0' in (r, [&quot;absorb &quot;++shw r++&quot; because of &quot;++shw t'++&quot;, using law  (x/\\y)\\/x = x&quot;], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1444 </span><span class="spaces"></span><span class="nottickedoff">-- Absorb:    (x/\\-y)\\/y  =  x\\/y</span>
<span class="lineno"> 1445 </span><span class="spaces">      </span><span class="nottickedoff">| isEIsc l &amp;&amp; not (null absor1)</span>
<span class="lineno"> 1446 </span><span class="spaces">           </span><span class="nottickedoff">= ( case head absor1 of</span>
<span class="lineno"> 1447 </span><span class="spaces">                 </span><span class="nottickedoff">(_,[]) -&gt; r</span>
<span class="lineno"> 1448 </span><span class="spaces">                 </span><span class="nottickedoff">(_,ts) -&gt; foldr1 (./\.) ts .\/. r</span>
<span class="lineno"> 1449 </span><span class="spaces">             </span><span class="nottickedoff">, [&quot;absorb &quot;++shw t'++&quot;, using law (x/\\-y)\\/y  =  x\\/y&quot; | (t',_)&lt;-absor1]</span>
<span class="lineno"> 1450 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;&lt;=&gt;&quot;</span>
<span class="lineno"> 1451 </span><span class="spaces">             </span><span class="nottickedoff">)</span>
<span class="lineno"> 1452 </span><span class="spaces">      </span><span class="nottickedoff">| isEIsc r &amp;&amp; not (null absor1')</span>
<span class="lineno"> 1453 </span><span class="spaces">           </span><span class="nottickedoff">= ( case head absor1' of</span>
<span class="lineno"> 1454 </span><span class="spaces">                 </span><span class="nottickedoff">(_,[]) -&gt; l</span>
<span class="lineno"> 1455 </span><span class="spaces">                 </span><span class="nottickedoff">(_,ts) -&gt; l .\/. foldr1 (./\.) ts</span>
<span class="lineno"> 1456 </span><span class="spaces">             </span><span class="nottickedoff">, [&quot;absorb &quot;++shw t'++&quot;, using law x\\/(y/\\-x)  =  x\\/y&quot; | (t',_)&lt;-absor1' ]</span>
<span class="lineno"> 1457 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;&lt;=&gt;&quot;</span>
<span class="lineno"> 1458 </span><span class="spaces">             </span><span class="nottickedoff">)</span>
<span class="lineno"> 1459 </span><span class="spaces">      </span><span class="nottickedoff">| otherwise = (t .\/. f, steps++steps', fEqu [equ',equ''])</span>
<span class="lineno"> 1460 </span><span class="spaces">      </span><span class="nottickedoff">where (t,steps, equ')  = nM posCpl l []</span>
<span class="lineno"> 1461 </span><span class="spaces">            </span><span class="nottickedoff">(f,steps',equ'') = nM posCpl r (l:rs)</span>
<span class="lineno"> 1462 </span><span class="spaces">         </span><span class="nottickedoff">-- absorption can take place if two terms are equal. So let us make a list of equal terms: absorbClasses (for substituting r\/r by r)</span>
<span class="lineno"> 1463 </span><span class="spaces">            </span><span class="nottickedoff">absorbClasses = eqClass (==) (exprUni2list l++exprUni2list r)</span>
<span class="lineno"> 1464 </span><span class="spaces">         </span><span class="nottickedoff">-- tautologies occur if -r\/r, so we are looking for pairs, (x,l) such that x== -l</span>
<span class="lineno"> 1465 </span><span class="spaces">            </span><span class="nottickedoff">tauts = [t' |disjunct&lt;-exprUni2list r,disjunct==notCpl l, ECpl t'&lt;-[disjunct,l]]</span>
<span class="lineno"> 1466 </span><span class="spaces">            </span><span class="nottickedoff">absor0  = [t' | t'&lt;-exprIsc2list l, f'&lt;-rs++exprUni2list r, t'==f']</span>
<span class="lineno"> 1467 </span><span class="spaces">            </span><span class="nottickedoff">absor0' = [t' | t'&lt;-exprIsc2list r, f'&lt;-rs++exprUni2list l, t'==f']</span>
<span class="lineno"> 1468 </span><span class="spaces">            </span><span class="nottickedoff">absor1  = [(t', exprIsc2list l&gt;-[t']) | t'&lt;-exprIsc2list l, ECpl f'&lt;-rs++exprUni2list r, t'==f']++[(e, exprIsc2list l&gt;-[e]) | e@(ECpl t')&lt;-exprIsc2list l, f'&lt;-rs++exprUni2list r, t'==f']</span>
<span class="lineno"> 1469 </span><span class="spaces">            </span><span class="nottickedoff">absor1' = [(t', exprIsc2list r&gt;-[t']) | t'&lt;-exprIsc2list r, ECpl f'&lt;-rs++exprUni2list l, t'==f']++[(e, exprIsc2list r&gt;-[e]) | e@(ECpl t')&lt;-exprIsc2list r, f'&lt;-rs++exprUni2list l, t'==f']</span>
<span class="lineno"> 1470 </span><span class="spaces">  </span><span class="nottickedoff">nM _ (EFlp e) _ | isSym e =  (e,[shw e++&quot; is symmetric&quot;],&quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1471 </span><span class="spaces">  </span><span class="nottickedoff">nM _ x _               = (x,[],&quot;&lt;=&gt;&quot;)</span></span>
<span class="lineno"> 1472 </span>
<span class="lineno"> 1473 </span>fEqu :: [String] -&gt; String
<span class="lineno"> 1474 </span><span class="decl"><span class="nottickedoff">fEqu ss = if and [s==&quot;&lt;=&gt;&quot; | s&lt;-ss] then &quot;&lt;=&gt;&quot; else &quot;==&gt;&quot;</span></span>
<span class="lineno"> 1475 </span>{-
<span class="lineno"> 1476 </span>   nfProof :: (Expression -&gt; String) -&gt; Expression -&gt; Proof Expression
<span class="lineno"> 1477 </span>   nfProof shw = nfPr shw True True -- The first boolean True means that clauses are derived using &lt;=&gt; derivations. The second True means that a disjunctive normal form is produced.
<span class="lineno"> 1478 </span>-}
<span class="lineno"> 1479 </span>
<span class="lineno"> 1480 </span>nfPr :: (Expression -&gt; String) -&gt; Bool -&gt; Bool -&gt; Expression -&gt; [(Expression, [String], String)]
<span class="lineno"> 1481 </span><span class="decl"><span class="nottickedoff">nfPr shw eq dnf expr</span>
<span class="lineno"> 1482 </span><span class="spaces"> </span><span class="nottickedoff">= {-if showADL expr==&quot;r \\/ s&quot;</span>
<span class="lineno"> 1483 </span><span class="spaces">   </span><span class="nottickedoff">then fatal 360 (&quot;Diagnose expr: &quot;++showADL expr++&quot;\n&quot;++</span>
<span class="lineno"> 1484 </span><span class="spaces">                   </span><span class="nottickedoff">&quot;eq:            &quot;++show eq++&quot;\n&quot;++</span>
<span class="lineno"> 1485 </span><span class="spaces">                   </span><span class="nottickedoff">&quot;dnf:           &quot;++show eq++&quot;\n&quot;++</span>
<span class="lineno"> 1486 </span><span class="spaces">                   </span><span class="nottickedoff">&quot;res:           &quot;++showADL res++&quot;\n&quot;++</span>
<span class="lineno"> 1487 </span><span class="spaces">                   </span><span class="nottickedoff">&quot;expr==res:     &quot;++show (expr==res)</span>
<span class="lineno"> 1488 </span><span class="spaces">                  </span><span class="nottickedoff">) else-}</span>
<span class="lineno"> 1489 </span><span class="spaces">   </span><span class="nottickedoff">if expr==res</span>
<span class="lineno"> 1490 </span><span class="spaces">   </span><span class="nottickedoff">then [(expr,[],&quot;&lt;=&gt;&quot;)]</span>
<span class="lineno"> 1491 </span><span class="spaces">   </span><span class="nottickedoff">else (expr,steps,equ):nfPr shw eq dnf (simplify res)</span>
<span class="lineno"> 1492 </span><span class="spaces"> </span><span class="nottickedoff">where (res,steps,equ) = normStep shw eq dnf False expr</span></span>
<span class="lineno"> 1493 </span>
<span class="lineno"> 1494 </span>conjNF, disjNF :: Options -&gt; Expression -&gt; Expression
<span class="lineno"> 1495 </span>(conjNF, disjNF) = <span class="nottickedoff">(pr False, pr True)</span>
<span class="lineno"> 1496 </span> where <span class="nottickedoff">pr dnf opts expr</span>
<span class="lineno"> 1497 </span><span class="spaces">        </span><span class="nottickedoff">= case oldNormalizer opts of</span>
<span class="lineno"> 1498 </span><span class="spaces">           </span><span class="nottickedoff">False -&gt; let rterm = expr2RTerm expr</span>
<span class="lineno"> 1499 </span><span class="spaces">                    </span><span class="nottickedoff">in (rTerm2expr.last.((:) (rterm)).map (rhs.snd).slideDown (weightNF dnf)) rterm</span>
<span class="lineno"> 1500 </span><span class="spaces">           </span><span class="nottickedoff">True  -&gt; let proof = if dnf then dfProof opts else cfProof opts</span>
<span class="lineno"> 1501 </span><span class="spaces">                        </span><span class="nottickedoff">(e,_,_) = if null (proof expr) then fatal 340 &quot;last: empty list&quot; else last (proof expr)</span>
<span class="lineno"> 1502 </span><span class="spaces">                    </span><span class="nottickedoff">in e</span>
<span class="lineno"> 1503 </span>
<span class="lineno"> 1504 </span>cfProof, dfProof :: Options -&gt; Expression -&gt; Proof Expression
<span class="lineno"> 1505 </span>(cfProof,dfProof) = <span class="nottickedoff">(proof False, proof True)</span>
<span class="lineno"> 1506 </span> where
<span class="lineno"> 1507 </span>   proof :: Bool -&gt; Options -&gt; Expression -&gt; Proof Expression
<span class="lineno"> 1508 </span>   <span class="nottickedoff">proof dnf opts expr</span>
<span class="lineno"> 1509 </span><span class="spaces">    </span><span class="nottickedoff">= case oldNormalizer opts of</span>
<span class="lineno"> 1510 </span><span class="spaces">       </span><span class="nottickedoff">False -&gt; [ (rTerm2expr term, explStr, logicSym) | (term, explStr, logicSym)&lt;-prRT (expr2RTerm expr) ]</span>
<span class="lineno"> 1511 </span><span class="spaces">       </span><span class="nottickedoff">True  -&gt; [line | step, line&lt;-init pr]++</span>
<span class="lineno"> 1512 </span><span class="spaces">                </span><span class="nottickedoff">[line | step', line&lt;-init pr']++</span>
<span class="lineno"> 1513 </span><span class="spaces">                </span><span class="nottickedoff">[last ([(expr,[],&quot;&lt;=&gt;&quot;)]++</span>
<span class="lineno"> 1514 </span><span class="spaces">                       </span><span class="nottickedoff">[line | step, line&lt;-pr]++</span>
<span class="lineno"> 1515 </span><span class="spaces">                       </span><span class="nottickedoff">[line | step', line&lt;-pr']</span>
<span class="lineno"> 1516 </span><span class="spaces">                      </span><span class="nottickedoff">)]</span>
<span class="lineno"> 1517 </span><span class="spaces">      </span><span class="nottickedoff">where</span>
<span class="lineno"> 1518 </span><span class="spaces">        </span><span class="nottickedoff">prRT :: RTerm -&gt; [(RTerm, [String], String)]</span>
<span class="lineno"> 1519 </span><span class="spaces">        </span><span class="nottickedoff">prRT term</span>
<span class="lineno"> 1520 </span><span class="spaces">           </span><span class="nottickedoff">= case slideDown (weightNF dnf) term of</span>
<span class="lineno"> 1521 </span><span class="spaces">               </span><span class="nottickedoff">[] -&gt; [ (term, [&quot;weight: &quot;++show (weightNF dnf term)], &quot;&lt;=&gt;&quot;) ]</span>
<span class="lineno"> 1522 </span><span class="spaces">               </span><span class="nottickedoff">ds -&gt; [ (lhs d, [&quot; weight: &quot;++show w++&quot;,   &quot;++showADL tmpl++&quot; = &quot;++showADL stp++&quot;  with unifier: &quot;++showADL unif | let (tmpl,unif,stp) = rul d], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1523 </span><span class="spaces">                     </span><span class="nottickedoff">| (w,d)&lt;-ds ] ++</span>
<span class="lineno"> 1524 </span><span class="spaces">                     </span><span class="nottickedoff">[ (rhs d, [], &quot;&lt;=&gt;&quot;)</span>
<span class="lineno"> 1525 </span><span class="spaces">                     </span><span class="nottickedoff">| let (_,d) = last ds ]</span>
<span class="lineno"> 1526 </span><span class="spaces">        </span><span class="nottickedoff">pr           = nfPr showADL True dnf expr</span>
<span class="lineno"> 1527 </span><span class="spaces">        </span><span class="nottickedoff">(expr',_,_)  = if null pr then fatal 356 &quot;last: empty list&quot; else last pr</span>
<span class="lineno"> 1528 </span><span class="spaces">        </span><span class="nottickedoff">step         = simplify expr/=simplify expr'</span>
<span class="lineno"> 1529 </span><span class="spaces">        </span><span class="nottickedoff">pr'          = nfPr showADL True dnf expr'</span>
<span class="lineno"> 1530 </span><span class="spaces">        </span><span class="nottickedoff">step'        = simplify expr'/=simplify expr''</span>
<span class="lineno"> 1531 </span><span class="spaces">        </span><span class="nottickedoff">(expr'',_,_) = if null pr' then fatal 365 &quot;last: empty list&quot; else last pr'</span>
<span class="lineno"> 1532 </span>
<span class="lineno"> 1533 </span>{-
<span class="lineno"> 1534 </span>   cfProof :: Expression -&gt; Proof Expression
<span class="lineno"> 1535 </span>   cfProof expr
<span class="lineno"> 1536 </span>    = [line | step, line&lt;-init pr]++
<span class="lineno"> 1537 </span>      [line | step', line&lt;-init pr']++
<span class="lineno"> 1538 </span>      [last ([(expr,[],&quot;&lt;=&gt;&quot;)]++
<span class="lineno"> 1539 </span>             [line | step, line&lt;-pr]++
<span class="lineno"> 1540 </span>             [line | step', line&lt;-pr']
<span class="lineno"> 1541 </span>            )]
<span class="lineno"> 1542 </span>      where pr           = nfPr showADL True False (simplify expr)
<span class="lineno"> 1543 </span>            (expr',_,_)  = if null pr then fatal 328 &quot;last: empty list&quot; else last pr
<span class="lineno"> 1544 </span>            step         = simplify expr/=expr' -- obsolete?    || and [null s | (_,ss,_)&lt;-pr, s&lt;-ss]
<span class="lineno"> 1545 </span>            pr'          = nfPr showADL True False (simplify expr')
<span class="lineno"> 1546 </span>            step'        = simplify expr'/=simplify expr'' -- obsolete?    || and [null s | (_,ss,_)&lt;-pr', s&lt;-ss]
<span class="lineno"> 1547 </span>            (expr'',_,_) = if null pr' then fatal 337 &quot;last: empty list&quot; else last pr'
<span class="lineno"> 1548 </span>
<span class="lineno"> 1549 </span>   dfProof :: Expression -&gt; Proof Expression
<span class="lineno"> 1550 </span>   dfProof expr
<span class="lineno"> 1551 </span>    = [line | step, line&lt;-init pr]++
<span class="lineno"> 1552 </span>      [line | step', line&lt;-init pr']++
<span class="lineno"> 1553 </span>      [last ([(expr,[],&quot;&lt;=&gt;&quot;)]++
<span class="lineno"> 1554 </span>             [line | step, line&lt;-pr]++
<span class="lineno"> 1555 </span>             [line | step', line&lt;-pr']
<span class="lineno"> 1556 </span>            )]
<span class="lineno"> 1557 </span>      where pr           = nfPr showADL True True expr
<span class="lineno"> 1558 </span>            (expr',_,_)  = if null pr then fatal 356 &quot;last: empty list&quot; else last pr
<span class="lineno"> 1559 </span>            step         = simplify expr/=simplify expr'
<span class="lineno"> 1560 </span>            pr'          = nfPr showADL True True expr'
<span class="lineno"> 1561 </span>            step'        = simplify expr'/=simplify expr''
<span class="lineno"> 1562 </span>            (expr'',_,_) = if null pr' then fatal 365 &quot;last: empty list&quot; else last pr'
<span class="lineno"> 1563 </span>-}
<span class="lineno"> 1564 </span>
<span class="lineno"> 1565 </span>isEUni :: Expression -&gt; Bool
<span class="lineno"> 1566 </span><span class="decl"><span class="nottickedoff">isEUni EUni{}  = True</span>
<span class="lineno"> 1567 </span><span class="spaces"></span><span class="nottickedoff">isEUni _       = False</span></span>
<span class="lineno"> 1568 </span>
<span class="lineno"> 1569 </span>isEIsc :: Expression -&gt; Bool
<span class="lineno"> 1570 </span><span class="decl"><span class="nottickedoff">isEIsc EIsc{}  = True</span>
<span class="lineno"> 1571 </span><span class="spaces"></span><span class="nottickedoff">isEIsc _       = False</span></span>
<span class="lineno"> 1572 </span>
<span class="lineno"> 1573 </span>
<span class="lineno"> 1574 </span>
<span class="lineno"> 1575 </span>
<span class="lineno"> 1576 </span>
<span class="lineno"> 1577 </span>conjuncts :: Options -&gt; Rule -&gt; [Expression]
<span class="lineno"> 1578 </span><span class="decl"><span class="nottickedoff">conjuncts opts = exprIsc2list.conjNF opts.rrexp</span></span>
<span class="lineno"> 1579 </span>
<span class="lineno"> 1580 </span>allShifts :: Options -&gt; DnfClause -&gt; [DnfClause]
<span class="lineno"> 1581 </span><span class="decl"><span class="nottickedoff">allShifts opts conjunct =  (map head.eqClass (==).filter pnEq.map normDNF) (shiftL conjunct++shiftR conjunct)  -- we want to nub all dnf-clauses, but nub itself does not do the trick...</span>
<span class="lineno"> 1582 </span><span class="spaces"></span><span class="nottickedoff">-- allShifts conjunct = error $ show conjunct++concat [ &quot;\n&quot;++show e'| e'&lt;-shiftL conjunct++shiftR conjunct] -- for debugging</span>
<span class="lineno"> 1583 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno"> 1584 </span><span class="spaces"> </span><span class="nottickedoff">{-</span>
<span class="lineno"> 1585 </span><span class="spaces">  </span><span class="nottickedoff">diagnostic</span>
<span class="lineno"> 1586 </span><span class="spaces">   </span><span class="nottickedoff">= intercalate &quot;\n  &quot;</span>
<span class="lineno"> 1587 </span><span class="spaces">       </span><span class="nottickedoff">[ &quot;shiftL: [ &quot;++intercalate &quot;\n          , &quot; [showHS opts &quot;\n            &quot; e | e&lt;-shiftL conjunct    ]++&quot;\n          ]&quot;</span>
<span class="lineno"> 1588 </span><span class="spaces">       </span><span class="nottickedoff">, &quot;shiftR: [ &quot;++intercalate &quot;\n          , &quot; [showHS opts &quot;\n            &quot; e | e&lt;-shiftR conjunct    ]++&quot;\n          ]&quot;</span>
<span class="lineno"> 1589 </span><span class="spaces">       </span><span class="nottickedoff">] -}</span>
<span class="lineno"> 1590 </span><span class="spaces">  </span><span class="nottickedoff">shiftL :: DnfClause -&gt; [DnfClause]</span>
<span class="lineno"> 1591 </span><span class="spaces">  </span><span class="nottickedoff">shiftL dc</span>
<span class="lineno"> 1592 </span><span class="spaces">   </span><span class="nottickedoff">| null (antcs dc)|| null (conss dc) = [dc] --  shiftL doesn't work here. This is just to make sure that both antss and conss are really not empty</span>
<span class="lineno"> 1593 </span><span class="spaces">   </span><span class="nottickedoff">| otherwise = [ Dnf { antcs = ass</span>
<span class="lineno"> 1594 </span><span class="spaces">                       </span><span class="nottickedoff">, conss = case css of</span>
<span class="lineno"> 1595 </span><span class="spaces">                                   </span><span class="nottickedoff">[] -&gt; let antcExpr = foldr1 (./\.) ass in</span>
<span class="lineno"> 1596 </span><span class="spaces">                                         </span><span class="nottickedoff">if isEndo antcExpr then [EDcI (source antcExpr)] else fatal 425 &quot;antcExpr should be endorelation&quot;</span>
<span class="lineno"> 1597 </span><span class="spaces">                                   </span><span class="nottickedoff">_  -&gt; css</span>
<span class="lineno"> 1598 </span><span class="spaces">                       </span><span class="nottickedoff">}</span>
<span class="lineno"> 1599 </span><span class="spaces">                 </span><span class="nottickedoff">| (ass,css)&lt;-nub (move (antcs dc) (conss dc))</span>
<span class="lineno"> 1600 </span><span class="spaces">                 </span><span class="nottickedoff">]</span>
<span class="lineno"> 1601 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno"> 1602 </span><span class="spaces">   </span><span class="nottickedoff">-- example:  r;s /\ p;r |- x;y   and suppose x and y are both univalent.</span>
<span class="lineno"> 1603 </span><span class="spaces">   </span><span class="nottickedoff">--  antcs =  [ r;s, p;r ]</span>
<span class="lineno"> 1604 </span><span class="spaces">   </span><span class="nottickedoff">--  conss =  [ x;y ]</span>
<span class="lineno"> 1605 </span><span class="spaces">    </span><span class="nottickedoff">move :: [Expression] -&gt; [Expression] -&gt; [([Expression],[Expression])]</span>
<span class="lineno"> 1606 </span><span class="spaces">    </span><span class="nottickedoff">move ass [] = [(ass,[])]</span>
<span class="lineno"> 1607 </span><span class="spaces">    </span><span class="nottickedoff">move ass css</span>
<span class="lineno"> 1608 </span><span class="spaces">     </span><span class="nottickedoff">= (ass,css):</span>
<span class="lineno"> 1609 </span><span class="spaces">       </span><span class="nottickedoff">if and [ (not.isEDcI) cs | cs&lt;-css]     -- all cs are nonempty because: (not.and.map isEDcI) cs ==&gt; not (null cs)</span>
<span class="lineno"> 1610 </span><span class="spaces">       </span><span class="nottickedoff">then [ts | let headEs = map headECps css</span>
<span class="lineno"> 1611 </span><span class="spaces">                </span><span class="nottickedoff">, length (eqClass (==) headEs) == 1                    -- example: True, because map head css == [ &quot;x&quot; ]</span>
<span class="lineno"> 1612 </span><span class="spaces">                </span><span class="nottickedoff">, let h=head headEs                                    -- example: h= &quot;x&quot;</span>
<span class="lineno"> 1613 </span><span class="spaces">                </span><span class="nottickedoff">, isUni h                                              -- example: assume True</span>
<span class="lineno"> 1614 </span><span class="spaces">                </span><span class="nottickedoff">, ts&lt;-move [if source h==source as then flp h.:.as else fatal 455 &quot;type mismatch&quot;</span>
<span class="lineno"> 1615 </span><span class="spaces">                           </span><span class="nottickedoff">|as&lt;-ass] (map tailECps css)]++ -- example: ts&lt;-move [ [flp &quot;x&quot;,&quot;r&quot;,&quot;s&quot;], [flp &quot;x&quot;,&quot;p&quot;,&quot;r&quot;] ]  [ [&quot;y&quot;,&quot;z&quot;] ]</span>
<span class="lineno"> 1616 </span><span class="spaces">            </span><span class="nottickedoff">[ts | let lastEs = map lastECps css</span>
<span class="lineno"> 1617 </span><span class="spaces">                </span><span class="nottickedoff">, length (eqClass (==) lastEs) == 1</span>
<span class="lineno"> 1618 </span><span class="spaces">                </span><span class="nottickedoff">, let l=head lastEs</span>
<span class="lineno"> 1619 </span><span class="spaces">                </span><span class="nottickedoff">, isInj l</span>
<span class="lineno"> 1620 </span><span class="spaces">                </span><span class="nottickedoff">, ts&lt;-move [if target as==target l then as.:.flp l else fatal 461 &quot;type mismatch&quot;</span>
<span class="lineno"> 1621 </span><span class="spaces">                           </span><span class="nottickedoff">|as&lt;-ass] (map initECps css)]   -- example: ts&lt;-move [ [&quot;r&quot;,&quot;s&quot;,flp &quot;z&quot;], [&quot;p&quot;,&quot;r&quot;,flp &quot;z&quot;] ]  [ [&quot;x&quot;,&quot;y&quot;] ]</span>
<span class="lineno"> 1622 </span><span class="spaces">       </span><span class="nottickedoff">else []</span>
<span class="lineno"> 1623 </span><span class="spaces">   </span><span class="nottickedoff">-- Here is (informally) what the example does:</span>
<span class="lineno"> 1624 </span><span class="spaces">   </span><span class="nottickedoff">-- move [ r;s , p;r ] [ x;y ]</span>
<span class="lineno"> 1625 </span><span class="spaces">   </span><span class="nottickedoff">-- ( [ r;s , p;r ] , [ x;y ] ): [ ts | ts&lt;-move [flp x.:.as | as&lt;-[ r;s , p;r ] [ y ] ] ]</span>
<span class="lineno"> 1626 </span><span class="spaces">   </span><span class="nottickedoff">-- ( [ r;s , p;r ] , [ x;y ] ): ( [ x~;r;s , x~;p;r ] , [ y ] ): [ ts | ts&lt;-move [flp y.:.as | as&lt;-[ y~;x~;r;s , y~;x~;p;r ] [] ] ]</span>
<span class="lineno"> 1627 </span><span class="spaces">   </span><span class="nottickedoff">-- ( [ r;s , p;r ] , [ x;y ] ): ( [ x~;r;s , x~;p;r ] , [ y ] ): [ [ y~;x~;r;s , y~;x~;p;r ] , [] ] ]</span>
<span class="lineno"> 1628 </span><span class="spaces">   </span><span class="nottickedoff">-- [ ( [ r;s , p;r ] , [ x;y ] ), ( [ x~;r;s , x~;p;r ] , [ y ] ), ( [ y~;x~;r;s , y~;x~;p;r ] , [] ) ]</span>
<span class="lineno"> 1629 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1630 </span><span class="spaces">  </span><span class="nottickedoff">shiftR :: DnfClause -&gt; [DnfClause]</span>
<span class="lineno"> 1631 </span><span class="spaces">  </span><span class="nottickedoff">shiftR dc</span>
<span class="lineno"> 1632 </span><span class="spaces">   </span><span class="nottickedoff">| null (antcs dc) || null (conss dc) = [dc] --  shiftR doesn't work here. This is just to make sure that both antss and conss are really not empty</span>
<span class="lineno"> 1633 </span><span class="spaces">   </span><span class="nottickedoff">| otherwise                = [ Dnf (case ass of</span>
<span class="lineno"> 1634 </span><span class="spaces">                                        </span><span class="nottickedoff">[] -&gt; let consExpr = foldr1 (.\/.) css in</span>
<span class="lineno"> 1635 </span><span class="spaces">                                              </span><span class="nottickedoff">if source consExpr==target consExpr then [EDcI (source consExpr)] else fatal 463 &quot;consExpr should be endorelation&quot;</span>
<span class="lineno"> 1636 </span><span class="spaces">                                        </span><span class="nottickedoff">_  -&gt; ass</span>
<span class="lineno"> 1637 </span><span class="spaces">                                      </span><span class="nottickedoff">) css</span>
<span class="lineno"> 1638 </span><span class="spaces">                                </span><span class="nottickedoff">| (ass,css)&lt;-nub (move (antcs dc) (conss dc))</span>
<span class="lineno"> 1639 </span><span class="spaces">                                </span><span class="nottickedoff">]</span>
<span class="lineno"> 1640 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno"> 1641 </span><span class="spaces">   </span><span class="nottickedoff">-- example  &quot;r;s /\ r;r |- x;y&quot;   and suppose r is both surjective.</span>
<span class="lineno"> 1642 </span><span class="spaces">   </span><span class="nottickedoff">--  ass =  [ r;s , r;r ]</span>
<span class="lineno"> 1643 </span><span class="spaces">   </span><span class="nottickedoff">--  css =  [ x;y ]</span>
<span class="lineno"> 1644 </span><span class="spaces">    </span><span class="nottickedoff">move :: [Expression] -&gt; [Expression] -&gt; [([Expression],[Expression])]</span>
<span class="lineno"> 1645 </span><span class="spaces">    </span><span class="nottickedoff">move ass css =</span>
<span class="lineno"> 1646 </span><span class="spaces">     </span><span class="nottickedoff">case ass of</span>
<span class="lineno"> 1647 </span><span class="spaces">      </span><span class="nottickedoff">[] -&gt; [] -- was [([EDcI (target (last css))],css)]</span>
<span class="lineno"> 1648 </span><span class="spaces">      </span><span class="nottickedoff">_  -&gt;</span>
<span class="lineno"> 1649 </span><span class="spaces">       </span><span class="nottickedoff">(ass,css):</span>
<span class="lineno"> 1650 </span><span class="spaces">       </span><span class="nottickedoff">if and [ (not.isEDcI) as | as&lt;-ass]</span>
<span class="lineno"> 1651 </span><span class="spaces">       </span><span class="nottickedoff">then [ts | let headEs = map headECps ass</span>
<span class="lineno"> 1652 </span><span class="spaces">                </span><span class="nottickedoff">, length (eqClass (==) headEs) == 1                      -- example: True, because map headECps ass == [ &quot;r&quot;, &quot;r&quot; ]</span>
<span class="lineno"> 1653 </span><span class="spaces">                </span><span class="nottickedoff">, let h=head headEs                                      -- example: h= &quot;r&quot;</span>
<span class="lineno"> 1654 </span><span class="spaces">                </span><span class="nottickedoff">, isSur h                                                -- example: assume True</span>
<span class="lineno"> 1655 </span><span class="spaces">                </span><span class="nottickedoff">, ts&lt;-move (map tailECps ass) [if source h==source cs then flp h.:.cs else fatal 496 &quot;type mismatch&quot;</span>
<span class="lineno"> 1656 </span><span class="spaces">                                              </span><span class="nottickedoff">|cs&lt;-css]]++   -- example: ts&lt;-move  [[&quot;s&quot;], [&quot;r&quot;]] [ [flp &quot;r&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;] ]</span>
<span class="lineno"> 1657 </span><span class="spaces">            </span><span class="nottickedoff">[ts | let lastEs = map lastECps ass</span>
<span class="lineno"> 1658 </span><span class="spaces">                </span><span class="nottickedoff">, length (eqClass (==) lastEs) == 1                      -- example: False, because map lastECps ass == [ [&quot;s&quot;], [&quot;r&quot;] ]</span>
<span class="lineno"> 1659 </span><span class="spaces">                </span><span class="nottickedoff">, let l=head lastEs</span>
<span class="lineno"> 1660 </span><span class="spaces">                </span><span class="nottickedoff">, isTot l</span>
<span class="lineno"> 1661 </span><span class="spaces">                </span><span class="nottickedoff">, ts&lt;-move (map initECps ass) [if target cs==target l then cs.:.flp l else fatal 502 &quot;type mismatch&quot;</span>
<span class="lineno"> 1662 </span><span class="spaces">                                              </span><span class="nottickedoff">|cs&lt;-css]]     -- is dit goed? cs.:.flp l wordt links zwaar, terwijl de normalisator rechts zwaar maakt.</span>
<span class="lineno"> 1663 </span><span class="spaces">       </span><span class="nottickedoff">else []</span>
<span class="lineno"> 1664 </span><span class="spaces">   </span><span class="nottickedoff">-- Here is (informally) what the example does:</span>
<span class="lineno"> 1665 </span><span class="spaces">   </span><span class="nottickedoff">-- move [ r;s , r;r ] [ x;y ]</span>
<span class="lineno"> 1666 </span><span class="spaces">   </span><span class="nottickedoff">-- ( [ r;s , r;r ] , [ x;y ] ): move [ s , r ] [ r~;x;y ]</span>
<span class="lineno"> 1667 </span><span class="spaces">   </span><span class="nottickedoff">-- ( [ r;s , r;r ] , [ x;y ] ): ( [ s , r ]  , [ r~;x;y ] ) : []</span>
<span class="lineno"> 1668 </span><span class="spaces">   </span><span class="nottickedoff">-- [ [ r;s , r;r ] , [ x;y ] ), ( [ s , r ]  , [ r~;x;y ] ) ]</span>
<span class="lineno"> 1669 </span><span class="spaces">   </span><span class="nottickedoff">--  diagnostic</span>
<span class="lineno"> 1670 </span><span class="spaces">   </span><span class="nottickedoff">--    = &quot;\n  antcs: [ &quot;++intercalate &quot;\n         , &quot; [showADL a | a&lt;-antcs ]++&quot;\n       ]&quot;++</span>
<span class="lineno"> 1671 </span><span class="spaces">   </span><span class="nottickedoff">--      &quot;\n  conss: [ &quot;++intercalate &quot;\n         , &quot; [showADL c | c&lt;-conss ]++&quot;\n       ]&quot;++</span>
<span class="lineno"> 1672 </span><span class="spaces">   </span><span class="nottickedoff">--      &quot;\n  move:  [ &quot;++intercalate &quot;\n         , &quot; [&quot;(&quot;++sh &quot; /\\ &quot; as++&quot;\n           ,&quot;++sh &quot; \\/ &quot; cs++&quot;)&quot; | (as,cs)&lt;-move antcs conss ]++&quot;\n       ]&quot;</span>
<span class="lineno"> 1673 </span><span class="spaces">   </span><span class="nottickedoff">--  sh :: String -&gt; [Expression] -&gt; String</span>
<span class="lineno"> 1674 </span><span class="spaces">   </span><span class="nottickedoff">--  sh str es = intercalate str [ showADL e | e&lt;-es]</span>
<span class="lineno"> 1675 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1676 </span><span class="spaces">  </span><span class="nottickedoff">normDNF :: DnfClause -&gt; DnfClause</span>
<span class="lineno"> 1677 </span><span class="spaces">  </span><span class="nottickedoff">normDNF dc = </span>
<span class="lineno"> 1678 </span><span class="spaces">    </span><span class="nottickedoff">Dnf { antcs = case antcs dc of</span>
<span class="lineno"> 1679 </span><span class="spaces">                   </span><span class="nottickedoff">[] -&gt; []</span>
<span class="lineno"> 1680 </span><span class="spaces">                   </span><span class="nottickedoff">_  -&gt; (exprIsc2list . conjNF opts . foldr1 (./\.)) (antcs dc)</span>
<span class="lineno"> 1681 </span><span class="spaces">        </span><span class="nottickedoff">, conss = case conss dc of</span>
<span class="lineno"> 1682 </span><span class="spaces">                   </span><span class="nottickedoff">[] -&gt; []</span>
<span class="lineno"> 1683 </span><span class="spaces">                   </span><span class="nottickedoff">_  -&gt; (exprUni2list . disjNF opts . foldr1 (.\/.)) (conss dc)</span>
<span class="lineno"> 1684 </span><span class="spaces">        </span><span class="nottickedoff">}</span>
<span class="lineno"> 1685 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1686 </span><span class="spaces">  </span><span class="nottickedoff">pnEq :: DnfClause -&gt; Bool</span>
<span class="lineno"> 1687 </span><span class="spaces">  </span><span class="nottickedoff">pnEq dc = antcs dc /= conss dc</span>
<span class="lineno"> 1688 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1689 </span><span class="spaces">  </span><span class="nottickedoff">headECps :: Expression -&gt; Expression</span>
<span class="lineno"> 1690 </span><span class="spaces">  </span><span class="nottickedoff">headECps expr = f expr</span>
<span class="lineno"> 1691 </span><span class="spaces">   </span><span class="nottickedoff">where f (ECps (l@ECps{},_)) = f l</span>
<span class="lineno"> 1692 </span><span class="spaces">         </span><span class="nottickedoff">f (ECps (l,_)) = l</span>
<span class="lineno"> 1693 </span><span class="spaces">         </span><span class="nottickedoff">f _ = expr</span>
<span class="lineno"> 1694 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1695 </span><span class="spaces">  </span><span class="nottickedoff">tailECps :: Expression -&gt; Expression</span>
<span class="lineno"> 1696 </span><span class="spaces">  </span><span class="nottickedoff">tailECps expr = f expr</span>
<span class="lineno"> 1697 </span><span class="spaces">   </span><span class="nottickedoff">where f (ECps (ECps (l,r),q)) = f (ECps (l, ECps (r,q)))</span>
<span class="lineno"> 1698 </span><span class="spaces">         </span><span class="nottickedoff">f (ECps (_,r)) = r</span>
<span class="lineno"> 1699 </span><span class="spaces">         </span><span class="nottickedoff">f _ = EDcI (target expr)</span>
<span class="lineno"> 1700 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1701 </span><span class="spaces">  </span><span class="nottickedoff">initECps :: Expression -&gt; Expression</span>
<span class="lineno"> 1702 </span><span class="spaces">  </span><span class="nottickedoff">initECps expr = f expr</span>
<span class="lineno"> 1703 </span><span class="spaces">   </span><span class="nottickedoff">where f (ECps (l, ECps (r,q))) = initECps (ECps (ECps (l,r),q))</span>
<span class="lineno"> 1704 </span><span class="spaces">         </span><span class="nottickedoff">f (ECps (l,_)) = l</span>
<span class="lineno"> 1705 </span><span class="spaces">         </span><span class="nottickedoff">f _ = EDcI (source expr)</span>
<span class="lineno"> 1706 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1707 </span><span class="spaces">  </span><span class="nottickedoff">lastECps :: Expression -&gt; Expression</span>
<span class="lineno"> 1708 </span><span class="spaces">  </span><span class="nottickedoff">lastECps expr = f expr</span>
<span class="lineno"> 1709 </span><span class="spaces">   </span><span class="nottickedoff">where f (ECps (_,r@ECps{})) = f r</span>
<span class="lineno"> 1710 </span><span class="spaces">         </span><span class="nottickedoff">f (ECps (_,r)) = r</span>
<span class="lineno"> 1711 </span><span class="spaces">         </span><span class="nottickedoff">f _ = expr</span>
<span class="lineno"> 1712 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1713 </span><span class="spaces">  </span><span class="nottickedoff">isEDcI :: Expression -&gt; Bool</span>
<span class="lineno"> 1714 </span><span class="spaces">  </span><span class="nottickedoff">isEDcI EDcI{} = True</span>
<span class="lineno"> 1715 </span><span class="spaces">  </span><span class="nottickedoff">isEDcI _ = False</span></span>
<span class="lineno"> 1716 </span>
<span class="lineno"> 1717 </span>
<span class="lineno"> 1718 </span>makeAllConjs :: Options -&gt; [Rule] -&gt; [Conjunct]
<span class="lineno"> 1719 </span><span class="decl"><span class="nottickedoff">makeAllConjs opts allRls =</span>
<span class="lineno"> 1720 </span><span class="spaces">  </span><span class="nottickedoff">let conjExprs :: [(Expression, [Rule])]</span>
<span class="lineno"> 1721 </span><span class="spaces">      </span><span class="nottickedoff">conjExprs = converse [ (rule, conjuncts opts rule) | rule &lt;- allRls ]</span>
<span class="lineno"> 1722 </span><span class="spaces">      </span><span class="nottickedoff"></span>
<span class="lineno"> 1723 </span><span class="spaces">      </span><span class="nottickedoff">conjs = [ Cjct { rc_id = &quot;conj_&quot;++show (i :: Int)</span>
<span class="lineno"> 1724 </span><span class="spaces">                     </span><span class="nottickedoff">, rc_orgRules   = rs</span>
<span class="lineno"> 1725 </span><span class="spaces">                     </span><span class="nottickedoff">, rc_conjunct   = expr</span>
<span class="lineno"> 1726 </span><span class="spaces">                     </span><span class="nottickedoff">, rc_dnfClauses = allShifts opts (expr2dnfClause expr)</span>
<span class="lineno"> 1727 </span><span class="spaces">                     </span><span class="nottickedoff">}</span>
<span class="lineno"> 1728 </span><span class="spaces">              </span><span class="nottickedoff">| ((expr, rs),i) &lt;- zip conjExprs [0..]</span>
<span class="lineno"> 1729 </span><span class="spaces">              </span><span class="nottickedoff">]</span>
<span class="lineno"> 1730 </span><span class="spaces">  </span><span class="nottickedoff">in  conjs</span>
<span class="lineno"> 1731 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno"> 1732 </span><span class="spaces">      </span><span class="nottickedoff">expr2dnfClause :: Expression -&gt; DnfClause</span>
<span class="lineno"> 1733 </span><span class="spaces">      </span><span class="nottickedoff">expr2dnfClause conj = (split (Dnf [] []).exprUni2list) conj</span>
<span class="lineno"> 1734 </span><span class="spaces">       </span><span class="nottickedoff">where</span>
<span class="lineno"> 1735 </span><span class="spaces">         </span><span class="nottickedoff">split :: DnfClause -&gt; [Expression] -&gt; DnfClause</span>
<span class="lineno"> 1736 </span><span class="spaces">         </span><span class="nottickedoff">split (Dnf antc cons) (ECpl e: rest) = split (Dnf (e:antc) cons) rest</span>
<span class="lineno"> 1737 </span><span class="spaces">         </span><span class="nottickedoff">split (Dnf antc cons) (     e: rest) = split (Dnf antc (e:cons)) rest</span>
<span class="lineno"> 1738 </span><span class="spaces">         </span><span class="nottickedoff">split dc              []             = dc</span></span>
<span class="lineno"> 1739 </span>

</pre>
</body>
</html>
