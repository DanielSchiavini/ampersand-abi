<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=CP850">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="lineno">    1 </span>module Database.Design.Ampersand.FSpec.ToFSpec.ADL2Plug
<span class="lineno">    2 </span>  (showPlug
<span class="lineno">    3 </span>  ,makeGeneratedSqlPlugs
<span class="lineno">    4 </span>  ,makeUserDefinedSqlPlug
<span class="lineno">    5 </span>  )
<span class="lineno">    6 </span>where
<span class="lineno">    7 </span>import Database.Design.Ampersand.Core.AbstractSyntaxTree hiding (sortWith)
<span class="lineno">    8 </span>import Database.Design.Ampersand.Core.Poset as Poset hiding (sortWith)
<span class="lineno">    9 </span>import Prelude hiding (Ord(..))
<span class="lineno">   10 </span>import Database.Design.Ampersand.Basics
<span class="lineno">   11 </span>import Database.Design.Ampersand.Classes
<span class="lineno">   12 </span>import Database.Design.Ampersand.ADL1
<span class="lineno">   13 </span>import Database.Design.Ampersand.FSpec.ShowADL
<span class="lineno">   14 </span>import Database.Design.Ampersand.FSpec.FSpec
<span class="lineno">   15 </span>import Database.Design.Ampersand.Misc
<span class="lineno">   16 </span>import Database.Design.Ampersand.FSpec.ShowHS --for debugging
<span class="lineno">   17 </span>import Data.Maybe
<span class="lineno">   18 </span>import Data.Char
<span class="lineno">   19 </span>import Data.List (nub,intercalate,intersect,partition,group,delete)
<span class="lineno">   20 </span>import GHC.Exts (sortWith)
<span class="lineno">   21 </span>--import Debug.Trace
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>fatal :: Int -&gt; String -&gt; a
<span class="lineno">   24 </span><span class="decl"><span class="nottickedoff">fatal = fatalMsg &quot;FSpec.ToFSpec.ADL2Plug&quot;</span></span>
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>-- Not the most ideal place for showPlug, but putting it in Database.Design.Ampersand.FSpec.FSpec creates an import cycle, which will require quite some effort to resolve.
<span class="lineno">   27 </span>showPlug :: PlugSQL -&gt; [String]
<span class="lineno">   28 </span><span class="decl"><span class="nottickedoff">showPlug plug =</span>
<span class="lineno">   29 </span><span class="spaces">  </span><span class="nottickedoff">[ &quot;Table: &quot; ++ (show $ sqlname plug) ++ &quot; (&quot; ++ plugType ++ &quot;)&quot; ] ++</span>
<span class="lineno">   30 </span><span class="spaces">  </span><span class="nottickedoff">indent 4</span>
<span class="lineno">   31 </span><span class="spaces">    </span><span class="nottickedoff">(blockParenthesize &quot;[&quot; &quot;]&quot; &quot;,&quot; $ map showField $ plugFields plug)</span>
<span class="lineno">   32 </span><span class="spaces">  </span><span class="nottickedoff">where plugType = case plug of</span>
<span class="lineno">   33 </span><span class="spaces">          </span><span class="nottickedoff">TblSQL{}    -&gt; &quot;wide&quot;</span>
<span class="lineno">   34 </span><span class="spaces">          </span><span class="nottickedoff">BinSQL{}    -&gt; &quot;binary&quot;</span>
<span class="lineno">   35 </span><span class="spaces">          </span><span class="nottickedoff">ScalarSQL{} -&gt; &quot;scalar&quot;</span>
<span class="lineno">   36 </span><span class="spaces">  </span><span class="nottickedoff"></span>
<span class="lineno">   37 </span><span class="spaces">        </span><span class="nottickedoff">showField :: SqlField -&gt; [String]</span>
<span class="lineno">   38 </span><span class="spaces">        </span><span class="nottickedoff">showField fld = [&quot;{&quot; ++ (if fldnull fld then &quot;+&quot; else &quot;-&quot;) ++ &quot;NUL,&quot; ++ (if flduniq fld then &quot;+&quot; else &quot;-&quot;) ++ &quot;UNQ&quot; ++</span>
<span class="lineno">   39 </span><span class="spaces">                         </span><span class="nottickedoff">(if fld `elem` kernelFields then &quot;, K} &quot; else &quot;}    &quot;) ++</span>
<span class="lineno">   40 </span><span class="spaces">                         </span><span class="nottickedoff">(show $ fldname fld) ++ &quot;: &quot;++showADL (target $ fldexpr fld)]</span>
<span class="lineno">   41 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">   42 </span><span class="spaces">        </span><span class="nottickedoff">kernelFields = case plug of </span>
<span class="lineno">   43 </span><span class="spaces">                         </span><span class="nottickedoff">TblSQL{} -&gt; map snd $ cLkpTbl plug</span>
<span class="lineno">   44 </span><span class="spaces">                         </span><span class="nottickedoff">_        -&gt; []</span></span> -- binaries and scalars do not have kernel fields
<span class="lineno">   45 </span>
<span class="lineno">   46 </span>makeGeneratedSqlPlugs :: Options
<span class="lineno">   47 </span>              -&gt; A_Context
<span class="lineno">   48 </span>              -&gt; [Expression]
<span class="lineno">   49 </span>              -&gt; [Declaration]    -- ^ relations to be saved in generated database plugs.
<span class="lineno">   50 </span>              -&gt; [PlugSQL]
<span class="lineno">   51 </span><span class="decl"><span class="nottickedoff">makeGeneratedSqlPlugs opts context totsurs entityDcls = gTables</span>
<span class="lineno">   52 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">   53 </span><span class="spaces">        </span><span class="nottickedoff">vsqlplugs = [ (makeUserDefinedSqlPlug context p) | p&lt;-ctxsql context] --REMARK -&gt; no optimization like try2specific, because these plugs are user defined</span>
<span class="lineno">   54 </span><span class="spaces">        </span><span class="nottickedoff">gTables = gPlugs ++ gLinkTables</span>
<span class="lineno">   55 </span><span class="spaces">        </span><span class="nottickedoff">gPlugs :: [PlugSQL]</span>
<span class="lineno">   56 </span><span class="spaces">        </span><span class="nottickedoff">gPlugs   = makeEntityTables opts context entityDcls (gens context) (ctxgenconcs context) (relsUsedIn vsqlplugs)</span>
<span class="lineno">   57 </span><span class="spaces">        </span><span class="nottickedoff">-- all plugs for relations not touched by definedplugs and gPlugs</span>
<span class="lineno">   58 </span><span class="spaces">        </span><span class="nottickedoff">gLinkTables :: [PlugSQL]</span>
<span class="lineno">   59 </span><span class="spaces">        </span><span class="nottickedoff">gLinkTables = [ makeLinkTable context dcl totsurs</span>
<span class="lineno">   60 </span><span class="spaces">                      </span><span class="nottickedoff">| dcl&lt;-entityDcls</span>
<span class="lineno">   61 </span><span class="spaces">                      </span><span class="nottickedoff">, Inj `notElem` multiplicities dcl</span>
<span class="lineno">   62 </span><span class="spaces">                      </span><span class="nottickedoff">, Uni `notElem` multiplicities dcl]</span></span>
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>-----------------------------------------
<span class="lineno">   65 </span>--makeLinkTable
<span class="lineno">   66 </span>-----------------------------------------
<span class="lineno">   67 </span>-- makeLinkTable creates associations (BinSQL) between plugs that represent wide tables.
<span class="lineno">   68 </span>-- Typical for BinSQL is that it has exactly two columns that are not unique and may not contain NULL values
<span class="lineno">   69 </span>--
<span class="lineno">   70 </span>-- this concerns relations that are not univalent nor injective, i.e. flduniq=False for both columns
<span class="lineno">   71 </span>-- Univalent relations and injective relations cannot be associations, because they are used as attributes in wide tables.
<span class="lineno">   72 </span>-- REMARK -&gt; imagine a context with only one univalent relation r::A*B.
<span class="lineno">   73 </span>--           Then r can be found in a wide table plug (TblSQL) with a list of two columns [I[A],r],
<span class="lineno">   74 </span>--           and not in a BinSQL with a pair of columns (I/\r;r~, r)
<span class="lineno">   75 </span>--
<span class="lineno">   76 </span>-- a relation r (or r~) is stored in the trgFld of this plug
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>-- | Make a binary sqlplug for a relation that is neither inj nor uni
<span class="lineno">   79 </span>makeLinkTable :: A_Context -&gt; Declaration -&gt; [Expression] -&gt; PlugSQL
<span class="lineno">   80 </span><span class="decl"><span class="nottickedoff">makeLinkTable context dcl totsurs =</span>
<span class="lineno">   81 </span><span class="spaces">  </span><span class="nottickedoff">case dcl of</span>
<span class="lineno">   82 </span><span class="spaces">    </span><span class="nottickedoff">Sgn{}</span>
<span class="lineno">   83 </span><span class="spaces">     </span><span class="nottickedoff">| isInj dcl || isUni dcl</span>
<span class="lineno">   84 </span><span class="spaces">        </span><span class="nottickedoff">-&gt; fatal 55 $ &quot;unexpected call of makeLinkTable(&quot;++show dcl++&quot;), because it is injective or univalent.&quot;</span>
<span class="lineno">   85 </span><span class="spaces">     </span><span class="nottickedoff">| otherwise</span>
<span class="lineno">   86 </span><span class="spaces">        </span><span class="nottickedoff">-&gt; BinSQL</span>
<span class="lineno">   87 </span><span class="spaces">             </span><span class="nottickedoff">{ sqlname = unquote . name $ dcl</span>
<span class="lineno">   88 </span><span class="spaces">             </span><span class="nottickedoff">, columns = ( -- The source field:</span>
<span class="lineno">   89 </span><span class="spaces">                           </span><span class="nottickedoff">Fld { fldname = concat[&quot;Src&quot; | isEndo dcl]++(unquote . name . source) trgExpr</span>
<span class="lineno">   90 </span><span class="spaces">                               </span><span class="nottickedoff">, fldexpr = srcExpr</span>
<span class="lineno">   91 </span><span class="spaces">                               </span><span class="nottickedoff">, fldtype = sqlTypeOf context (target srcExpr)</span>
<span class="lineno">   92 </span><span class="spaces">                               </span><span class="nottickedoff">, flduse  = if suitableAsKey (sqlTypeOf context (target srcExpr))</span>
<span class="lineno">   93 </span><span class="spaces">                                           </span><span class="nottickedoff">then ForeignKey (target srcExpr)</span>
<span class="lineno">   94 </span><span class="spaces">                                           </span><span class="nottickedoff">else PlainAttr</span>
<span class="lineno">   95 </span><span class="spaces">                               </span><span class="nottickedoff">, fldnull = isTot trgExpr</span>
<span class="lineno">   96 </span><span class="spaces">                               </span><span class="nottickedoff">, flduniq = isUni trgExpr</span>
<span class="lineno">   97 </span><span class="spaces">                               </span><span class="nottickedoff">}</span>
<span class="lineno">   98 </span><span class="spaces">                         </span><span class="nottickedoff">, -- The target field:</span>
<span class="lineno">   99 </span><span class="spaces">                           </span><span class="nottickedoff">Fld { fldname = concat[&quot;Tgt&quot; | isEndo dcl]++(unquote . name . target) trgExpr</span>
<span class="lineno">  100 </span><span class="spaces">                               </span><span class="nottickedoff">, fldexpr = trgExpr</span>
<span class="lineno">  101 </span><span class="spaces">                               </span><span class="nottickedoff">, fldtype = sqlTypeOf context (target trgExpr)</span>
<span class="lineno">  102 </span><span class="spaces">                               </span><span class="nottickedoff">, flduse  = if suitableAsKey (sqlTypeOf context (target trgExpr))</span>
<span class="lineno">  103 </span><span class="spaces">                                           </span><span class="nottickedoff">then ForeignKey (target trgExpr)</span>
<span class="lineno">  104 </span><span class="spaces">                                           </span><span class="nottickedoff">else PlainAttr</span>
<span class="lineno">  105 </span><span class="spaces">                               </span><span class="nottickedoff">, fldnull = isSur trgExpr</span>
<span class="lineno">  106 </span><span class="spaces">                               </span><span class="nottickedoff">, flduniq = isInj trgExpr</span>
<span class="lineno">  107 </span><span class="spaces">                               </span><span class="nottickedoff">}</span>
<span class="lineno">  108 </span><span class="spaces">                          </span><span class="nottickedoff">)</span>
<span class="lineno">  109 </span><span class="spaces">             </span><span class="nottickedoff">, cLkpTbl = [] --in case of TOT or SUR you might use a binary plug to lookup a concept (don't forget to nub)</span>
<span class="lineno">  110 </span><span class="spaces">             </span><span class="nottickedoff">, mLkp    = trgExpr</span>
<span class="lineno">  111 </span><span class="spaces">          </span><span class="nottickedoff">--   , sqlfpa  = NO</span>
<span class="lineno">  112 </span><span class="spaces">             </span><span class="nottickedoff">}</span>
<span class="lineno">  113 </span><span class="spaces">    </span><span class="nottickedoff">_  -&gt; fatal 90 &quot;Do not call makeLinkTable on relations other than Sgn{}&quot;</span>
<span class="lineno">  114 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno">  115 </span><span class="spaces">    </span><span class="nottickedoff">r_is_Tot = isTot dcl || dcl `elem` [ d |       EDcD d  &lt;- totsurs]</span>
<span class="lineno">  116 </span><span class="spaces">    </span><span class="nottickedoff">r_is_Sur = isSur dcl || dcl `elem` [ d | EFlp (EDcD d) &lt;- totsurs]</span>
<span class="lineno">  117 </span><span class="spaces">    </span><span class="nottickedoff">--the expr for the source of r</span>
<span class="lineno">  118 </span><span class="spaces">    </span><span class="nottickedoff">srcExpr</span>
<span class="lineno">  119 </span><span class="spaces">     </span><span class="nottickedoff">| r_is_Tot = EDcI (source dcl)</span>
<span class="lineno">  120 </span><span class="spaces">     </span><span class="nottickedoff">| r_is_Sur = EDcI (target dcl)</span>
<span class="lineno">  121 </span><span class="spaces">     </span><span class="nottickedoff">| otherwise = let er=EDcD dcl in EDcI (source dcl) ./\. (er .:. flp er)</span>
<span class="lineno">  122 </span><span class="spaces">    </span><span class="nottickedoff">--the expr for the target of r</span>
<span class="lineno">  123 </span><span class="spaces">    </span><span class="nottickedoff">trgExpr</span>
<span class="lineno">  124 </span><span class="spaces">     </span><span class="nottickedoff">| not r_is_Tot &amp;&amp; r_is_Sur = flp (EDcD dcl)</span>
<span class="lineno">  125 </span><span class="spaces">     </span><span class="nottickedoff">| otherwise                = EDcD dcl</span></span>
<span class="lineno">  126 </span>unquote :: String -&gt; String
<span class="lineno">  127 </span><span class="decl"><span class="nottickedoff">unquote str </span>
<span class="lineno">  128 </span><span class="spaces">  </span><span class="nottickedoff">| length str &lt; 2 = str</span>
<span class="lineno">  129 </span><span class="spaces">  </span><span class="nottickedoff">| head str == '&quot;' &amp;&amp; last str == '&quot;' = reverse . tail . reverse .tail $ str </span>
<span class="lineno">  130 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise = str</span></span>
<span class="lineno">  131 </span>      
<span class="lineno">  132 </span>suitableAsKey :: SqlType -&gt; Bool
<span class="lineno">  133 </span><span class="decl"><span class="nottickedoff">suitableAsKey st =</span>
<span class="lineno">  134 </span><span class="spaces">  </span><span class="nottickedoff">case st of</span>
<span class="lineno">  135 </span><span class="spaces">    </span><span class="nottickedoff">SQLChar{}    -&gt; True</span>
<span class="lineno">  136 </span><span class="spaces">    </span><span class="nottickedoff">SQLBlob      -&gt; False</span>
<span class="lineno">  137 </span><span class="spaces">    </span><span class="nottickedoff">SQLPass      -&gt; False</span>
<span class="lineno">  138 </span><span class="spaces">    </span><span class="nottickedoff">SQLSingle    -&gt; True</span>
<span class="lineno">  139 </span><span class="spaces">    </span><span class="nottickedoff">SQLDouble    -&gt; True</span>
<span class="lineno">  140 </span><span class="spaces">    </span><span class="nottickedoff">SQLText      -&gt; False</span>
<span class="lineno">  141 </span><span class="spaces">    </span><span class="nottickedoff">SQLuInt{}    -&gt; True</span>
<span class="lineno">  142 </span><span class="spaces">    </span><span class="nottickedoff">SQLsInt{}    -&gt; True</span>
<span class="lineno">  143 </span><span class="spaces">    </span><span class="nottickedoff">SQLId{}      -&gt; True</span>
<span class="lineno">  144 </span><span class="spaces">    </span><span class="nottickedoff">SQLVarchar{} -&gt; True</span>
<span class="lineno">  145 </span><span class="spaces">    </span><span class="nottickedoff">SQLBool{}    -&gt; True</span></span>
<span class="lineno">  146 </span>
<span class="lineno">  147 </span>-----------------------------------------
<span class="lineno">  148 </span>--rel2fld
<span class="lineno">  149 </span>-----------------------------------------
<span class="lineno">  150 </span>-- Each relation yields one field f1 in the plug...
<span class="lineno">  151 </span>-- r is the relation from some kernel field k1 to f1
<span class="lineno">  152 </span>-- (fldexpr k1) is the relation from the plug's imaginary ID to k1
<span class="lineno">  153 </span>-- (fldexpr k1);r is the relation from ID to f1
<span class="lineno">  154 </span>-- the rule (fldexpr k1)~;(fldexpr k1);r = r holds because (fldexpr k1) is uni and sur, which means that (fldexpr k1)~;(fldexpr k1) = I
<span class="lineno">  155 </span>-- REMARK -&gt; r may be tot or sur, but not inj. (fldexpr k1) may be tot.
<span class="lineno">  156 </span>--
<span class="lineno">  157 </span>-- fldnull and fldunique are based on the multiplicity of the relation (kernelpath);r from ID to (target r)
<span class="lineno">  158 </span>-- it is given that ID is unique and not null
<span class="lineno">  159 </span>-- fldnull=not(isTot (kernelpath);r)
<span class="lineno">  160 </span>-- flduniq=isInj (kernelpath);r
<span class="lineno">  161 </span>--
<span class="lineno">  162 </span>-- (kernel++plugAtts) defines the name space, making sure that all fields within a plug have unique names.
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>-- | Create field for TblSQL or ScalarSQL plugs
<span class="lineno">  165 </span>rel2fld :: A_Context
<span class="lineno">  166 </span>        -&gt; [Expression] -- ^ all relations (in the form either EDcD r, EDcI or EFlp (EDcD r)) that may be represented as attributes of this entity.
<span class="lineno">  167 </span>        -&gt; [Expression] -- ^ all relations (in the form either EDcD r or EFlp (EDcD r)) that are defined as attributes by the user.
<span class="lineno">  168 </span>        -&gt; Expression   -- ^ either EDcD r, EDcI c or EFlp (EDcD r), representing the relation from some kernel field k1 to f1
<span class="lineno">  169 </span>        -&gt; SqlField
<span class="lineno">  170 </span><span class="decl"><span class="nottickedoff">rel2fld context</span>
<span class="lineno">  171 </span><span class="spaces">        </span><span class="nottickedoff">kernel</span>
<span class="lineno">  172 </span><span class="spaces">        </span><span class="nottickedoff">plugAtts</span>
<span class="lineno">  173 </span><span class="spaces">        </span><span class="nottickedoff">e</span>
<span class="lineno">  174 </span><span class="spaces"> </span><span class="nottickedoff">= Fld { fldname = fldName</span>
<span class="lineno">  175 </span><span class="spaces">       </span><span class="nottickedoff">, fldexpr = e</span>
<span class="lineno">  176 </span><span class="spaces">       </span><span class="nottickedoff">, fldtype = sqlTypeOf context (target e)</span>
<span class="lineno">  177 </span><span class="spaces">       </span><span class="nottickedoff">, flduse  =</span>
<span class="lineno">  178 </span><span class="spaces">          </span><span class="nottickedoff">let f expr =</span>
<span class="lineno">  179 </span><span class="spaces">                 </span><span class="nottickedoff">case expr of</span>
<span class="lineno">  180 </span><span class="spaces">                    </span><span class="nottickedoff">EDcI c   -&gt; if suitableAsKey (sqlTypeOf context c)</span>
<span class="lineno">  181 </span><span class="spaces">                                </span><span class="nottickedoff">then TableKey ((not.maybenull) e) c</span>
<span class="lineno">  182 </span><span class="spaces">                                </span><span class="nottickedoff">else PlainAttr</span>
<span class="lineno">  183 </span><span class="spaces">                    </span><span class="nottickedoff">EDcD _   -&gt; PlainAttr</span>
<span class="lineno">  184 </span><span class="spaces">                    </span><span class="nottickedoff">EFlp e'  -&gt; f e'</span>
<span class="lineno">  185 </span><span class="spaces">                    </span><span class="nottickedoff">_        -&gt; fatal 144 (&quot;No flduse defined for &quot;++show expr)</span>
<span class="lineno">  186 </span><span class="spaces">          </span><span class="nottickedoff">in f e</span>
<span class="lineno">  187 </span><span class="spaces">       </span><span class="nottickedoff">, fldnull = maybenull e</span>
<span class="lineno">  188 </span><span class="spaces">       </span><span class="nottickedoff">, flduniq = isInj e      -- all kernel fldexprs are inj</span>
<span class="lineno">  189 </span><span class="spaces">                                </span><span class="nottickedoff">-- Therefore, a composition of kernel expr (I;kernelpath;e) will also be inj.</span>
<span class="lineno">  190 </span><span class="spaces">                                </span><span class="nottickedoff">-- It is enough to check isInj e</span>
<span class="lineno">  191 </span><span class="spaces">       </span><span class="nottickedoff">}</span>
<span class="lineno">  192 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno">  193 </span><span class="spaces">   </span><span class="nottickedoff">fldName = case [nm | (r',nm)&lt;-table, e==r'] of</span>
<span class="lineno">  194 </span><span class="spaces">               </span><span class="nottickedoff">[]   -&gt; fatal 117 $ &quot;null names in table for e: &quot; ++ show (e,table)</span>
<span class="lineno">  195 </span><span class="spaces">               </span><span class="nottickedoff">n:_  -&gt; n</span>
<span class="lineno">  196 </span><span class="spaces">     </span><span class="nottickedoff">where</span>
<span class="lineno">  197 </span><span class="spaces">       </span><span class="nottickedoff">table :: [(Expression, String)]</span>
<span class="lineno">  198 </span><span class="spaces">       </span><span class="nottickedoff">table   = [ entry</span>
<span class="lineno">  199 </span><span class="spaces">                 </span><span class="nottickedoff">| cl&lt;-eqCl (map toLower.mkColumnName) (kernel++plugAtts)</span>
<span class="lineno">  200 </span><span class="spaces">                 </span><span class="nottickedoff">, entry&lt;-if length cl==1 then [(rel,mkColumnName rel) |rel&lt;-cl] else tbl cl]</span>
<span class="lineno">  201 </span><span class="spaces">       </span><span class="nottickedoff">tbl rs  = [ entry</span>
<span class="lineno">  202 </span><span class="spaces">                 </span><span class="nottickedoff">| cl&lt;-eqCl (map toLower.name.source) rs</span>
<span class="lineno">  203 </span><span class="spaces">                 </span><span class="nottickedoff">, entry&lt;-if length cl==1</span>
<span class="lineno">  204 </span><span class="spaces">                          </span><span class="nottickedoff">then [(rel,mkColumnName rel++&quot;_&quot;++(unquote . name . source) rel) |rel&lt;-cl]</span>
<span class="lineno">  205 </span><span class="spaces">                          </span><span class="nottickedoff">else [(rel,mkColumnName rel++&quot;_&quot;++show i)|(rel,i)&lt;-zip cl [(0::Int)..]]]</span>
<span class="lineno">  206 </span><span class="spaces">       </span><span class="nottickedoff"></span>
<span class="lineno">  207 </span><span class="spaces">       </span><span class="nottickedoff">mkColumnName expr = mkColumnName' False expr</span>
<span class="lineno">  208 </span><span class="spaces">         </span><span class="nottickedoff">where  mkColumnName' isFlipped (EFlp x) = mkColumnName' (not isFlipped) x</span>
<span class="lineno">  209 </span><span class="spaces">                </span><span class="nottickedoff">mkColumnName' isFlipped (EDcD d) = (if isFlipped then &quot;src&quot; else &quot;tgt&quot;)++&quot;_&quot;++(unquote . name) d</span>
<span class="lineno">  210 </span><span class="spaces">                </span><span class="nottickedoff">mkColumnName' _         (EDcI c) = (unquote . name) c</span>
<span class="lineno">  211 </span><span class="spaces">                </span><span class="nottickedoff">mkColumnName' _ rel = fatal 162 ( &quot;Unexpected relation found:\n&quot;++</span>
<span class="lineno">  212 </span><span class="spaces">                                                  </span><span class="nottickedoff">intercalate &quot;\n  &quot;</span>
<span class="lineno">  213 </span><span class="spaces">                                                    </span><span class="nottickedoff">[ &quot;***rel:&quot;</span>
<span class="lineno">  214 </span><span class="spaces">                                                    </span><span class="nottickedoff">, show rel</span>
<span class="lineno">  215 </span><span class="spaces">                                                    </span><span class="nottickedoff">, &quot;***kernel:&quot;</span>
<span class="lineno">  216 </span><span class="spaces">                                                    </span><span class="nottickedoff">, show kernel</span>
<span class="lineno">  217 </span><span class="spaces">                                                    </span><span class="nottickedoff">, &quot;***plugAtts:&quot;</span>
<span class="lineno">  218 </span><span class="spaces">                                                    </span><span class="nottickedoff">, show plugAtts</span>
<span class="lineno">  219 </span><span class="spaces">                                                    </span><span class="nottickedoff">]</span>
<span class="lineno">  220 </span><span class="spaces">                                                </span><span class="nottickedoff">)</span>
<span class="lineno">  221 </span><span class="spaces">   </span><span class="nottickedoff">--in a wide table, m can be total, but the field for its target may contain NULL values,</span>
<span class="lineno">  222 </span><span class="spaces">   </span><span class="nottickedoff">--because (why? ...)</span>
<span class="lineno">  223 </span><span class="spaces">   </span><span class="nottickedoff">--A kernel field may contain NULL values if</span>
<span class="lineno">  224 </span><span class="spaces">   </span><span class="nottickedoff">--  + its field expr is not total OR</span>
<span class="lineno">  225 </span><span class="spaces">   </span><span class="nottickedoff">--  + its field expr is not the identity relation AND the (kernel) field for its source may contain NULL values</span>
<span class="lineno">  226 </span><span class="spaces">   </span><span class="nottickedoff">--(if the fldexpr of a kernel field is the identity,</span>
<span class="lineno">  227 </span><span class="spaces">   </span><span class="nottickedoff">-- then the fldexpr defines the relation between this kernel field and this kernel field (fldnull=not(isTot I) and flduniq=isInj I)</span>
<span class="lineno">  228 </span><span class="spaces">   </span><span class="nottickedoff">-- otherwise it is the relation between this kernel field and some other kernel field)</span>
<span class="lineno">  229 </span><span class="spaces">   </span><span class="nottickedoff">maybenull expr</span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="nottickedoff">| length(map target kernel) &gt; length(nub(map target kernel))</span>
<span class="lineno">  231 </span><span class="spaces">       </span><span class="nottickedoff">= fatal 146 $&quot;more than one kernel field for the same concept:\n    expr = &quot; ++(show expr)++</span>
<span class="lineno">  232 </span><span class="spaces">           </span><span class="nottickedoff">intercalate &quot;\n  *** &quot; ( &quot;&quot; : (map (name.target) kernel))</span>
<span class="lineno">  233 </span><span class="spaces">    </span><span class="nottickedoff">| otherwise = case expr of</span>
<span class="lineno">  234 </span><span class="spaces">                   </span><span class="nottickedoff">EDcD dcl</span>
<span class="lineno">  235 </span><span class="spaces">                        </span><span class="nottickedoff">| (not.isTot) dcl -&gt; True</span>
<span class="lineno">  236 </span><span class="spaces">                        </span><span class="nottickedoff">| otherwise -&gt; (not.null) [()|k&lt;-kernelpaths, target k==source dcl &amp;&amp; isTot k || target k==target dcl &amp;&amp; isSur k ]</span>
<span class="lineno">  237 </span><span class="spaces">                   </span><span class="nottickedoff">EFlp (EDcD dcl)</span>
<span class="lineno">  238 </span><span class="spaces">                        </span><span class="nottickedoff">| (not.isSur) dcl -&gt; True</span>
<span class="lineno">  239 </span><span class="spaces">                        </span><span class="nottickedoff">| otherwise -&gt; (not.null) [()|k&lt;-kernelpaths, target k==source dcl &amp;&amp; isSur k || target k==target dcl &amp;&amp; isTot k]</span>
<span class="lineno">  240 </span><span class="spaces">                   </span><span class="nottickedoff">EDcI _ -&gt; False</span>
<span class="lineno">  241 </span><span class="spaces">                   </span><span class="nottickedoff">_ -&gt; fatal 152 (&quot;Illegal Plug Expression: &quot;++show expr ++&quot;\n&quot;++</span>
<span class="lineno">  242 </span><span class="spaces">                                   </span><span class="nottickedoff">&quot; ***kernel:*** \n   &quot;++</span>
<span class="lineno">  243 </span><span class="spaces">                                   </span><span class="nottickedoff">intercalate &quot;\n   &quot; (map show kernel)++&quot;\n&quot;++</span>
<span class="lineno">  244 </span><span class="spaces">                                   </span><span class="nottickedoff">&quot; ***Attributes:*** \n   &quot;++</span>
<span class="lineno">  245 </span><span class="spaces">                                   </span><span class="nottickedoff">intercalate &quot;\n   &quot; (map show plugAtts)++&quot;\n&quot;++</span>
<span class="lineno">  246 </span><span class="spaces">                                   </span><span class="nottickedoff">&quot; ***e:*** \n   &quot;++</span>
<span class="lineno">  247 </span><span class="spaces">                                   </span><span class="nottickedoff">( show e)</span>
<span class="lineno">  248 </span><span class="spaces">                                  </span><span class="nottickedoff">)</span>
<span class="lineno">  249 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  250 </span><span class="spaces">   </span><span class="nottickedoff">kernelpaths = clos kernel</span>
<span class="lineno">  251 </span><span class="spaces">    </span><span class="nottickedoff">where</span>
<span class="lineno">  252 </span><span class="spaces">     </span><span class="nottickedoff">-- Warshall's transitive closure algorithm, adapted for this purpose:</span>
<span class="lineno">  253 </span><span class="spaces">     </span><span class="nottickedoff">clos :: [Expression] -&gt; [Expression]</span>
<span class="lineno">  254 </span><span class="spaces">     </span><span class="nottickedoff">clos xs</span>
<span class="lineno">  255 </span><span class="spaces">      </span><span class="nottickedoff">= [ foldr1 (.:.) expr | expr&lt;-exprList ]</span>
<span class="lineno">  256 </span><span class="spaces">        </span><span class="nottickedoff">where</span>
<span class="lineno">  257 </span><span class="spaces">         </span><span class="nottickedoff">exprList :: [[Expression]]</span>
<span class="lineno">  258 </span><span class="spaces">      </span><span class="nottickedoff">-- SJ 20131117. The following code (exprList and f) assumes no ISA's in the A-structure. Therefore, this works due to the introduction of EEps.</span>
<span class="lineno">  259 </span><span class="spaces">         </span><span class="nottickedoff">exprList = foldl f [[x] | x&lt;-nub xs]</span>
<span class="lineno">  260 </span><span class="spaces">                          </span><span class="nottickedoff">(nub [c | c&lt;-nub (map source xs), c'&lt;-nub (map target xs), c==c'])</span>
<span class="lineno">  261 </span><span class="spaces">         </span><span class="nottickedoff">f :: [[Expression]] -&gt; A_Concept -&gt; [[Expression]]</span>
<span class="lineno">  262 </span><span class="spaces">         </span><span class="nottickedoff">f q x = q ++ [ls ++ rs | ls &lt;- q, x == target (last ls)</span>
<span class="lineno">  263 </span><span class="spaces">                                </span><span class="nottickedoff">, rs &lt;- q, x == source (head rs), null (ls `isc` rs)]</span></span>
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>-- ^ Explanation:  rel is a relation from some kernel field k to f
<span class="lineno">  266 </span>-- ^ (fldexpr k) is the relation from the plug's ID to k
<span class="lineno">  267 </span>-- ^ (fldexpr k);rel is the relation from ID to f
<span class="lineno">  268 </span>
<span class="lineno">  269 </span>-----------------------------------------
<span class="lineno">  270 </span>--makeEntityTables  (formerly called: makeTblPlugs)
<span class="lineno">  271 </span>-----------------------------------------
<span class="lineno">  272 </span>{- makeEntityTables computes a set of plugs to obtain tables in a transactional database with minimal redundancy.
<span class="lineno">  273 </span>   We call them &quot;wide tables&quot;.
<span class="lineno">  274 </span>   makeEntityTables computes entities with their attributes.
<span class="lineno">  275 </span>   It is based on the principle that each concept is represented in at most one plug,
<span class="lineno">  276 </span>   and each relation in at most one plug.
<span class="lineno">  277 </span>   First, we determine the kernels for all plugs.
<span class="lineno">  278 </span>   A kernel contains the concept table(s) for all concepts that are administered in the same entity.
<span class="lineno">  279 </span>   For that, we collect all relations that are univalent, injective, and surjective (the kernel relations).
<span class="lineno">  280 </span>      By the way, that includes all isa-relations, since they are univalent, injective, and surjective by definition.
<span class="lineno">  281 </span>      Since isa-relations are not declared explicitly, they are generated separately.
<span class="lineno">  282 </span>   If two concepts a and b are in the same entity, there is a concept g such that a isa g and b isa g.
<span class="lineno">  283 </span>   Of all concepts in an entity, one most generic concept is designated as root, and is positioned in the first column of the table.
<span class="lineno">  284 </span>   Secondly, we take all univalent relations that are not in the kernel, but depart from this kernel.
<span class="lineno">  285 </span>   These relations serve as attributes. Code:  [a| a&lt;-attRels, source a `elem` concs kernel]
<span class="lineno">  286 </span>   Then, all these relations are made into fields. Code: plugFields = [rel2fld plugMors a| a&lt;-plugMors]
<span class="lineno">  287 </span>   We also define two lookup tables, one for the concepts that are stored in the kernel, and one for the attributes of these concepts.
<span class="lineno">  288 </span>   For the fun of it, we sort the plugs on length, the longest first. Code:   sortWith ((0-).length.fields)
<span class="lineno">  289 </span>   By the way, parameter allRels contains all relations that are declared in context, enriched with extra multiplicities.
<span class="lineno">  290 </span>   This parameter allRels was added to makePlugs to avoid recomputation of the extra multiplicities.
<span class="lineno">  291 </span>   The parameter exclusions was added in order to exclude certain concepts and relations from the process.
<span class="lineno">  292 </span>-}
<span class="lineno">  293 </span>-- | Generate non-binary sqlplugs for relations that are at least inj or uni, but not already in some user defined sqlplug
<span class="lineno">  294 </span>makeEntityTables :: Options
<span class="lineno">  295 </span>                -&gt; A_Context
<span class="lineno">  296 </span>                -&gt; [Declaration] -- ^ all relations in scope
<span class="lineno">  297 </span>                -&gt; [A_Gen]
<span class="lineno">  298 </span>                -&gt; [[A_Concept]] -- ^ concepts `belonging' together.
<span class="lineno">  299 </span>                                 --   for each class&lt;-conceptss: c,c'&lt;-class:   c `join` c' exists (although there is not necessarily a concept d=c `join` c'    ...)
<span class="lineno">  300 </span>                -&gt; [Declaration] -- ^ relations that should be excluded, because they wil not be implemented using generated sql plugs.
<span class="lineno">  301 </span>                -&gt; [PlugSQL]
<span class="lineno">  302 </span><span class="decl"><span class="nottickedoff">makeEntityTables opts context allDcls isas conceptss exclusions</span>
<span class="lineno">  303 </span><span class="spaces"> </span><span class="nottickedoff">= sortWith ((0-).length.plugFields)</span>
<span class="lineno">  304 </span><span class="spaces">    </span><span class="nottickedoff">(map kernel2Plug kernelsWithAttributes)</span>
<span class="lineno">  305 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno">  306 </span><span class="spaces">    </span><span class="nottickedoff">diagnostics</span>
<span class="lineno">  307 </span><span class="spaces">      </span><span class="nottickedoff">= &quot;\nallDcls:&quot; ++     concat [&quot;\n  &quot;++showHSName r           | r&lt;-allDcls]++</span>
<span class="lineno">  308 </span><span class="spaces">        </span><span class="nottickedoff">&quot;\nallDcls:&quot; ++     concat [&quot;\n  &quot;++showHS opts &quot;\n  &quot; r  | r&lt;-allDcls]++</span>
<span class="lineno">  309 </span><span class="spaces">        </span><span class="nottickedoff">&quot;\nconceptss:&quot; ++   concat [&quot;\n  &quot;++showHS opts &quot;    &quot; cs | cs&lt;-conceptss]++</span>
<span class="lineno">  310 </span><span class="spaces">        </span><span class="nottickedoff">&quot;\nexclusions:&quot; ++  concat [&quot;\n  &quot;++showHSName r           | r&lt;-exclusions]++</span>
<span class="lineno">  311 </span><span class="spaces">        </span><span class="nottickedoff">&quot;\nattRels:&quot; ++     concat [&quot;\n  &quot;++showHS opts &quot;    &quot; e  | e&lt;-attRels]++</span>
<span class="lineno">  312 </span><span class="spaces">        </span><span class="nottickedoff">&quot;\n&quot;</span>
<span class="lineno">  313 </span><span class="spaces">    </span><span class="nottickedoff">-- | kernels are computed, starting with the set of concepts, on the basis of generalization tuples.</span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="nottickedoff">kernPartition :: [A_Gen] -&gt; [[A_Concept]] -- ^ This function contains the recipe to derive a set of kernels from a set of isa-pairs.</span>
<span class="lineno">  315 </span><span class="spaces">    </span><span class="nottickedoff">kernPartition specialzs</span>
<span class="lineno">  316 </span><span class="spaces">     </span><span class="nottickedoff">= foldl f (group (delete ONE (concs context))) specialzs</span>
<span class="lineno">  317 </span><span class="spaces">       </span><span class="nottickedoff">where f disjuncLists g = concat haves : nohaves</span>
<span class="lineno">  318 </span><span class="spaces">               </span><span class="nottickedoff">where</span>
<span class="lineno">  319 </span><span class="spaces">                 </span><span class="nottickedoff">(haves,nohaves) = partition (not.null.intersect (concs g)) disjuncLists</span>
<span class="lineno">  320 </span><span class="spaces">    </span><span class="nottickedoff">preKernels = kernPartition (gens context) -- Step 1: compute the kernels from the isa-pairs from the context</span>
<span class="lineno">  321 </span><span class="spaces">    </span><span class="nottickedoff">extraIsas  -- Step 2: Maybe extra isa-pairs are needed to ensure that each kernel has precisely one largest concept</span>
<span class="lineno">  322 </span><span class="spaces">       </span><span class="nottickedoff">= concat</span>
<span class="lineno">  323 </span><span class="spaces">         </span><span class="nottickedoff">[ case [c | c&lt;-kernel, null (largerConcepts isas c)] of -- determine how many concepts in one kernel are largest</span>
<span class="lineno">  324 </span><span class="spaces">             </span><span class="nottickedoff">[_] -&gt; []</span>
<span class="lineno">  325 </span><span class="spaces">             </span><span class="nottickedoff">rs  -&gt; [ Isa{gengen=rootConcept, genspc=c} | c&lt;-rs ]</span>
<span class="lineno">  326 </span><span class="spaces">         </span><span class="nottickedoff">| (rootConcept,kernel) &lt;- zip [rc | i&lt;-[0::Int ..]</span>
<span class="lineno">  327 </span><span class="spaces">                                           </span><span class="nottickedoff">, let rc=PlainConcept { cptnm = &quot;rootConcept&quot;++show i</span>
<span class="lineno">  328 </span><span class="spaces">                                                                 </span><span class="nottickedoff">}</span>
<span class="lineno">  329 </span><span class="spaces">                                           </span><span class="nottickedoff">, rc `notElem` concs context ]</span>
<span class="lineno">  330 </span><span class="spaces">                                       </span><span class="nottickedoff">preKernels</span>
<span class="lineno">  331 </span><span class="spaces">         </span><span class="nottickedoff">]</span>
<span class="lineno">  332 </span><span class="spaces">    </span><span class="nottickedoff">kernls     -- Step 3: compute the kernels</span>
<span class="lineno">  333 </span><span class="spaces">     </span><span class="nottickedoff">= [ largerCs++[ c | c&lt;-kernel, c `notElem` largerCs ]              -- put the largest element up front</span>
<span class="lineno">  334 </span><span class="spaces">       </span><span class="nottickedoff">| kernel &lt;- kernPartition (extraIsas++gens context)                -- recompute the kernels with the extra isa-pairs.</span>
<span class="lineno">  335 </span><span class="spaces">       </span><span class="nottickedoff">, let largerCs = [c | c&lt;-kernel, null (largerConcepts isas c)]   -- get the set of largest concepts (each kernel has precisely one)</span>
<span class="lineno">  336 </span><span class="spaces">       </span><span class="nottickedoff">]</span>
<span class="lineno">  337 </span><span class="spaces">    </span><span class="nottickedoff">kernelsWithAttributes = dist attRels kernls []</span>
<span class="lineno">  338 </span><span class="spaces">      </span><span class="nottickedoff">where</span>
<span class="lineno">  339 </span><span class="spaces">        </span><span class="nottickedoff">dist :: (Association attrib, Show attrib) =&gt; [attrib] -&gt; [[A_Concept]] -&gt; [([A_Concept], [attrib])] -&gt; [([A_Concept], [attrib])]</span>
<span class="lineno">  340 </span><span class="spaces">        </span><span class="nottickedoff">dist []   []     result = result</span>
<span class="lineno">  341 </span><span class="spaces">        </span><span class="nottickedoff">dist atts []     _      = fatal 246 (&quot;No kernel found for atts: &quot;++show atts++&quot;\n&quot;++diagnostics)</span>
<span class="lineno">  342 </span><span class="spaces">        </span><span class="nottickedoff">dist atts (kernel:ks) result = dist otherAtts ks ([(kernel,attsOfK)] ++ result)</span>
<span class="lineno">  343 </span><span class="spaces">           </span><span class="nottickedoff">where (attsOfK,otherAtts) = partition belongsInK atts</span>
<span class="lineno">  344 </span><span class="spaces">                 </span><span class="nottickedoff">belongsInK att = source att `elem` kernel</span>
<span class="lineno">  345 </span><span class="spaces">    </span><span class="nottickedoff">-- | converts a kernel into a plug</span>
<span class="lineno">  346 </span><span class="spaces">    </span><span class="nottickedoff">kernel2Plug :: ([A_Concept],[Expression]) -&gt; PlugSQL</span>
<span class="lineno">  347 </span><span class="spaces">    </span><span class="nottickedoff">kernel2Plug (kernel, attsAndIsaRels)</span>
<span class="lineno">  348 </span><span class="spaces">     </span><span class="nottickedoff">=  TblSQL</span>
<span class="lineno">  349 </span><span class="spaces">             </span><span class="nottickedoff">{ sqlname = unquote . name . head $ kernel -- ++ &quot; !!Let op: De ISA relaties zie ik hier nergens terug!! (TODO. HJO 20131201&quot;</span>
<span class="lineno">  350 </span><span class="spaces">             </span><span class="nottickedoff">, fields  = map fld plugMors      -- Each field comes from a relation.</span>
<span class="lineno">  351 </span><span class="spaces">             </span><span class="nottickedoff">, cLkpTbl = conceptLookuptable</span>
<span class="lineno">  352 </span><span class="spaces">             </span><span class="nottickedoff">, mLkpTbl = attributeLookuptable ++ isaLookuptable</span>
<span class="lineno">  353 </span><span class="spaces">             </span><span class="nottickedoff">}</span>
<span class="lineno">  354 </span><span class="spaces">        </span><span class="nottickedoff">where</span>
<span class="lineno">  355 </span><span class="spaces">          </span><span class="nottickedoff">(isaAtts,atts) = partition isISA attsAndIsaRels</span>
<span class="lineno">  356 </span><span class="spaces">            </span><span class="nottickedoff">where isISA (EDcI _) = True</span>
<span class="lineno">  357 </span><span class="spaces">                  </span><span class="nottickedoff">isISA _        = False</span>
<span class="lineno">  358 </span><span class="spaces">          </span><span class="nottickedoff">mainkernel = map EDcI kernel</span>
<span class="lineno">  359 </span><span class="spaces">          </span><span class="nottickedoff">plugMors :: [Expression]</span>
<span class="lineno">  360 </span><span class="spaces">          </span><span class="nottickedoff">plugMors = mainkernel++atts</span>
<span class="lineno">  361 </span><span class="spaces">          </span><span class="nottickedoff">conceptLookuptable :: [(A_Concept,SqlField)]</span>
<span class="lineno">  362 </span><span class="spaces">          </span><span class="nottickedoff">conceptLookuptable    = [(target r,fld r) | r &lt;-mainkernel]</span>
<span class="lineno">  363 </span><span class="spaces">          </span><span class="nottickedoff">attributeLookuptable :: [(Expression,SqlField,SqlField)]</span>
<span class="lineno">  364 </span><span class="spaces">          </span><span class="nottickedoff">attributeLookuptable  = -- kernel attributes are always surjective from left to right. So do not flip the lookup table!</span>
<span class="lineno">  365 </span><span class="spaces">                                  </span><span class="nottickedoff">[(e,lookupC (source e),fld e) | e &lt;-plugMors]</span>
<span class="lineno">  366 </span><span class="spaces">          </span><span class="nottickedoff">lookupC cpt           = head [f |(c',f)&lt;-conceptLookuptable, cpt==c']</span>
<span class="lineno">  367 </span><span class="spaces">          </span><span class="nottickedoff">fld a                 = rel2fld context mainkernel atts a</span>
<span class="lineno">  368 </span><span class="spaces">          </span><span class="nottickedoff">isaLookuptable = [(e,lookupC (source e),lookupC (target e)) | e &lt;- isaAtts ]</span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="nottickedoff">-- attRels contains all relations that will be attribute of a kernel.</span>
<span class="lineno">  370 </span><span class="spaces">    </span><span class="nottickedoff">-- The type is the largest possible type, which is the declared type, because that contains all atoms (also the atoms of subtypes) needed in the operation.</span>
<span class="lineno">  371 </span><span class="spaces">    </span><span class="nottickedoff">attRels :: [Expression]</span>
<span class="lineno">  372 </span><span class="spaces">    </span><span class="nottickedoff">attRels = mapMaybe attExprOf (allDcls&gt;- exclusions)</span>
<span class="lineno">  373 </span><span class="spaces">     </span><span class="nottickedoff">where</span>
<span class="lineno">  374 </span><span class="spaces">       </span><span class="nottickedoff">attExprOf :: Declaration -&gt; Maybe Expression</span>
<span class="lineno">  375 </span><span class="spaces">       </span><span class="nottickedoff">attExprOf d =</span>
<span class="lineno">  376 </span><span class="spaces">        </span><span class="nottickedoff">case d of  --make explicit what happens with each possible decl...</span>
<span class="lineno">  377 </span><span class="spaces">          </span><span class="nottickedoff">Isn{} -&gt; Nothing -- These relations are already in the kernel</span>
<span class="lineno">  378 </span><span class="spaces">          </span><span class="nottickedoff">Vs{}  -&gt; Nothing -- Vs are not implemented at all</span>
<span class="lineno">  379 </span><span class="spaces">          </span><span class="nottickedoff">Sgn{} -&gt;</span>
<span class="lineno">  380 </span><span class="spaces">               </span><span class="nottickedoff">case (isInj d, isUni d, isTot d, isSur d) of</span>
<span class="lineno">  381 </span><span class="spaces">                    </span><span class="nottickedoff">(False  , False  , _      , _      ) --Will become a link-table</span>
<span class="lineno">  382 </span><span class="spaces">                        </span><span class="nottickedoff">-&gt; Nothing</span>
<span class="lineno">  383 </span><span class="spaces">                    </span><span class="nottickedoff">(True   , False  , _      , _      )</span>
<span class="lineno">  384 </span><span class="spaces">                        </span><span class="nottickedoff">-&gt; Just $ flp (EDcD d)</span>
<span class="lineno">  385 </span><span class="spaces">                    </span><span class="nottickedoff">(True   , True   , True   , False  ) --Equivalent to CLASSIFY s ISA t, however, it is named, so it must be stored in a plug!</span>
<span class="lineno">  386 </span><span class="spaces">                        </span><span class="nottickedoff">-&gt; Just $ flp (EDcD d)</span>
<span class="lineno">  387 </span><span class="spaces">                    </span><span class="nottickedoff">_   -&gt; Just $      EDcD d</span></span>
<span class="lineno">  388 </span>
<span class="lineno">  389 </span>-----------------------------------------
<span class="lineno">  390 </span>--makeUserDefinedSqlPlug
<span class="lineno">  391 </span>-----------------------------------------
<span class="lineno">  392 </span>--makeUserDefinedSqlPlug is used to make user defined plugs. One advantage is that the field names and types can be controlled by the user.
<span class="lineno">  393 </span>--
<span class="lineno">  394 </span>--TODO151210 -&gt; (see also Instance Object PlugSQL)
<span class="lineno">  395 </span>--              cLkpTbl TblSQL{} can have more than one concept i.e. one for each kernel field
<span class="lineno">  396 </span>--              a kernel may have more than one concept that is uni,tot,inj,sur with some imaginary ID of the plug (i.e. fldnull=False)
<span class="lineno">  397 </span>--              When is an ObjectDef a ScalarPlug or BinPlug?
<span class="lineno">  398 </span>--              When do you want to define your own Scalar or BinPlug
<span class="lineno">  399 </span>--rel2fld  (identities context) kernel plugAtts r
<span class="lineno">  400 </span>
<span class="lineno">  401 </span>-- | Make a sqlplug from an ObjectDef (user-defined sql plug)
<span class="lineno">  402 </span>makeUserDefinedSqlPlug :: A_Context -&gt; ObjectDef -&gt; PlugSQL
<span class="lineno">  403 </span><span class="decl"><span class="nottickedoff">makeUserDefinedSqlPlug context obj</span>
<span class="lineno">  404 </span><span class="spaces"> </span><span class="nottickedoff">| null(attributes obj) &amp;&amp; isIdent(objctx obj)</span>
<span class="lineno">  405 </span><span class="spaces">    </span><span class="nottickedoff">= ScalarSQL { sqlname   = unquote . name $ obj</span>
<span class="lineno">  406 </span><span class="spaces">                </span><span class="nottickedoff">, sqlColumn = rel2fld context [EDcI c] [] (EDcI c)</span>
<span class="lineno">  407 </span><span class="spaces">                </span><span class="nottickedoff">, cLkp      = c</span>
<span class="lineno">  408 </span><span class="spaces">                </span><span class="nottickedoff">}</span>
<span class="lineno">  409 </span><span class="spaces"> </span><span class="nottickedoff">| null(attributes obj) --TODO151210 -&gt; assuming objctx obj is Rel{} if it is not I{}</span>
<span class="lineno">  410 </span><span class="spaces">   </span><span class="nottickedoff">= fatal 2372 &quot;TODO151210 -&gt; implement defining binary plugs in ASCII&quot;</span>
<span class="lineno">  411 </span><span class="spaces"> </span><span class="nottickedoff">| isIdent(objctx obj) --TODO151210 -&gt; a kernel may have more than one concept that is uni,tot,inj,sur with some imaginary ID of the plug</span>
<span class="lineno">  412 </span><span class="spaces">   </span><span class="nottickedoff">= {- The following may be useful for debugging:</span>
<span class="lineno">  413 </span><span class="spaces">     </span><span class="nottickedoff">error</span>
<span class="lineno">  414 </span><span class="spaces">      </span><span class="nottickedoff">(&quot;\nc: &quot;++show c++</span>
<span class="lineno">  415 </span><span class="spaces">       </span><span class="nottickedoff">&quot;\nrels:&quot;++concat [&quot;\n  &quot;++show r | r&lt;-rels]++</span>
<span class="lineno">  416 </span><span class="spaces">       </span><span class="nottickedoff">&quot;\nkernel:&quot;++concat [&quot;\n  &quot;++show r | r&lt;-kernel]++</span>
<span class="lineno">  417 </span><span class="spaces">       </span><span class="nottickedoff">&quot;\nattRels:&quot;++concat [&quot;\n  &quot;++show e | e&lt;-attRels]++</span>
<span class="lineno">  418 </span><span class="spaces">       </span><span class="nottickedoff">&quot;\nplugfields:&quot;++concat [&quot;\n  &quot;++show plugField | plugField&lt;-plugfields]</span>
<span class="lineno">  419 </span><span class="spaces">      </span><span class="nottickedoff">) -}</span>
<span class="lineno">  420 </span><span class="spaces">     </span><span class="nottickedoff">TblSQL { sqlname = unquote . name $ obj</span>
<span class="lineno">  421 </span><span class="spaces">            </span><span class="nottickedoff">, fields  = plugfields</span>
<span class="lineno">  422 </span><span class="spaces">            </span><span class="nottickedoff">, cLkpTbl = conceptLookuptable</span>
<span class="lineno">  423 </span><span class="spaces">            </span><span class="nottickedoff">, mLkpTbl = attributeLookuptable</span>
<span class="lineno">  424 </span><span class="spaces">            </span><span class="nottickedoff">}</span>
<span class="lineno">  425 </span><span class="spaces"> </span><span class="nottickedoff">| otherwise = fatal 279 &quot;Implementation expects one concept for plug object (SQLPLUG tblX: I[Concept]).&quot;</span>
<span class="lineno">  426 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  427 </span><span class="spaces">   </span><span class="nottickedoff">c   -- one concept from the kernel is designated to &quot;lead&quot; this plug, this is user-defined.</span>
<span class="lineno">  428 </span><span class="spaces">     </span><span class="nottickedoff">= source(objctx obj)</span>
<span class="lineno">  429 </span><span class="spaces">   </span><span class="nottickedoff">rels --fields are user-defined as one deep objats with objctx=r. note: type incorrect or non-relation objats are ignored</span>
<span class="lineno">  430 </span><span class="spaces">     </span><span class="nottickedoff">= [(objctx att,sqltp att) | att&lt;-attributes obj, source (objctx att)==c]</span>
<span class="lineno">  431 </span><span class="spaces">   </span><span class="nottickedoff">kernel --I[c] and every non-endo r or r~ which is at least uni,inj,sur are kernel fields</span>
<span class="lineno">  432 </span><span class="spaces">          </span><span class="nottickedoff">--REMARK -&gt; endo r or r~ which are at least uni,inj,sur are inefficient in a way</span>
<span class="lineno">  433 </span><span class="spaces">          </span><span class="nottickedoff">--          if also TOT than r=I =&gt; duplicates,</span>
<span class="lineno">  434 </span><span class="spaces">          </span><span class="nottickedoff">--          otherwise if r would be implemented as GEN (target r) ISA C then (target r) could become a kernel field</span>
<span class="lineno">  435 </span><span class="spaces">     </span><span class="nottickedoff">= [(EDcI c,sqltp obj)]</span>
<span class="lineno">  436 </span><span class="spaces">       </span><span class="nottickedoff">++ [(r,tp) |(r,tp)&lt;-rels,not (isEndo r),isUni r, isInj r, isSur r]</span>
<span class="lineno">  437 </span><span class="spaces">       </span><span class="nottickedoff">++ [(r,tp) |(r,tp)&lt;-rels,not (isEndo r),isUni r, isInj r, isTot r, not (isSur r)]</span>
<span class="lineno">  438 </span><span class="spaces">   </span><span class="nottickedoff">attRels --all user-defined non-kernel fields are attributes of (rel2fld context (objctx c))</span>
<span class="lineno">  439 </span><span class="spaces">     </span><span class="nottickedoff">= (rels &gt;- kernel) &gt;- [(flp r,tp) |(r,tp)&lt;-kernel] --note: r&lt;-rels where r=objctx obj are ignored (objctx obj=I)</span>
<span class="lineno">  440 </span><span class="spaces">   </span><span class="nottickedoff">plugMors              = kernel++attRels</span>
<span class="lineno">  441 </span><span class="spaces">   </span><span class="nottickedoff">plugfields            = [fld r tp | (r,tp)&lt;-plugMors]</span>
<span class="lineno">  442 </span><span class="spaces">   </span><span class="nottickedoff">fld r tp              = (rel2fld context (map fst kernel) (map fst attRels) r){fldtype=tp}  --redefine sqltype</span>
<span class="lineno">  443 </span><span class="spaces">   </span><span class="nottickedoff">conceptLookuptable    = [(target e,fld e tp) |(e,tp)&lt;-kernel]</span>
<span class="lineno">  444 </span><span class="spaces">   </span><span class="nottickedoff">attributeLookuptable  = [(er,lookupC (source er),fld er tp) | (er,tp)&lt;-plugMors]</span>
<span class="lineno">  445 </span><span class="spaces">   </span><span class="nottickedoff">lookupC cpt           = head [f |(c',f)&lt;-conceptLookuptable, cpt==c']</span>
<span class="lineno">  446 </span><span class="spaces">   </span><span class="nottickedoff">sqltp :: ObjectDef -&gt; SqlType</span>
<span class="lineno">  447 </span><span class="spaces">   </span><span class="nottickedoff">sqltp att = head $ [sqlTypeOf' sqltp' | strs&lt;-objstrs att,('S':'Q':'L':'T':'Y':'P':'E':'=':sqltp')&lt;-strs]</span>
<span class="lineno">  448 </span><span class="spaces">                      </span><span class="nottickedoff">++[SQLVarchar 255]</span></span>
<span class="lineno">  449 </span>
<span class="lineno">  450 </span>sqlTypeOf :: A_Context -&gt; A_Concept -&gt; SqlType
<span class="lineno">  451 </span><span class="decl"><span class="nottickedoff">sqlTypeOf _ ONE = SQLBool -- TODO (SJ):  Martijn, why should ONE have a representation? Or should this rather be a fatal?</span>
<span class="lineno">  452 </span><span class="spaces"></span><span class="nottickedoff">sqlTypeOf context c</span>
<span class="lineno">  453 </span><span class="spaces">    </span><span class="nottickedoff">= case nub [ cdtyp cdef | cdef&lt;-ctxcds context, name c==name cdef ] of</span>
<span class="lineno">  454 </span><span class="spaces">       </span><span class="nottickedoff">[str] -&gt; sqlTypeOf' str</span>
<span class="lineno">  455 </span><span class="spaces">       </span><span class="nottickedoff">[]    -&gt; sqlTypeOf' &quot;&quot;</span>
<span class="lineno">  456 </span><span class="spaces">       </span><span class="nottickedoff">_     -&gt; fatal 396 (&quot;Multiple SQL types defined for concept &quot;++name c)</span></span>
<span class="lineno">  457 </span>
<span class="lineno">  458 </span>sqlTypeOf' :: String -&gt; SqlType
<span class="lineno">  459 </span><span class="decl"><span class="nottickedoff">sqlTypeOf' str = case str of</span>
<span class="lineno">  460 </span><span class="spaces">       </span><span class="nottickedoff">('V':'a':'r':'c':'h':'a':'r':_) -&gt; SQLVarchar 255 --TODO number</span>
<span class="lineno">  461 </span><span class="spaces">       </span><span class="nottickedoff">&quot;Pass&quot; -&gt; SQLPass</span>
<span class="lineno">  462 </span><span class="spaces">       </span><span class="nottickedoff">('C':'h':'a':'r':_) -&gt; SQLChar 255 --TODO number</span>
<span class="lineno">  463 </span><span class="spaces">       </span><span class="nottickedoff">&quot;Blob&quot; -&gt; SQLBlob</span>
<span class="lineno">  464 </span><span class="spaces">       </span><span class="nottickedoff">&quot;Text&quot; -&gt; SQLText</span>
<span class="lineno">  465 </span><span class="spaces">       </span><span class="nottickedoff">&quot;Single&quot; -&gt; SQLSingle</span>
<span class="lineno">  466 </span><span class="spaces">       </span><span class="nottickedoff">&quot;Double&quot; -&gt; SQLDouble</span>
<span class="lineno">  467 </span><span class="spaces">       </span><span class="nottickedoff">('u':'I':'n':'t':_) -&gt; SQLuInt 4 --TODO number</span>
<span class="lineno">  468 </span><span class="spaces">       </span><span class="nottickedoff">('s':'I':'n':'t':_) -&gt; SQLsInt 4 --TODO number</span>
<span class="lineno">  469 </span><span class="spaces">       </span><span class="nottickedoff">&quot;Id&quot; -&gt; SQLId</span>
<span class="lineno">  470 </span><span class="spaces">       </span><span class="nottickedoff">('B':'o':'o':'l':_) -&gt; SQLBool</span>
<span class="lineno">  471 </span><span class="spaces">       </span><span class="nottickedoff">&quot;&quot; -&gt; SQLVarchar 255</span>
<span class="lineno">  472 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; fatal 335 (&quot;Unknown type: &quot;++str)</span></span>

</pre>
</body>
</html>
