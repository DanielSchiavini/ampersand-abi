<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=CP850">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="lineno">    1 </span>module Database.Design.Ampersand.FSpec.SQL
<span class="lineno">    2 </span>  ( prettySQLQuery)
<span class="lineno">    3 </span>  
<span class="lineno">    4 </span>where
<span class="lineno">    5 </span>import Language.SQL.SimpleSQL.Syntax
<span class="lineno">    6 </span>import Language.SQL.SimpleSQL.Pretty
<span class="lineno">    7 </span>import Database.Design.Ampersand.Basics
<span class="lineno">    8 </span>import Database.Design.Ampersand.Classes.ConceptStructure
<span class="lineno">    9 </span>import Database.Design.Ampersand.Core.AbstractSyntaxTree
<span class="lineno">   10 </span>import Database.Design.Ampersand.ADL1.Expression
<span class="lineno">   11 </span>import Database.Design.Ampersand.FSpec.FSpec
<span class="lineno">   12 </span>import Database.Design.Ampersand.FSpec.FSpecAux
<span class="lineno">   13 </span>import Database.Design.Ampersand.FSpec.ShowADL
<span class="lineno">   14 </span>import Database.Design.Ampersand.Misc
<span class="lineno">   15 </span>import Data.List
<span class="lineno">   16 </span>import Data.Maybe
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>fatal :: Int -&gt; String -&gt; a
<span class="lineno">   19 </span><span class="decl"><span class="nottickedoff">fatal = fatalMsg &quot;FSpec.SQL&quot;</span></span>
<span class="lineno">   20 </span>
<span class="lineno">   21 </span>
<span class="lineno">   22 </span>class SQLAble a where
<span class="lineno">   23 </span>  -- | prettyprint and indent it with spaces
<span class="lineno">   24 </span>  prettySQLQuery :: FSpec -&gt; Int -&gt; a -&gt; String
<span class="lineno">   25 </span>  makeANice :: (a -&gt; BinQueryExpr) -&gt; Int -&gt; a -&gt; String
<span class="lineno">   26 </span>  <span class="decl"><span class="nottickedoff">makeANice f i =</span>
<span class="lineno">   27 </span><span class="spaces">    </span><span class="nottickedoff">intercalate (&quot;\n&quot;++replicate i ' ') .  lines . </span>
<span class="lineno">   28 </span><span class="spaces">       </span><span class="nottickedoff">prettyQueryExpr theDialect . toSQL . f</span></span>   
<span class="lineno">   29 </span>    
<span class="lineno">   30 </span>instance SQLAble Expression where  
<span class="lineno">   31 </span>  <span class="decl"><span class="nottickedoff">prettySQLQuery = makeANice . selectExpr</span></span> 
<span class="lineno">   32 </span>instance SQLAble Declaration where
<span class="lineno">   33 </span>  <span class="decl"><span class="nottickedoff">prettySQLQuery = makeANice . selectDeclaration</span></span>
<span class="lineno">   34 </span>  
<span class="lineno">   35 </span>     
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>sourceAlias, targetAlias :: Name
<span class="lineno">   38 </span><span class="decl"><span class="nottickedoff">sourceAlias = (Name &quot;src&quot;)</span></span> 
<span class="lineno">   39 </span><span class="decl"><span class="nottickedoff">targetAlias = (Name &quot;tgt&quot;)</span></span>
<span class="lineno">   40 </span>selectExpr :: FSpec    -- current context
<span class="lineno">   41 </span>        -&gt; Expression  -- expression to be translated
<span class="lineno">   42 </span>        -&gt; BinQueryExpr   -- resulting info for the binary SQL expression
<span class="lineno">   43 </span>-- In order to translate all Expressions, code generators have been written for EUni ( \/ ), EIsc ( /\ ), EFlp ( ~ ), ECpl (unary - ), and ECps ( ; ),
<span class="lineno">   44 </span>-- each of which is supposed to generate correct code in 100% of the cases. (TODO: how do we establish that properly?)
<span class="lineno">   45 </span>-- The other operators, EEqu ( = ), EImp ( |- ), ERad ( ! ), EPrd ( * ), ELrs ( / ), ERrs ( \ ), and EDia ( &lt;&gt; ), have been implemented in terms of the previous ones,
<span class="lineno">   46 </span>-- in order to prevent mistakes in the code generator. It is possible that more efficient code may be generated in these cases.
<span class="lineno">   47 </span>-- Special cases are treated up front, so they will overrule the more general cases.
<span class="lineno">   48 </span>-- That allows more efficient code while retaining correctness and completeness as much as possible.
<span class="lineno">   49 </span>-- Code for the Kleene operators EKl0 ( * ) and EKl1 ( + ) is not done, because this cannot be expressed in SQL.
<span class="lineno">   50 </span>-- These operators must be eliminated from the Expression before using selectExpr, or else you will get fatals.
<span class="lineno">   51 </span><span class="decl"><span class="nottickedoff">selectExpr fSpec expr </span>
<span class="lineno">   52 </span><span class="spaces"> </span><span class="nottickedoff">= fromMaybe (nonSpecialSelectExpr fSpec expr) (maybeSpecialCase fSpec expr)</span></span> --special cases for optimized results.
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>-- Special cases for optimized SQL generation
<span class="lineno">   55 </span>-- Sometimes it is possible to generate queries that perform better. If this is the case for some 
<span class="lineno">   56 </span>-- expression, this function will return the optimized query. 
<span class="lineno">   57 </span>maybeSpecialCase :: FSpec -&gt; Expression -&gt; Maybe BinQueryExpr
<span class="lineno">   58 </span><span class="decl"><span class="nottickedoff">maybeSpecialCase fSpec expr = </span>
<span class="lineno">   59 </span><span class="spaces">  </span><span class="nottickedoff">case expr of </span>
<span class="lineno">   60 </span><span class="spaces">    </span><span class="nottickedoff">EIsc (EDcI a , ECpl (ECps (EDcD r,EFlp (EDcD r')) )) </span>
<span class="lineno">   61 </span><span class="spaces">      </span><span class="nottickedoff">| r == r'   -&gt; Just . BQEComment </span>
<span class="lineno">   62 </span><span class="spaces">                              </span><span class="nottickedoff">[ BlockComment $ &quot;Optimized case for: &quot;++name r++showSign r++&quot; [TOT].&quot;</span>
<span class="lineno">   63 </span><span class="spaces">                              </span><span class="nottickedoff">, BlockComment $ &quot;   &quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;</span>
<span class="lineno">   64 </span><span class="spaces">                              </span><span class="nottickedoff">] $ </span>
<span class="lineno">   65 </span><span class="spaces">                                 </span><span class="nottickedoff">let aAtt = Iden [sqlAttConcept fSpec a]</span>
<span class="lineno">   66 </span><span class="spaces">                                     </span><span class="nottickedoff">whereClause = </span>
<span class="lineno">   67 </span><span class="spaces">                                       </span><span class="nottickedoff">conjunctSQL [ aAtt `isNotIn` selectSource (selectExpr fSpec (EDcD r))</span>
<span class="lineno">   68 </span><span class="spaces">                                                   </span><span class="nottickedoff">, notNull aAtt</span>
<span class="lineno">   69 </span><span class="spaces">                                                   </span><span class="nottickedoff">]</span>
<span class="lineno">   70 </span><span class="spaces">                                 </span><span class="nottickedoff">in    </span>
<span class="lineno">   71 </span><span class="spaces">                                   </span><span class="nottickedoff">BSE { bseSrc = aAtt</span>
<span class="lineno">   72 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseTrg = aAtt</span>
<span class="lineno">   73 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseTbl = [sqlConceptTable fSpec a `as` Name &quot;notIns&quot;]</span>
<span class="lineno">   74 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseWhr = Just whereClause</span>
<span class="lineno">   75 </span><span class="spaces">                                       </span><span class="nottickedoff">}</span>
<span class="lineno">   76 </span><span class="spaces">      </span><span class="nottickedoff">| otherwise -&gt; Nothing</span>
<span class="lineno">   77 </span><span class="spaces">    </span><span class="nottickedoff">EIsc (expr1 , ECpl expr2)</span>
<span class="lineno">   78 </span><span class="spaces">                  </span><span class="nottickedoff">-&gt; Just . BQEComment</span>
<span class="lineno">   79 </span><span class="spaces">                              </span><span class="nottickedoff">[ BlockComment . unlines $</span>
<span class="lineno">   80 </span><span class="spaces">                                   </span><span class="nottickedoff">[ &quot;Optimized case for: &lt;expr1&gt; intersect with the complement of &lt;expr2&gt;.&quot;</span>
<span class="lineno">   81 </span><span class="spaces">                                   </span><span class="nottickedoff">, &quot;where &quot;</span>
<span class="lineno">   82 </span><span class="spaces">                                   </span><span class="nottickedoff">, &quot;  &lt;expr1&gt; = &quot;++showADL expr1++&quot; (&quot;++show (sign expr1)++&quot;)&quot;</span>
<span class="lineno">   83 </span><span class="spaces">                                   </span><span class="nottickedoff">, &quot;  &lt;expr2&gt; = &quot;++showADL expr2++&quot; (&quot;++show (sign expr2)++&quot;)&quot;</span>
<span class="lineno">   84 </span><span class="spaces">                                   </span><span class="nottickedoff">, &quot;   &quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;</span>
<span class="lineno">   85 </span><span class="spaces">                                   </span><span class="nottickedoff">]</span>
<span class="lineno">   86 </span><span class="spaces">                              </span><span class="nottickedoff">] $ let table1 = Name &quot;t1&quot;</span>
<span class="lineno">   87 </span><span class="spaces">                                      </span><span class="nottickedoff">table2 = Name &quot;t2&quot;</span>
<span class="lineno">   88 </span><span class="spaces">                                      </span><span class="nottickedoff">whereClause = Just . disjunctSQL $</span>
<span class="lineno">   89 </span><span class="spaces">                                                      </span><span class="nottickedoff">[ isNull (Iden[table2,sourceAlias])</span>
<span class="lineno">   90 </span><span class="spaces">                                                      </span><span class="nottickedoff">, isNull (Iden[table2,targetAlias])</span>
<span class="lineno">   91 </span><span class="spaces">                                                      </span><span class="nottickedoff">]</span>
<span class="lineno">   92 </span><span class="spaces">                                  </span><span class="nottickedoff">in BSE { bseSrc = Iden [table1 ,sourceAlias]</span>
<span class="lineno">   93 </span><span class="spaces">                                         </span><span class="nottickedoff">, bseTrg = Iden [table1 ,targetAlias]</span>
<span class="lineno">   94 </span><span class="spaces">                                         </span><span class="nottickedoff">, bseTbl = [TRJoin </span>
<span class="lineno">   95 </span><span class="spaces">                                                       </span><span class="nottickedoff">(TRQueryExpr (toSQL (selectExpr fSpec expr1)) `as` table1)</span>
<span class="lineno">   96 </span><span class="spaces">                                                       </span><span class="nottickedoff">False -- Needs to be false in MySql</span>
<span class="lineno">   97 </span><span class="spaces">                                                       </span><span class="nottickedoff">JLeft</span>
<span class="lineno">   98 </span><span class="spaces">                                                       </span><span class="nottickedoff">(TRQueryExpr (toSQL (selectExpr fSpec expr2)) `as` table2)</span>
<span class="lineno">   99 </span><span class="spaces">                                                       </span><span class="nottickedoff">(Just . JoinOn . conjunctSQL $</span>
<span class="lineno">  100 </span><span class="spaces">                                                           </span><span class="nottickedoff">[ BinOp (Iden[table1,sourceAlias]) [Name &quot;=&quot;] (Iden[table2,sourceAlias])</span>
<span class="lineno">  101 </span><span class="spaces">                                                           </span><span class="nottickedoff">, BinOp (Iden[table1,targetAlias]) [Name &quot;=&quot;] (Iden[table2,targetAlias])</span>
<span class="lineno">  102 </span><span class="spaces">                                                           </span><span class="nottickedoff">]</span>
<span class="lineno">  103 </span><span class="spaces">                                                       </span><span class="nottickedoff">) </span>
<span class="lineno">  104 </span><span class="spaces">                                                    </span><span class="nottickedoff">]</span>
<span class="lineno">  105 </span><span class="spaces">                                         </span><span class="nottickedoff">, bseWhr = whereClause</span>
<span class="lineno">  106 </span><span class="spaces">                                         </span><span class="nottickedoff">}</span>
<span class="lineno">  107 </span><span class="spaces">    </span><span class="nottickedoff">EIsc (expr1 , EFlp (ECpl expr2))</span>
<span class="lineno">  108 </span><span class="spaces">                  </span><span class="nottickedoff">-&gt; Just . BQEComment</span>
<span class="lineno">  109 </span><span class="spaces">                              </span><span class="nottickedoff">[ BlockComment . unlines $</span>
<span class="lineno">  110 </span><span class="spaces">                                   </span><span class="nottickedoff">[ &quot;Optimized case for: &lt;expr1&gt; intersect with the flipped complement of &lt;expr2&gt;.&quot;</span>
<span class="lineno">  111 </span><span class="spaces">                                   </span><span class="nottickedoff">, &quot;where &quot;</span>
<span class="lineno">  112 </span><span class="spaces">                                   </span><span class="nottickedoff">, &quot;  &lt;expr1&gt; = &quot;++showADL expr1++&quot; (&quot;++show (sign expr1)++&quot;)&quot;</span>
<span class="lineno">  113 </span><span class="spaces">                                   </span><span class="nottickedoff">, &quot;  &lt;expr2&gt; = &quot;++showADL expr2++&quot; (&quot;++show (sign expr2)++&quot;)&quot;</span>
<span class="lineno">  114 </span><span class="spaces">                                   </span><span class="nottickedoff">, &quot;   &quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;</span>
<span class="lineno">  115 </span><span class="spaces">                                   </span><span class="nottickedoff">]</span>
<span class="lineno">  116 </span><span class="spaces">                              </span><span class="nottickedoff">] $ let table1 = Name &quot;t1&quot;</span>
<span class="lineno">  117 </span><span class="spaces">                                      </span><span class="nottickedoff">table2 = Name &quot;t2&quot;</span>
<span class="lineno">  118 </span><span class="spaces">                                      </span><span class="nottickedoff">whereClause = Just . disjunctSQL $</span>
<span class="lineno">  119 </span><span class="spaces">                                                      </span><span class="nottickedoff">[ isNull (Iden[table2,sourceAlias])</span>
<span class="lineno">  120 </span><span class="spaces">                                                      </span><span class="nottickedoff">, isNull (Iden[table2,targetAlias])</span>
<span class="lineno">  121 </span><span class="spaces">                                                      </span><span class="nottickedoff">]</span>
<span class="lineno">  122 </span><span class="spaces">                                  </span><span class="nottickedoff">in BSE { bseSrc = Iden [table1 ,sourceAlias]</span>
<span class="lineno">  123 </span><span class="spaces">                                         </span><span class="nottickedoff">, bseTrg = Iden [table1 ,targetAlias]</span>
<span class="lineno">  124 </span><span class="spaces">                                         </span><span class="nottickedoff">, bseTbl = [TRJoin </span>
<span class="lineno">  125 </span><span class="spaces">                                                       </span><span class="nottickedoff">(TRQueryExpr (toSQL (selectExpr fSpec expr1)) `as` table1)</span>
<span class="lineno">  126 </span><span class="spaces">                                                       </span><span class="nottickedoff">False -- Needs to be false in MySql</span>
<span class="lineno">  127 </span><span class="spaces">                                                       </span><span class="nottickedoff">JLeft</span>
<span class="lineno">  128 </span><span class="spaces">                                                       </span><span class="nottickedoff">(TRQueryExpr (toSQL (selectExpr fSpec (flp expr2))) `as` table2)</span>
<span class="lineno">  129 </span><span class="spaces">                                                       </span><span class="nottickedoff">(Just . JoinOn . conjunctSQL $</span>
<span class="lineno">  130 </span><span class="spaces">                                                           </span><span class="nottickedoff">[ BinOp (Iden[table1,sourceAlias]) [Name &quot;=&quot;] (Iden[table2,sourceAlias])</span>
<span class="lineno">  131 </span><span class="spaces">                                                           </span><span class="nottickedoff">, BinOp (Iden[table1,targetAlias]) [Name &quot;=&quot;] (Iden[table2,targetAlias])</span>
<span class="lineno">  132 </span><span class="spaces">                                                           </span><span class="nottickedoff">]</span>
<span class="lineno">  133 </span><span class="spaces">                                                       </span><span class="nottickedoff">) </span>
<span class="lineno">  134 </span><span class="spaces">                                                    </span><span class="nottickedoff">]</span>
<span class="lineno">  135 </span><span class="spaces">                                         </span><span class="nottickedoff">, bseWhr = whereClause</span>
<span class="lineno">  136 </span><span class="spaces">                                         </span><span class="nottickedoff">}</span>
<span class="lineno">  137 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Nothing</span></span> 
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>nonSpecialSelectExpr :: FSpec -&gt; Expression -&gt; BinQueryExpr
<span class="lineno">  141 </span><span class="decl"><span class="nottickedoff">nonSpecialSelectExpr fSpec expr=</span>
<span class="lineno">  142 </span><span class="spaces">    </span><span class="nottickedoff">case expr of</span>
<span class="lineno">  143 </span><span class="spaces">    </span><span class="nottickedoff">EIsc{} -&gt; </span>
<span class="lineno">  144 </span><span class="spaces">    </span><span class="nottickedoff">{- The story on the case of EIsc:</span>
<span class="lineno">  145 </span><span class="spaces"> </span><span class="nottickedoff">This alternative of selectExpr compiles a conjunction of at least two subexpressions (code: EIsc lst'@(_:_:_))</span>
<span class="lineno">  146 </span><span class="spaces"> </span><span class="nottickedoff">Each of these subexpressions are of one of the following types:</span>
<span class="lineno">  147 </span><span class="spaces">     </span><span class="nottickedoff">1) positive and Mp1</span>
<span class="lineno">  148 </span><span class="spaces">     </span><span class="nottickedoff">2) negative and Mp1</span>
<span class="lineno">  149 </span><span class="spaces">     </span><span class="nottickedoff">3) not Mp1</span>
<span class="lineno">  150 </span><span class="spaces">    </span><span class="nottickedoff">-}</span>
<span class="lineno">  151 </span><span class="spaces">          </span><span class="nottickedoff">case posVals of</span>
<span class="lineno">  152 </span><span class="spaces">            </span><span class="nottickedoff">( _ {-a-} : _ {-b-} : _ )</span>
<span class="lineno">  153 </span><span class="spaces">                </span><span class="nottickedoff">-&gt; emptySet  --since a /= b, there can be no result. </span>
<span class="lineno">  154 </span><span class="spaces">            </span><span class="nottickedoff">[val]</span>
<span class="lineno">  155 </span><span class="spaces">                </span><span class="nottickedoff">-&gt; if val `elem` negVals then emptySet</span>
<span class="lineno">  156 </span><span class="spaces">                   </span><span class="nottickedoff">else f (Just val) nonMp1Terms</span>
<span class="lineno">  157 </span><span class="spaces">            </span><span class="nottickedoff">[]  -&gt; f Nothing nonMp1Terms</span>
<span class="lineno">  158 </span><span class="spaces">           </span><span class="nottickedoff">where </span>
<span class="lineno">  159 </span><span class="spaces">                  </span><span class="nottickedoff">posVals :: [String]</span>
<span class="lineno">  160 </span><span class="spaces">                  </span><span class="nottickedoff">posVals = nub (map atmValue posMp1Terms)</span>
<span class="lineno">  161 </span><span class="spaces">                  </span><span class="nottickedoff">negVals :: [String]</span>
<span class="lineno">  162 </span><span class="spaces">                  </span><span class="nottickedoff">negVals = nub (map (atmValue . notCpl) negMp1Terms)</span>
<span class="lineno">  163 </span><span class="spaces">                  </span><span class="nottickedoff">atmValue (EMp1 a _) = a</span>
<span class="lineno">  164 </span><span class="spaces">                  </span><span class="nottickedoff">atmValue _          = fatal 31 &quot;atm error&quot;</span>
<span class="lineno">  165 </span><span class="spaces">                  </span><span class="nottickedoff">mp1Terms, nonMp1Terms :: [Expression]</span>
<span class="lineno">  166 </span><span class="spaces">                  </span><span class="nottickedoff">(mp1Terms,nonMp1Terms) = partition isMp1 (exprIsc2list expr)</span>
<span class="lineno">  167 </span><span class="spaces">                  </span><span class="nottickedoff">posMp1Terms, negMp1Terms :: [Expression]</span>
<span class="lineno">  168 </span><span class="spaces">                  </span><span class="nottickedoff">(posMp1Terms,negMp1Terms) = partition isPos mp1Terms</span>
<span class="lineno">  169 </span><span class="spaces">                  </span><span class="nottickedoff">f :: Maybe String   -- Optional the single atomvalue that might be found as the only possible value </span>
<span class="lineno">  170 </span><span class="spaces">                      </span><span class="nottickedoff">-&gt; [Expression] -- subexpressions of the intersection.  Mp1{} nor ECpl(Mp1{}) are allowed elements of this list.  </span>
<span class="lineno">  171 </span><span class="spaces">                      </span><span class="nottickedoff">-&gt; BinQueryExpr</span>
<span class="lineno">  172 </span><span class="spaces">                  </span><span class="nottickedoff">f specificValue subTerms </span>
<span class="lineno">  173 </span><span class="spaces">                     </span><span class="nottickedoff">= BQEComment [BlockComment $ unlines ([&quot;case: (EIsc &quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;</span>
<span class="lineno">  174 </span><span class="spaces">                                                           </span><span class="nottickedoff">]++case expr of </span>
<span class="lineno">  175 </span><span class="spaces">                                                                </span><span class="nottickedoff">EIsc (a,b) -&gt; </span>
<span class="lineno">  176 </span><span class="spaces">                                                                   </span><span class="nottickedoff">[show a</span>
<span class="lineno">  177 </span><span class="spaces">                                                                   </span><span class="nottickedoff">,show b</span>
<span class="lineno">  178 </span><span class="spaces">                                                                   </span><span class="nottickedoff">]</span>
<span class="lineno">  179 </span><span class="spaces">                                                                </span><span class="nottickedoff">_ -&gt; fatal 148 $ &quot;Not expecting anything else here than EIsc!\n  &quot; ++ show expr</span>
<span class="lineno">  180 </span><span class="spaces">                                                          </span><span class="nottickedoff">)] $</span>
<span class="lineno">  181 </span><span class="spaces">                        </span><span class="nottickedoff">case subTerms of</span>
<span class="lineno">  182 </span><span class="spaces">                          </span><span class="nottickedoff">[] -&gt; case specificValue of </span>
<span class="lineno">  183 </span><span class="spaces">                                 </span><span class="nottickedoff">Nothing  -&gt; emptySet -- case might occur with only negMp1Terms??</span>
<span class="lineno">  184 </span><span class="spaces">                                 </span><span class="nottickedoff">Just str -&gt;</span>
<span class="lineno">  185 </span><span class="spaces">                                    </span><span class="nottickedoff">BSE { bseSrc = StringLit str</span>
<span class="lineno">  186 </span><span class="spaces">                                        </span><span class="nottickedoff">, bseTrg = StringLit str</span>
<span class="lineno">  187 </span><span class="spaces">                                        </span><span class="nottickedoff">, bseTbl = []</span>
<span class="lineno">  188 </span><span class="spaces">                                        </span><span class="nottickedoff">, bseWhr = Nothing</span>
<span class="lineno">  189 </span><span class="spaces">                                        </span><span class="nottickedoff">}</span>
<span class="lineno">  190 </span><span class="spaces">                          </span><span class="nottickedoff">ts  -&gt;    BSE { bseSrc = theSrc</span>
<span class="lineno">  191 </span><span class="spaces">                                        </span><span class="nottickedoff">, bseTrg = theTrg</span>
<span class="lineno">  192 </span><span class="spaces">                                        </span><span class="nottickedoff">, bseTbl = theTbl</span>
<span class="lineno">  193 </span><span class="spaces">                                        </span><span class="nottickedoff">, bseWhr = case catMaybes [mandatoryTuple,forbiddenTuples,theWhr] of</span>
<span class="lineno">  194 </span><span class="spaces">                                                    </span><span class="nottickedoff">[] -&gt; Nothing</span>
<span class="lineno">  195 </span><span class="spaces">                                                    </span><span class="nottickedoff">vs -&gt; Just (conjunctSQL vs)</span>
<span class="lineno">  196 </span><span class="spaces">                                        </span><span class="nottickedoff">}</span>
<span class="lineno">  197 </span><span class="spaces">                                     </span><span class="nottickedoff">where</span>
<span class="lineno">  198 </span><span class="spaces">                                       </span><span class="nottickedoff">mandatoryTuple :: Maybe ValueExpr</span>
<span class="lineno">  199 </span><span class="spaces">                                       </span><span class="nottickedoff">mandatoryTuple =</span>
<span class="lineno">  200 </span><span class="spaces">                                          </span><span class="nottickedoff">case specificValue of</span>
<span class="lineno">  201 </span><span class="spaces">                                            </span><span class="nottickedoff">Nothing  -&gt; Nothing</span>
<span class="lineno">  202 </span><span class="spaces">                                            </span><span class="nottickedoff">Just val -&gt; Just $ equalToValueClause val</span>
<span class="lineno">  203 </span><span class="spaces">                                          </span><span class="nottickedoff">where</span>
<span class="lineno">  204 </span><span class="spaces">                                            </span><span class="nottickedoff">equalToValueClause :: String -&gt; ValueExpr</span>
<span class="lineno">  205 </span><span class="spaces">                                            </span><span class="nottickedoff">equalToValueClause str = conjunctSQL </span>
<span class="lineno">  206 </span><span class="spaces">                                                               </span><span class="nottickedoff">[ BinOp theSrc [Name &quot;=&quot;] (StringLit str)</span>
<span class="lineno">  207 </span><span class="spaces">                                                               </span><span class="nottickedoff">, BinOp theTrg [Name &quot;=&quot;] (StringLit str)</span>
<span class="lineno">  208 </span><span class="spaces">                                                               </span><span class="nottickedoff">]</span>
<span class="lineno">  209 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  210 </span><span class="spaces">                                       </span><span class="nottickedoff">forbiddenTuples :: Maybe ValueExpr</span>
<span class="lineno">  211 </span><span class="spaces">                                       </span><span class="nottickedoff">forbiddenTuples = </span>
<span class="lineno">  212 </span><span class="spaces">                                           </span><span class="nottickedoff">case negVals of</span>
<span class="lineno">  213 </span><span class="spaces">                                            </span><span class="nottickedoff">[]  -&gt; Nothing</span>
<span class="lineno">  214 </span><span class="spaces">                                            </span><span class="nottickedoff">_   -&gt; Just . conjunctSQL $</span>
<span class="lineno">  215 </span><span class="spaces">                                                     </span><span class="nottickedoff">map notEqualToValueClause negVals</span>
<span class="lineno">  216 </span><span class="spaces">                                          </span><span class="nottickedoff">where</span>
<span class="lineno">  217 </span><span class="spaces">                                            </span><span class="nottickedoff">notEqualToValueClause :: String -&gt; ValueExpr</span>
<span class="lineno">  218 </span><span class="spaces">                                            </span><span class="nottickedoff">notEqualToValueClause str = conjunctSQL </span>
<span class="lineno">  219 </span><span class="spaces">                                                               </span><span class="nottickedoff">[ BinOp theSrc [Name &quot;&lt;&gt;&quot;] (StringLit str)</span>
<span class="lineno">  220 </span><span class="spaces">                                                               </span><span class="nottickedoff">, BinOp theTrg [Name &quot;&lt;&gt;&quot;] (StringLit str)</span>
<span class="lineno">  221 </span><span class="spaces">                                                               </span><span class="nottickedoff">]</span>
<span class="lineno">  222 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  223 </span><span class="spaces">                                       </span><span class="nottickedoff">theSrc = bseSrc (makeSelectable sResult)</span>
<span class="lineno">  224 </span><span class="spaces">                                       </span><span class="nottickedoff">theTrg = bseTrg (makeSelectable sResult)</span>
<span class="lineno">  225 </span><span class="spaces">                                       </span><span class="nottickedoff">theTbl = bseTbl (makeSelectable sResult)</span>
<span class="lineno">  226 </span><span class="spaces">                                       </span><span class="nottickedoff">theWhr = case makeSelectable sResult of</span>
<span class="lineno">  227 </span><span class="spaces">                                                  </span><span class="nottickedoff">e@BSE{}      -&gt; bseWhr e</span>
<span class="lineno">  228 </span><span class="spaces">                                                  </span><span class="nottickedoff">BCQE{}       -&gt; fatal 129 &quot;makeSelectable is not doing what it is supposed to do!&quot; </span>
<span class="lineno">  229 </span><span class="spaces">                                                  </span><span class="nottickedoff">BQEComment{} -&gt; fatal 130 &quot;makeSelectable is not doing what it is supposed to do!&quot; </span>
<span class="lineno">  230 </span><span class="spaces">                                       </span><span class="nottickedoff">sResult = makeIntersectSelectExpr ts</span>
<span class="lineno">  231 </span><span class="spaces">                                       </span><span class="nottickedoff">makeSelectable :: BinQueryExpr -&gt; BinQueryExpr</span>
<span class="lineno">  232 </span><span class="spaces">                                       </span><span class="nottickedoff">makeSelectable x =</span>
<span class="lineno">  233 </span><span class="spaces">                                         </span><span class="nottickedoff">case x of</span>
<span class="lineno">  234 </span><span class="spaces">                                           </span><span class="nottickedoff">BSE{}   -&gt; x</span>
<span class="lineno">  235 </span><span class="spaces">                                           </span><span class="nottickedoff">_       -&gt; BSE { bseSrc = Iden [sourceAlias]</span>
<span class="lineno">  236 </span><span class="spaces">                                                          </span><span class="nottickedoff">, bseTrg = Iden [targetAlias]</span>
<span class="lineno">  237 </span><span class="spaces">                                                          </span><span class="nottickedoff">, bseTbl = [TRQueryExpr (toSQL (x)) `as` Name &quot;someDummyNameBecauseMySQLNeedsOne&quot; ]</span>
<span class="lineno">  238 </span><span class="spaces">                                                          </span><span class="nottickedoff">, bseWhr = Nothing</span>
<span class="lineno">  239 </span><span class="spaces">                                                          </span><span class="nottickedoff">}</span>
<span class="lineno">  240 </span><span class="spaces">                                       </span><span class="nottickedoff">makeIntersectSelectExpr :: [Expression] -&gt; BinQueryExpr</span>
<span class="lineno">  241 </span><span class="spaces">                                       </span><span class="nottickedoff">makeIntersectSelectExpr exprs =</span>
<span class="lineno">  242 </span><span class="spaces">                                        </span><span class="nottickedoff">case map (selectExpr fSpec) exprs of </span>
<span class="lineno">  243 </span><span class="spaces">                                          </span><span class="nottickedoff">[]  -&gt; fatal 126 &quot;makeIntersectSelectExpr must not be used on empty list&quot;</span>
<span class="lineno">  244 </span><span class="spaces">                                          </span><span class="nottickedoff">[e] -&gt; e</span>
<span class="lineno">  245 </span><span class="spaces">                                          </span><span class="nottickedoff">es  -&gt; -- Note: We now have at least two subexpressions</span>
<span class="lineno">  246 </span><span class="spaces">                                                 </span><span class="nottickedoff">BQEComment [BlockComment &quot;`intersect` does not work in MySQL, so this statement is generated:&quot;] $</span>
<span class="lineno">  247 </span><span class="spaces">                                                 </span><span class="nottickedoff">BSE { bseSrc = Iden[iSect 0,sourceAlias]</span>
<span class="lineno">  248 </span><span class="spaces">                                                     </span><span class="nottickedoff">, bseTrg = Iden[iSect 0,targetAlias]</span>
<span class="lineno">  249 </span><span class="spaces">                                                     </span><span class="nottickedoff">, bseTbl = map tableRef (zip [0..] es)</span>
<span class="lineno">  250 </span><span class="spaces">                                                     </span><span class="nottickedoff">, bseWhr = Just . conjunctSQL . concatMap constraintsOfTailExpression $ </span>
<span class="lineno">  251 </span><span class="spaces">                                                                   </span><span class="nottickedoff">[1..length (tail es)]     </span>
<span class="lineno">  252 </span><span class="spaces">                                                     </span><span class="nottickedoff">}</span>
<span class="lineno">  253 </span><span class="spaces">                                                  </span><span class="nottickedoff">where</span>
<span class="lineno">  254 </span><span class="spaces">                                                   </span><span class="nottickedoff">iSect :: Int -&gt; Name</span>
<span class="lineno">  255 </span><span class="spaces">                                                   </span><span class="nottickedoff">iSect n = Name (&quot;subIntersect&quot;++show n)</span>
<span class="lineno">  256 </span><span class="spaces">                                                   </span><span class="nottickedoff">tableRef :: (Int, BinQueryExpr) -&gt; TableRef</span>
<span class="lineno">  257 </span><span class="spaces">                                                   </span><span class="nottickedoff">tableRef (n, e) = TRQueryExpr (toSQL e) `as` iSect n</span>
<span class="lineno">  258 </span><span class="spaces">                                                   </span><span class="nottickedoff">constraintsOfTailExpression :: Int -&gt; [ValueExpr]</span>
<span class="lineno">  259 </span><span class="spaces">                                                   </span><span class="nottickedoff">constraintsOfTailExpression n </span>
<span class="lineno">  260 </span><span class="spaces">                                                      </span><span class="nottickedoff">= [ BinOp (Iden[iSect n,sourceAlias]) [Name &quot;=&quot;] (Iden[iSect 0,sourceAlias])</span>
<span class="lineno">  261 </span><span class="spaces">                                                        </span><span class="nottickedoff">, BinOp (Iden[iSect n,targetAlias]) [Name &quot;=&quot;] (Iden[iSect 0,targetAlias])</span>
<span class="lineno">  262 </span><span class="spaces">                                                        </span><span class="nottickedoff">]</span>
<span class="lineno">  263 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  264 </span><span class="spaces">    </span><span class="nottickedoff">EUni (l,r) -&gt; BQEComment [BlockComment $ &quot;case: EUni (l,r)&quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;] $</span>
<span class="lineno">  265 </span><span class="spaces">                  </span><span class="nottickedoff">BCQE { bcqeOper = Union</span>
<span class="lineno">  266 </span><span class="spaces">                       </span><span class="nottickedoff">, bcqe0    = selectExpr fSpec l</span>
<span class="lineno">  267 </span><span class="spaces">                       </span><span class="nottickedoff">, bcqe1    = selectExpr fSpec r</span>
<span class="lineno">  268 </span><span class="spaces">                       </span><span class="nottickedoff">}</span>
<span class="lineno">  269 </span><span class="spaces">                                 </span><span class="nottickedoff"></span>
<span class="lineno">  270 </span><span class="spaces">    </span><span class="nottickedoff">ECps{}  -&gt;</span>
<span class="lineno">  271 </span><span class="spaces">       </span><span class="nottickedoff">case exprCps2list expr of</span>
<span class="lineno">  272 </span><span class="spaces">          </span><span class="nottickedoff">[] -&gt; fatal 190 (&quot;impossible outcome of exprCps2list: &quot;++showADL expr)</span>
<span class="lineno">  273 </span><span class="spaces">          </span><span class="nottickedoff">[e]-&gt; selectExpr fSpec e -- Even though this case cannot occur, it safeguards that there are two or more elements in exprCps2list expr in the remainder of this code.</span>
<span class="lineno">  274 </span><span class="spaces"></span><span class="nottickedoff">{-  We can treat the ECps expressions as poles-and-fences, with at least two fences.</span>
<span class="lineno">  275 </span><span class="spaces">    </span><span class="nottickedoff">We start numbering the fences with 0. Each fence is connected to the previous fence with a pole.</span>
<span class="lineno">  276 </span><span class="spaces">    </span><span class="nottickedoff">the pole holds the constraints of the connection of the fence to the previous fence. Only pole 0 has no previous </span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="nottickedoff">fence, so ther are no constraints. </span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="nottickedoff">In general, at some pole i, the constraint is that fence(i-1).trg=fencei.src</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="nottickedoff">However, there are exceptions for the expressions V and Mp1 (and possibly I??).</span>
<span class="lineno">  280 </span><span class="spaces">    </span><span class="nottickedoff">For V, we don not calculate V, and we also pose no restrictions at the pole. </span>
<span class="lineno">  281 </span><span class="spaces">    </span><span class="nottickedoff">For Mp1, we do not calculate Mp1, but we do pose a restriction at the pole.  </span>
<span class="lineno">  282 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">  283 </span><span class="spaces">    </span><span class="nottickedoff">Imagine subexpressions as &quot;fences&quot;. The source and target of a &quot;fence&quot; are the &quot;poles&quot; between which that &quot;fence&quot; is mounted.</span>
<span class="lineno">  284 </span><span class="spaces">    </span><span class="nottickedoff">In this metaphor, we create the FROM-clause directly from the &quot;fences&quot;, and the WHERE-clause from the &quot;poles&quot; between &quot;fences&quot;.</span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="nottickedoff">The &quot;outer poles&quot; correspond to the source and target of the entire expression.</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="nottickedoff">To prevent name conflicts in SQL, each calculated subexpression is aliased in SQL by a unique the fenceName. &quot;.</span>
<span class="lineno">  287 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno">  288 </span><span class="spaces"></span><span class="nottickedoff">{- TODO: Check these assumptions:</span>
<span class="lineno">  289 </span><span class="spaces">     </span><span class="nottickedoff">1) We assume that: let exprCps2list = [e0, e1, ... , en],</span>
<span class="lineno">  290 </span><span class="spaces">                             </span><span class="nottickedoff">for all i: 0&lt;=i&lt; n the following is true:</span>
<span class="lineno">  291 </span><span class="spaces">                                </span><span class="nottickedoff">if ei == EDcV{}  then e(i+1) /= EDcV{}</span>
<span class="lineno">  292 </span><span class="spaces">                                </span><span class="nottickedoff">Or, in plain english: two neighbouring expressions are not both `V`</span>
<span class="lineno">  293 </span><span class="spaces">     </span><span class="nottickedoff">2) We assume that for all expressions e in the list: e /= I[ONE]</span>
<span class="lineno">  294 </span><span class="spaces">           </span><span class="nottickedoff">(We don't like:  ... ;V[A*ONE];I[ONE];V[ONE*B];... . It should have been normalized to V[A*B])</span>
<span class="lineno">  295 </span><span class="spaces">     </span><span class="nottickedoff">3) We assume that for all neighbouring expressions ei and e(i+1) in the list cannot be both EMp1</span>
<span class="lineno">  296 </span><span class="spaces">           </span><span class="nottickedoff">(`value1`;`value2` can be normalized to `value1` iff value1 == value2. Otherwise it can be normalized to the empty set )</span>
<span class="lineno">  297 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno">  298 </span><span class="spaces">          </span><span class="nottickedoff">es -&gt; let fenceName :: Int -&gt; Name</span>
<span class="lineno">  299 </span><span class="spaces">                    </span><span class="nottickedoff">fenceName n = Name (&quot;fence&quot;++show n)</span>
<span class="lineno">  300 </span><span class="spaces">                    </span><span class="nottickedoff">firstNr, lastNr :: Int</span>
<span class="lineno">  301 </span><span class="spaces">                    </span><span class="nottickedoff">firstNr = 0</span>
<span class="lineno">  302 </span><span class="spaces">                    </span><span class="nottickedoff">lastNr = firstNr + length es - 1</span>
<span class="lineno">  303 </span><span class="spaces">                    </span><span class="nottickedoff">fenceExpr :: Int -&gt; Expression </span>
<span class="lineno">  304 </span><span class="spaces">                    </span><span class="nottickedoff">fenceExpr i = case lookup i (zip [firstNr..lastNr] es) of</span>
<span class="lineno">  305 </span><span class="spaces">                                    </span><span class="nottickedoff">Nothing -&gt; fatal 238 &quot;i out of bound!&quot;</span>
<span class="lineno">  306 </span><span class="spaces">                                    </span><span class="nottickedoff">Just e -&gt; e </span>
<span class="lineno">  307 </span><span class="spaces">                    </span><span class="nottickedoff">fences :: [Maybe TableRef]</span>
<span class="lineno">  308 </span><span class="spaces">                    </span><span class="nottickedoff">fences = map fenceTable [firstNr..lastNr]</span>
<span class="lineno">  309 </span><span class="spaces">                    </span><span class="nottickedoff">fenceTable :: Int -&gt; Maybe TableRef</span>
<span class="lineno">  310 </span><span class="spaces">                    </span><span class="nottickedoff">fenceTable i = </span>
<span class="lineno">  311 </span><span class="spaces">                      </span><span class="nottickedoff">-- The first and the last fence must always exist, because the source and target of the entire expression </span>
<span class="lineno">  312 </span><span class="spaces">                      </span><span class="nottickedoff">-- depend on them. </span>
<span class="lineno">  313 </span><span class="spaces">                      </span><span class="nottickedoff">if i == firstNr || i == lastNr </span>
<span class="lineno">  314 </span><span class="spaces">                      </span><span class="nottickedoff">then makeNormalFence</span>
<span class="lineno">  315 </span><span class="spaces">                      </span><span class="nottickedoff">else </span>
<span class="lineno">  316 </span><span class="spaces">                        </span><span class="nottickedoff">case fenceExpr i of </span>
<span class="lineno">  317 </span><span class="spaces">                       </span><span class="nottickedoff">-- In some cases of a non-outer expression, a fence need not be generated, to get better SQL queries. </span>
<span class="lineno">  318 </span><span class="spaces">                            </span><span class="nottickedoff">EDcV{} -&gt; Nothing  </span>
<span class="lineno">  319 </span><span class="spaces">                            </span><span class="nottickedoff">EMp1{} -&gt; Nothing</span>
<span class="lineno">  320 </span><span class="spaces">                            </span><span class="nottickedoff">(ECpl EMp1{}) -&gt; Nothing </span>
<span class="lineno">  321 </span><span class="spaces">                            </span><span class="nottickedoff">_      -&gt; makeNormalFence</span>
<span class="lineno">  322 </span><span class="spaces">                     </span><span class="nottickedoff">where</span>
<span class="lineno">  323 </span><span class="spaces">                       </span><span class="nottickedoff">makeNormalFence = Just $ (TRQueryExpr . toSQL . selectExpr fSpec) (fenceExpr i) `as` fenceName i</span>
<span class="lineno">  324 </span><span class="spaces">                       </span><span class="nottickedoff"></span>
<span class="lineno">  325 </span><span class="spaces">                                                                  </span><span class="nottickedoff"></span>
<span class="lineno">  326 </span><span class="spaces">                                    </span><span class="nottickedoff"></span>
<span class="lineno">  327 </span><span class="spaces">                    </span><span class="nottickedoff">-- | between two fences there is a pole. The pole holds the constraint(s) between these fences.</span>
<span class="lineno">  328 </span><span class="spaces">                    </span><span class="nottickedoff">polesConstraints :: [Maybe ValueExpr]</span>
<span class="lineno">  329 </span><span class="spaces">                    </span><span class="nottickedoff">polesConstraints = map makePole [firstNr..lastNr - 1] --there is one pole less than fences...</span>
<span class="lineno">  330 </span><span class="spaces">                      </span><span class="nottickedoff">where </span>
<span class="lineno">  331 </span><span class="spaces">                        </span><span class="nottickedoff">makePole :: Int -&gt; Maybe ValueExpr</span>
<span class="lineno">  332 </span><span class="spaces">                        </span><span class="nottickedoff">makePole i </span>
<span class="lineno">  333 </span><span class="spaces">                         </span><span class="nottickedoff">= case (fenceTable i, fenceTable (i+1)) of</span>
<span class="lineno">  334 </span><span class="spaces">                             </span><span class="nottickedoff">(Just _ , Just _ ) -&gt; </span>
<span class="lineno">  335 </span><span class="spaces">                                                 </span><span class="nottickedoff">Just (BinOp (Iden [fenceName i,targetAlias])</span>
<span class="lineno">  336 </span><span class="spaces">                                                             </span><span class="nottickedoff">[Name &quot;=&quot;]</span>
<span class="lineno">  337 </span><span class="spaces">                                                             </span><span class="nottickedoff">(Iden [fenceName (i+1) ,sourceAlias])) </span>
<span class="lineno">  338 </span><span class="spaces">                             </span><span class="nottickedoff">-- When one or both sides have no fenceTable, that is because of optimation of</span>
<span class="lineno">  339 </span><span class="spaces">                             </span><span class="nottickedoff">-- the SQL statement. Check the code of fenceTable for more details</span>
<span class="lineno">  340 </span><span class="spaces">                             </span><span class="nottickedoff">(Just _ , Nothing) -&gt; </span>
<span class="lineno">  341 </span><span class="spaces">                                  </span><span class="nottickedoff">case fenceExpr (i+1) of </span>
<span class="lineno">  342 </span><span class="spaces">                                    </span><span class="nottickedoff">EDcV _    -&gt; noConstraint  &quot;..;EDcV&quot;</span>
<span class="lineno">  343 </span><span class="spaces">                                    </span><span class="nottickedoff">EMp1 a _  -&gt; Just (BinOp (Iden [fenceName i,targetAlias])</span>
<span class="lineno">  344 </span><span class="spaces">                                                             </span><span class="nottickedoff">[Name &quot;=&quot;]</span>
<span class="lineno">  345 </span><span class="spaces">                                                             </span><span class="nottickedoff">(StringLit a))</span>
<span class="lineno">  346 </span><span class="spaces">                                    </span><span class="nottickedoff">(ECpl (EMp1 a _)) </span>
<span class="lineno">  347 </span><span class="spaces">                                              </span><span class="nottickedoff">-&gt; Just (BinOp (Iden [fenceName i,targetAlias])</span>
<span class="lineno">  348 </span><span class="spaces">                                                             </span><span class="nottickedoff">[Name &quot;&lt;&gt;&quot;]</span>
<span class="lineno">  349 </span><span class="spaces">                                                             </span><span class="nottickedoff">(StringLit a))</span>
<span class="lineno">  350 </span><span class="spaces">                                    </span><span class="nottickedoff">_         -&gt; fatal 251 &quot;there is no reason for having no fenceTable!&quot;</span>
<span class="lineno">  351 </span><span class="spaces">                             </span><span class="nottickedoff">(Nothing, Just _ ) -&gt;</span>
<span class="lineno">  352 </span><span class="spaces">                                  </span><span class="nottickedoff">case fenceExpr i of </span>
<span class="lineno">  353 </span><span class="spaces">                                    </span><span class="nottickedoff">EDcV _    -&gt; noConstraint  &quot;EDcV;..&quot;</span>
<span class="lineno">  354 </span><span class="spaces">                                    </span><span class="nottickedoff">EMp1 a _  -&gt; Just (BinOp (StringLit a)</span>
<span class="lineno">  355 </span><span class="spaces">                                                             </span><span class="nottickedoff">[Name &quot;=&quot;]</span>
<span class="lineno">  356 </span><span class="spaces">                                                             </span><span class="nottickedoff">(Iden [fenceName (i+1) ,sourceAlias]))</span>
<span class="lineno">  357 </span><span class="spaces">                                    </span><span class="nottickedoff">(ECpl (EMp1 a _)) </span>
<span class="lineno">  358 </span><span class="spaces">                                              </span><span class="nottickedoff">-&gt; Just (BinOp (StringLit a)</span>
<span class="lineno">  359 </span><span class="spaces">                                                             </span><span class="nottickedoff">[Name &quot;&lt;&gt;&quot;]</span>
<span class="lineno">  360 </span><span class="spaces">                                                             </span><span class="nottickedoff">(Iden [fenceName (i+1) ,sourceAlias]))</span>
<span class="lineno">  361 </span><span class="spaces">                                    </span><span class="nottickedoff">_         -&gt; fatal 258 &quot;there is no reason for having no fenceTable!&quot;</span>
<span class="lineno">  362 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  363 </span><span class="spaces">                             </span><span class="nottickedoff">(Nothing, Nothing) -&gt; </span>
<span class="lineno">  364 </span><span class="spaces">                                  </span><span class="nottickedoff">fatal 286 $ intercalate &quot;\n  &quot; $</span>
<span class="lineno">  365 </span><span class="spaces">                                     </span><span class="nottickedoff">[&quot;Can this happen? Here is a case to analyse: (i = &quot;++show i++&quot;)&quot;</span>
<span class="lineno">  366 </span><span class="spaces">                                     </span><span class="nottickedoff">, &quot;expr: &quot;++showADL expr</span>
<span class="lineno">  367 </span><span class="spaces">                                     </span><span class="nottickedoff">]++map show (zip (map (stringOfName . fenceName) [firstNr..]) es)</span>
<span class="lineno">  368 </span><span class="spaces">                          </span><span class="nottickedoff">where</span>
<span class="lineno">  369 </span><span class="spaces">                            </span><span class="nottickedoff">noConstraint str = Just $ BinOp x [Name &quot;=&quot;] x</span>
<span class="lineno">  370 </span><span class="spaces">                                     </span><span class="nottickedoff">where</span>
<span class="lineno">  371 </span><span class="spaces">                                       </span><span class="nottickedoff">x = StringLit (&quot;pole&quot;++show i++&quot;_&quot;++str)                       </span>
<span class="lineno">  372 </span><span class="spaces">                             </span><span class="nottickedoff"></span>
<span class="lineno">  373 </span><span class="spaces">                             </span><span class="nottickedoff"></span>
<span class="lineno">  374 </span><span class="spaces">                          </span><span class="nottickedoff"></span>
<span class="lineno">  375 </span><span class="spaces">                </span><span class="nottickedoff">in BQEComment [BlockComment $ &quot;case: (ECps es), with two or more elements in es.&quot;++showADL expr] $</span>
<span class="lineno">  376 </span><span class="spaces">                   </span><span class="nottickedoff">BSE { bseSrc = if source (head es) == ONE -- the first expression is V[ONE*someConcept]</span>
<span class="lineno">  377 </span><span class="spaces">                                  </span><span class="nottickedoff">then NumLit &quot;1&quot;</span>
<span class="lineno">  378 </span><span class="spaces">                                  </span><span class="nottickedoff">else Iden [fenceName firstNr,sourceAlias]</span>
<span class="lineno">  379 </span><span class="spaces">                       </span><span class="nottickedoff">, bseTrg = if target (last es) == ONE -- the last expression is V[someConcept*ONE]</span>
<span class="lineno">  380 </span><span class="spaces">                                  </span><span class="nottickedoff">then NumLit &quot;1&quot;</span>
<span class="lineno">  381 </span><span class="spaces">                                  </span><span class="nottickedoff">else Iden [fenceName lastNr, targetAlias]</span>
<span class="lineno">  382 </span><span class="spaces">                       </span><span class="nottickedoff">, bseTbl = catMaybes fences</span>
<span class="lineno">  383 </span><span class="spaces">                       </span><span class="nottickedoff">, bseWhr = case catMaybes polesConstraints of</span>
<span class="lineno">  384 </span><span class="spaces">                                    </span><span class="nottickedoff">[] -&gt; Nothing</span>
<span class="lineno">  385 </span><span class="spaces">                                    </span><span class="nottickedoff">cs -&gt; Just (conjunctSQL cs) </span>
<span class="lineno">  386 </span><span class="spaces">                       </span><span class="nottickedoff">}</span>
<span class="lineno">  387 </span><span class="spaces">    </span><span class="nottickedoff">(EFlp x) -&gt; flipped (selectExpr fSpec x)</span>
<span class="lineno">  388 </span><span class="spaces">                 </span><span class="nottickedoff">where </span>
<span class="lineno">  389 </span><span class="spaces">                   </span><span class="nottickedoff">flipped se =</span>
<span class="lineno">  390 </span><span class="spaces">                     </span><span class="nottickedoff">BQEComment [BlockComment (&quot;Flipped: &quot;++show x)] $</span>
<span class="lineno">  391 </span><span class="spaces">                        </span><span class="nottickedoff">case se of </span>
<span class="lineno">  392 </span><span class="spaces">                         </span><span class="nottickedoff">BSE{}  -&gt; BSE { bseSrc = bseTrg se</span>
<span class="lineno">  393 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseTrg = bseSrc se</span>
<span class="lineno">  394 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseTbl = bseTbl se</span>
<span class="lineno">  395 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseWhr = bseWhr se</span>
<span class="lineno">  396 </span><span class="spaces">                                       </span><span class="nottickedoff">}</span>
<span class="lineno">  397 </span><span class="spaces">                         </span><span class="nottickedoff">BCQE{} -&gt; BSE { bseSrc = Iden [targetAlias]</span>
<span class="lineno">  398 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseTrg = Iden [sourceAlias]</span>
<span class="lineno">  399 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseTbl = [toTableRef se `as` Name &quot;flipped&quot;] -- MySQL requires you to label the &quot;sub query&quot; instead of just leaving it like many other implementations.</span>
<span class="lineno">  400 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseWhr = Nothing</span>
<span class="lineno">  401 </span><span class="spaces">                                       </span><span class="nottickedoff">}</span>
<span class="lineno">  402 </span><span class="spaces">                         </span><span class="nottickedoff">(BQEComment c e) </span>
<span class="lineno">  403 </span><span class="spaces">                                </span><span class="nottickedoff">-&gt; case flipped e of</span>
<span class="lineno">  404 </span><span class="spaces">                                    </span><span class="nottickedoff">BQEComment (_:c') fe -&gt; BQEComment (c++c') fe</span>
<span class="lineno">  405 </span><span class="spaces">                                    </span><span class="nottickedoff">_ -&gt; fatal 309 &quot;A flipped expression will always start with the comment `Flipped: ...&quot;</span>
<span class="lineno">  406 </span><span class="spaces">    </span><span class="nottickedoff">(EMp1 atom _) -&gt; BQEComment [BlockComment &quot;case: EMp1 atom.&quot;] $</span>
<span class="lineno">  407 </span><span class="spaces">                     </span><span class="nottickedoff">BSE { bseSrc = sqlAtomQuote atom</span>
<span class="lineno">  408 </span><span class="spaces">                         </span><span class="nottickedoff">, bseTrg = sqlAtomQuote atom</span>
<span class="lineno">  409 </span><span class="spaces">                         </span><span class="nottickedoff">, bseTbl = []</span>
<span class="lineno">  410 </span><span class="spaces">                         </span><span class="nottickedoff">, bseWhr = Nothing</span>
<span class="lineno">  411 </span><span class="spaces">                         </span><span class="nottickedoff">}</span>
<span class="lineno">  412 </span><span class="spaces">    </span><span class="nottickedoff">(EDcV (Sign s t))    -&gt; </span>
<span class="lineno">  413 </span><span class="spaces">                 </span><span class="nottickedoff">let (psrc,fsrc) = (QName (name plug), QName (name fld))</span>
<span class="lineno">  414 </span><span class="spaces">                                     </span><span class="nottickedoff">where (plug,fld) = getConceptTableInfo fSpec s</span>
<span class="lineno">  415 </span><span class="spaces">                     </span><span class="nottickedoff">(ptgt,ftgt) = (QName (name plug), QName (name fld))</span>
<span class="lineno">  416 </span><span class="spaces">                                     </span><span class="nottickedoff">where (plug,fld) = getConceptTableInfo fSpec t</span>
<span class="lineno">  417 </span><span class="spaces">                 </span><span class="nottickedoff">in BQEComment [BlockComment $ &quot;case: (EDcV (Sign s t))   V[ \&quot;&quot;++show (Sign s t)++&quot;\&quot; ]&quot;] $</span>
<span class="lineno">  418 </span><span class="spaces">                    </span><span class="nottickedoff">case (s,t) of</span>
<span class="lineno">  419 </span><span class="spaces">                     </span><span class="nottickedoff">(ONE, ONE) -&gt; one</span>
<span class="lineno">  420 </span><span class="spaces">                     </span><span class="nottickedoff">(_  , ONE) -&gt; BSE { bseSrc = Iden [psrc, fsrc]</span>
<span class="lineno">  421 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseTrg = NumLit &quot;1&quot;</span>
<span class="lineno">  422 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseTbl = [TRSimple [psrc]]</span>
<span class="lineno">  423 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseWhr = Just (notNull (Iden [psrc, fsrc]))</span>
<span class="lineno">  424 </span><span class="spaces">                                                              </span><span class="nottickedoff"></span>
<span class="lineno">  425 </span><span class="spaces">                                       </span><span class="nottickedoff">}</span>
<span class="lineno">  426 </span><span class="spaces">                     </span><span class="nottickedoff">(ONE, _  ) -&gt; BSE { bseSrc = NumLit &quot;1&quot;</span>
<span class="lineno">  427 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseTrg = Iden [ptgt, ftgt]</span>
<span class="lineno">  428 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseTbl = [TRSimple [ptgt]]</span>
<span class="lineno">  429 </span><span class="spaces">                                       </span><span class="nottickedoff">, bseWhr = Just (notNull (Iden [ptgt, ftgt]))</span>
<span class="lineno">  430 </span><span class="spaces">                                       </span><span class="nottickedoff">}</span>
<span class="lineno">  431 </span><span class="spaces">                     </span><span class="nottickedoff">_     -&gt; BSE { bseSrc = Iden [first, fsrc]</span>
<span class="lineno">  432 </span><span class="spaces">                                  </span><span class="nottickedoff">, bseTrg = Iden [secnd, ftgt]</span>
<span class="lineno">  433 </span><span class="spaces">                                  </span><span class="nottickedoff">, bseTbl = [TRSimple [psrc] `as` first</span>
<span class="lineno">  434 </span><span class="spaces">                                             </span><span class="nottickedoff">,TRSimple [ptgt] `as` secnd]</span>
<span class="lineno">  435 </span><span class="spaces">                                  </span><span class="nottickedoff">, bseWhr = Just $ conjunctSQL</span>
<span class="lineno">  436 </span><span class="spaces">                                          </span><span class="nottickedoff">[notNull (Iden[first, fsrc]), notNull (Iden[secnd, ftgt])]</span>
<span class="lineno">  437 </span><span class="spaces">                                  </span><span class="nottickedoff">}</span>
<span class="lineno">  438 </span><span class="spaces">                                </span><span class="nottickedoff">where</span>
<span class="lineno">  439 </span><span class="spaces">                                  </span><span class="nottickedoff">first = Name &quot;fst&quot;</span>
<span class="lineno">  440 </span><span class="spaces">                                  </span><span class="nottickedoff">secnd = Name &quot;snd&quot;</span>
<span class="lineno">  441 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">  442 </span><span class="spaces">    </span><span class="nottickedoff">(EDcI c)             -&gt; case c of</span>
<span class="lineno">  443 </span><span class="spaces">                              </span><span class="nottickedoff">ONE -&gt;   BQEComment [BlockComment &quot;I[ONE]&quot;] $</span>
<span class="lineno">  444 </span><span class="spaces">                                       </span><span class="nottickedoff">BSE { bseSrc = NumLit &quot;1&quot;</span>
<span class="lineno">  445 </span><span class="spaces">                                           </span><span class="nottickedoff">, bseTrg = NumLit &quot;1&quot;</span>
<span class="lineno">  446 </span><span class="spaces">                                           </span><span class="nottickedoff">, bseTbl = []</span>
<span class="lineno">  447 </span><span class="spaces">                                           </span><span class="nottickedoff">, bseWhr = Nothing</span>
<span class="lineno">  448 </span><span class="spaces">                                           </span><span class="nottickedoff">}</span>
<span class="lineno">  449 </span><span class="spaces">                              </span><span class="nottickedoff">PlainConcept{} -&gt; </span>
<span class="lineno">  450 </span><span class="spaces">                                 </span><span class="nottickedoff">let cAtt = Iden [sqlAttConcept fSpec c]</span>
<span class="lineno">  451 </span><span class="spaces">                                 </span><span class="nottickedoff">in    BQEComment [BlockComment $ &quot;I[&quot;++name c++&quot;]&quot;] $</span>
<span class="lineno">  452 </span><span class="spaces">                                       </span><span class="nottickedoff">BSE { bseSrc = cAtt</span>
<span class="lineno">  453 </span><span class="spaces">                                           </span><span class="nottickedoff">, bseTrg = cAtt</span>
<span class="lineno">  454 </span><span class="spaces">                                           </span><span class="nottickedoff">, bseTbl = [sqlConceptTable fSpec c]</span>
<span class="lineno">  455 </span><span class="spaces">                                           </span><span class="nottickedoff">, bseWhr = Just (notNull cAtt)</span>
<span class="lineno">  456 </span><span class="spaces">                                           </span><span class="nottickedoff">}</span>
<span class="lineno">  457 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  458 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  459 </span><span class="spaces">    </span><span class="nottickedoff">-- EEps behaves like I. The intersects are semantically relevant, because all semantic irrelevant EEps expressions have been filtered from es.</span>
<span class="lineno">  460 </span><span class="spaces">    </span><span class="nottickedoff">(EEps c sgn)     -&gt; BQEComment [BlockComment $ &quot;epsilon &quot;++name c++&quot; &quot;++showSign sgn] $</span>
<span class="lineno">  461 </span><span class="spaces">                         </span><span class="nottickedoff">case c of -- select the population of the most specific concept, which is the source.</span>
<span class="lineno">  462 </span><span class="spaces">                              </span><span class="nottickedoff">ONE -&gt;   BSE { bseSrc = NumLit &quot;1&quot;</span>
<span class="lineno">  463 </span><span class="spaces">                                           </span><span class="nottickedoff">, bseTrg = NumLit &quot;1&quot;</span>
<span class="lineno">  464 </span><span class="spaces">                                           </span><span class="nottickedoff">, bseTbl = []</span>
<span class="lineno">  465 </span><span class="spaces">                                           </span><span class="nottickedoff">, bseWhr = Nothing</span>
<span class="lineno">  466 </span><span class="spaces">                                           </span><span class="nottickedoff">}</span>
<span class="lineno">  467 </span><span class="spaces">                              </span><span class="nottickedoff">PlainConcept{} -&gt; </span>
<span class="lineno">  468 </span><span class="spaces">                                 </span><span class="nottickedoff">let cAtt = sqlAttConcept fSpec c</span>
<span class="lineno">  469 </span><span class="spaces">                                 </span><span class="nottickedoff">in    BSE { bseSrc = Iden [cAtt]</span>
<span class="lineno">  470 </span><span class="spaces">                                           </span><span class="nottickedoff">, bseTrg = Iden [cAtt]</span>
<span class="lineno">  471 </span><span class="spaces">                                           </span><span class="nottickedoff">, bseTbl = [sqlConceptTable fSpec c]</span>
<span class="lineno">  472 </span><span class="spaces">                                           </span><span class="nottickedoff">, bseWhr = Just (notNull (Iden [cAtt]))</span>
<span class="lineno">  473 </span><span class="spaces">                                           </span><span class="nottickedoff">}</span>
<span class="lineno">  474 </span><span class="spaces">    </span><span class="nottickedoff">(EDcD d)             -&gt; selectDeclaration fSpec d</span>
<span class="lineno">  475 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  476 </span><span class="spaces">    </span><span class="nottickedoff">(EBrk e)             -&gt; selectExpr fSpec e</span>
<span class="lineno">  477 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  478 </span><span class="spaces">    </span><span class="nottickedoff">(ECpl e)</span>
<span class="lineno">  479 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; case e of</span>
<span class="lineno">  480 </span><span class="spaces">           </span><span class="nottickedoff">EDcV _        -&gt; emptySet</span>
<span class="lineno">  481 </span><span class="spaces">           </span><span class="nottickedoff">EDcI ONE      -&gt; fatal 254 &quot;EDcI ONE must not be seen at this place.&quot;</span>
<span class="lineno">  482 </span><span class="spaces">           </span><span class="nottickedoff">EDcI c        -&gt; BQEComment [BlockComment $ &quot;case: ECpl (EDcI &quot;++name c++&quot;)&quot;] $</span>
<span class="lineno">  483 </span><span class="spaces">                             </span><span class="nottickedoff">BSE { bseSrc = Iden [QName &quot;concept0&quot;, concpt]</span>
<span class="lineno">  484 </span><span class="spaces">                                 </span><span class="nottickedoff">, bseTrg = Iden [QName &quot;concept1&quot;, concpt]</span>
<span class="lineno">  485 </span><span class="spaces">                                 </span><span class="nottickedoff">, bseTbl = [sqlConceptTable fSpec c `as` QName &quot;concept0&quot;</span>
<span class="lineno">  486 </span><span class="spaces">                                            </span><span class="nottickedoff">,sqlConceptTable fSpec c `as` QName &quot;concept1&quot;</span>
<span class="lineno">  487 </span><span class="spaces">                                            </span><span class="nottickedoff">]</span>
<span class="lineno">  488 </span><span class="spaces">                                 </span><span class="nottickedoff">, bseWhr = Just (BinOp (Iden [QName &quot;concept0&quot;, concpt])</span>
<span class="lineno">  489 </span><span class="spaces">                                                        </span><span class="nottickedoff">[Name &quot;&lt;&gt;&quot;]</span>
<span class="lineno">  490 </span><span class="spaces">                                                        </span><span class="nottickedoff">(Iden [QName &quot;concept1&quot;, concpt])</span>
<span class="lineno">  491 </span><span class="spaces">                                                 </span><span class="nottickedoff">)</span>
<span class="lineno">  492 </span><span class="spaces">                                 </span><span class="nottickedoff">}</span>
<span class="lineno">  493 </span><span class="spaces">                             </span><span class="nottickedoff">where concpt = sqlAttConcept fSpec c</span>
<span class="lineno">  494 </span><span class="spaces">           </span><span class="nottickedoff">_ | otherwise       -&gt; BQEComment (map BlockComment [ &quot;case: ECpl e&quot;, &quot;ECpl ( \&quot;&quot;++showADL e++&quot;\&quot; )&quot;]) $</span>
<span class="lineno">  495 </span><span class="spaces">                                  </span><span class="nottickedoff">BSE { bseSrc = Iden [closedWorldName,sourceAlias]</span>
<span class="lineno">  496 </span><span class="spaces">                                      </span><span class="nottickedoff">, bseTrg = Iden [closedWorldName,targetAlias]</span>
<span class="lineno">  497 </span><span class="spaces">                                      </span><span class="nottickedoff">, bseTbl = [(toTableRef . selectExpr fSpec) theClosedWorldExpression `as` closedWorldName]</span>
<span class="lineno">  498 </span><span class="spaces">                                      </span><span class="nottickedoff">, bseWhr = Just $ selectNotExists </span>
<span class="lineno">  499 </span><span class="spaces">                                                          </span><span class="nottickedoff">(toTableRef (selectExpr fSpec e) `as` posName) </span>
<span class="lineno">  500 </span><span class="spaces">                                                                      </span><span class="nottickedoff">(Just . conjunctSQL $ </span>
<span class="lineno">  501 </span><span class="spaces">                                                                         </span><span class="nottickedoff">[BinOp (Iden [closedWorldName,sourceAlias])</span>
<span class="lineno">  502 </span><span class="spaces">                                                                                </span><span class="nottickedoff">[Name &quot;=&quot;]</span>
<span class="lineno">  503 </span><span class="spaces">                                                                                </span><span class="nottickedoff">(Iden [posName,sourceAlias])</span>
<span class="lineno">  504 </span><span class="spaces">                                                                         </span><span class="nottickedoff">,BinOp (Iden [closedWorldName,targetAlias])</span>
<span class="lineno">  505 </span><span class="spaces">                                                                                </span><span class="nottickedoff">[Name &quot;=&quot;]</span>
<span class="lineno">  506 </span><span class="spaces">                                                                                </span><span class="nottickedoff">(Iden [posName,targetAlias])</span>
<span class="lineno">  507 </span><span class="spaces">                                                                         </span><span class="nottickedoff">]</span>
<span class="lineno">  508 </span><span class="spaces">                                                                      </span><span class="nottickedoff">)</span>
<span class="lineno">  509 </span><span class="spaces">                                      </span><span class="nottickedoff">}</span>
<span class="lineno">  510 </span><span class="spaces">              </span><span class="nottickedoff">where posName = Name &quot;pos&quot;</span>
<span class="lineno">  511 </span><span class="spaces">                    </span><span class="nottickedoff">closedWorldName = QName (&quot;cartesian product of &quot;++plur (source e) ++ &quot; and &quot; ++ plur (target e)) </span>
<span class="lineno">  512 </span><span class="spaces">                                       </span><span class="nottickedoff"></span>
<span class="lineno">  513 </span><span class="spaces">                          </span><span class="nottickedoff">where plur c = plural (fsLang fSpec) (name c)</span>
<span class="lineno">  514 </span><span class="spaces">                    </span><span class="nottickedoff">theClosedWorldExpression = EDcV (sign e) </span>
<span class="lineno">  515 </span><span class="spaces">                        </span><span class="nottickedoff"></span>
<span class="lineno">  516 </span><span class="spaces">    </span><span class="nottickedoff">EKl0 _               -&gt; fatal 249 &quot;SQL cannot create closures EKl0 (`SELECT * FROM NotExistingKl0`)&quot;</span>
<span class="lineno">  517 </span><span class="spaces">    </span><span class="nottickedoff">EKl1 _               -&gt; fatal 249 &quot;SQL cannot create closures EKl1 (`SELECT * FROM NotExistingKl1`)&quot;</span>
<span class="lineno">  518 </span><span class="spaces">    </span><span class="nottickedoff">(EDif (EDcV _,x)) -&gt; BQEComment [BlockComment $ &quot;case: EDif V x&quot;++&quot;EDif V ( \&quot;&quot;++showADL x++&quot;\&quot; ) \&quot;&quot;++show (sign expr)++&quot;\&quot;&quot;]</span>
<span class="lineno">  519 </span><span class="spaces">                                    </span><span class="nottickedoff">(selectExpr fSpec (notCpl x))</span>
<span class="lineno">  520 </span><span class="spaces"></span><span class="nottickedoff">-- The following definitions express code generation of the remaining cases in terms of the previously defined generators.</span>
<span class="lineno">  521 </span><span class="spaces"></span><span class="nottickedoff">-- As a result of this way of working, code generated for =, |-, -, !, *, \, and / may not be efficient, but at least it is correct.</span>
<span class="lineno">  522 </span><span class="spaces">    </span><span class="nottickedoff">EEqu (l,r)</span>
<span class="lineno">  523 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; BQEComment [BlockComment $ &quot;case: EEqu (l,r)&quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;] $</span>
<span class="lineno">  524 </span><span class="spaces">         </span><span class="nottickedoff">selectExpr fSpec ((ECpl l .\/. r) ./\. (ECpl r .\/. l))</span>
<span class="lineno">  525 </span><span class="spaces">    </span><span class="nottickedoff">EImp (l,r)</span>
<span class="lineno">  526 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; BQEComment [BlockComment $ &quot;case: EImp (l,r)&quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;] $</span>
<span class="lineno">  527 </span><span class="spaces">         </span><span class="nottickedoff">selectExpr fSpec (ECpl l .\/. r)</span>
<span class="lineno">  528 </span><span class="spaces">    </span><span class="nottickedoff">EDif (l,r)</span>
<span class="lineno">  529 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; BQEComment [BlockComment $ &quot;case: EDif (l,r)&quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;] $</span>
<span class="lineno">  530 </span><span class="spaces">         </span><span class="nottickedoff">selectExpr fSpec (l ./\. ECpl r)</span>
<span class="lineno">  531 </span><span class="spaces">    </span><span class="nottickedoff">ERrs (l,r) -- The right residual l\r is defined by: for all x,y:   x(l\r)y  &lt;=&gt;  for all z in X, z l x implies z r y.</span>
<span class="lineno">  532 </span><span class="spaces"></span><span class="nottickedoff">{- In order to obtain an SQL-query, we make a Haskell derivation of the right residual:</span>
<span class="lineno">  533 </span><span class="spaces">             </span><span class="nottickedoff">and [    (z,x)    `elem` contents l -&gt; (z,y) `elem` contents r  | z&lt;-contents (source l)]</span>
<span class="lineno">  534 </span><span class="spaces">   </span><span class="nottickedoff">=</span>
<span class="lineno">  535 </span><span class="spaces">             </span><span class="nottickedoff">and [    (z,x) `notElem` contents l || (z,y) `elem` contents r  | z&lt;-contents (source l)]</span>
<span class="lineno">  536 </span><span class="spaces">   </span><span class="nottickedoff">=</span>
<span class="lineno">  537 </span><span class="spaces">        </span><span class="nottickedoff">not ( or [not((z,x) `notElem` contents l || (z,y) `elem` contents r) | z&lt;-contents (source l)])</span>
<span class="lineno">  538 </span><span class="spaces">   </span><span class="nottickedoff">=</span>
<span class="lineno">  539 </span><span class="spaces">        </span><span class="nottickedoff">not ( or [    (z,x)  `elem` contents l &amp;&amp; (z,y) `notElem` contents r | z&lt;-contents (source l)])</span>
<span class="lineno">  540 </span><span class="spaces">   </span><span class="nottickedoff">=</span>
<span class="lineno">  541 </span><span class="spaces">        </span><span class="nottickedoff">null [ () | z&lt;-contents (source l), (z,x)  `elem` contents l &amp;&amp; (z,y) `notElem` contents r]</span>
<span class="lineno">  542 </span><span class="spaces">   </span><span class="nottickedoff">=</span>
<span class="lineno">  543 </span><span class="spaces">        </span><span class="nottickedoff">null [ () | z&lt;-contents (source l), (z,x)  `elem` contents l, (z,y) `notElem` contents r]</span>
<span class="lineno">  544 </span><span class="spaces">   </span><span class="nottickedoff">=</span>
<span class="lineno">  545 </span><span class="spaces">        </span><span class="nottickedoff">null [ () | (z,x') &lt;- contents l, x==x', (z,y) `notElem` contents r ]</span>
<span class="lineno">  546 </span><span class="spaces">   </span><span class="nottickedoff">=</span>
<span class="lineno">  547 </span><span class="spaces">        </span><span class="nottickedoff">null [ () | (z,x') &lt;- contents l, x==x' &amp;&amp; (z,y) `notElem` contents r ]</span>
<span class="lineno">  548 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  549 </span><span class="spaces"></span><span class="nottickedoff">Based on this derivation:</span>
<span class="lineno">  550 </span><span class="spaces">  </span><span class="nottickedoff">contents (l\r)</span>
<span class="lineno">  551 </span><span class="spaces">    </span><span class="nottickedoff">= [(x,y) | x&lt;-contents (target l), y&lt;-contents (target r)</span>
<span class="lineno">  552 </span><span class="spaces">             </span><span class="nottickedoff">, null [ () | (z,x') &lt;- contents l, x==x', (z,y) `notElem` contents r ]</span>
<span class="lineno">  553 </span><span class="spaces">             </span><span class="nottickedoff">]</span>
<span class="lineno">  554 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno">  555 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; let rResiduClause</span>
<span class="lineno">  556 </span><span class="spaces">              </span><span class="nottickedoff">| target l == ONE = fatal 332 (&quot;ONE is unexpected as target of &quot;++showADL l)</span>
<span class="lineno">  557 </span><span class="spaces">              </span><span class="nottickedoff">| target r == ONE = fatal 333 (&quot;ONE is unexpected as target of &quot;++showADL r)</span>
<span class="lineno">  558 </span><span class="spaces">              </span><span class="nottickedoff">| otherwise</span>
<span class="lineno">  559 </span><span class="spaces">                  </span><span class="nottickedoff">= BSE { bseSrc = Iden [ resLeft, mainSrc]</span>
<span class="lineno">  560 </span><span class="spaces">                        </span><span class="nottickedoff">, bseTrg = Iden [ resRight, mainTgt]</span>
<span class="lineno">  561 </span><span class="spaces">                        </span><span class="nottickedoff">, bseTbl = [sqlConceptTable fSpec (target l) `as` resLeft</span>
<span class="lineno">  562 </span><span class="spaces">                                  </span><span class="nottickedoff">,sqlConceptTable fSpec (target r) `as` resRight]</span>
<span class="lineno">  563 </span><span class="spaces">                        </span><span class="nottickedoff">, bseWhr = Just . VEComment [BlockComment $ &quot;Left hand side: &quot;++showADL l] $ </span>
<span class="lineno">  564 </span><span class="spaces">                                          </span><span class="nottickedoff">selectNotExists </span>
<span class="lineno">  565 </span><span class="spaces">                                            </span><span class="nottickedoff">(lCode `as` lhs)</span>
<span class="lineno">  566 </span><span class="spaces">                                            </span><span class="nottickedoff">( Just $ conjunctSQL</span>
<span class="lineno">  567 </span><span class="spaces">                                                </span><span class="nottickedoff">[BinOp (Iden [resLeft,mainSrc])</span>
<span class="lineno">  568 </span><span class="spaces">                                                       </span><span class="nottickedoff">[Name &quot;=&quot;]</span>
<span class="lineno">  569 </span><span class="spaces">                                                       </span><span class="nottickedoff">(Iden [lhs,targetAlias])</span>
<span class="lineno">  570 </span><span class="spaces">                                                </span><span class="nottickedoff">,VEComment [BlockComment $ &quot;Right hand side: &quot;++showADL r] $ </span>
<span class="lineno">  571 </span><span class="spaces">                                                 </span><span class="nottickedoff">selectNotExists </span>
<span class="lineno">  572 </span><span class="spaces">                                                   </span><span class="nottickedoff">(rCode `as` rhs)</span>
<span class="lineno">  573 </span><span class="spaces">                                                   </span><span class="nottickedoff">( Just $ conjunctSQL </span>
<span class="lineno">  574 </span><span class="spaces">                                                      </span><span class="nottickedoff">[BinOp (Iden [rhs,sourceAlias])</span>
<span class="lineno">  575 </span><span class="spaces">                                                             </span><span class="nottickedoff">[Name &quot;=&quot;]</span>
<span class="lineno">  576 </span><span class="spaces">                                                             </span><span class="nottickedoff">(Iden [lhs,sourceAlias])</span>
<span class="lineno">  577 </span><span class="spaces">                                                      </span><span class="nottickedoff">,BinOp (Iden [rhs,targetAlias])</span>
<span class="lineno">  578 </span><span class="spaces">                                                             </span><span class="nottickedoff">[Name &quot;=&quot;]</span>
<span class="lineno">  579 </span><span class="spaces">                                                             </span><span class="nottickedoff">(Iden [resRight,mainTgt])</span>
<span class="lineno">  580 </span><span class="spaces">                                                      </span><span class="nottickedoff">]</span>
<span class="lineno">  581 </span><span class="spaces">                                                   </span><span class="nottickedoff">)</span>
<span class="lineno">  582 </span><span class="spaces">                                                </span><span class="nottickedoff">]</span>
<span class="lineno">  583 </span><span class="spaces">                                            </span><span class="nottickedoff">) </span>
<span class="lineno">  584 </span><span class="spaces">                        </span><span class="nottickedoff">}</span>
<span class="lineno">  585 </span><span class="spaces">             </span><span class="nottickedoff">mainSrc = (sqlAttConcept fSpec.target) l  -- Note: this 'target' is not an error!!! It is part of the definition of right residu</span>
<span class="lineno">  586 </span><span class="spaces">             </span><span class="nottickedoff">mainTgt = (sqlAttConcept fSpec.target) r</span>
<span class="lineno">  587 </span><span class="spaces">             </span><span class="nottickedoff">resLeft  = Name &quot;RResLeft&quot;</span>
<span class="lineno">  588 </span><span class="spaces">             </span><span class="nottickedoff">resRight = Name &quot;RResRight&quot;</span>
<span class="lineno">  589 </span><span class="spaces">             </span><span class="nottickedoff">lhs  = Name &quot;lhs&quot;</span>
<span class="lineno">  590 </span><span class="spaces">             </span><span class="nottickedoff">rhs  = Name &quot;rhs&quot;</span>
<span class="lineno">  591 </span><span class="spaces">             </span><span class="nottickedoff">lCode = toTableRef $ selectExpr fSpec l -- selectExprInFROM fSpec sourceAlias targetAlias l</span>
<span class="lineno">  592 </span><span class="spaces">             </span><span class="nottickedoff">rCode = toTableRef $ selectExpr fSpec r -- selectExprInFROM fSpec sourceAlias targetAlias r</span>
<span class="lineno">  593 </span><span class="spaces">         </span><span class="nottickedoff">in BQEComment [BlockComment $ &quot;case: ERrs (l,r)&quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;]</span>
<span class="lineno">  594 </span><span class="spaces">                         </span><span class="nottickedoff">rResiduClause</span>
<span class="lineno">  595 </span><span class="spaces">    </span><span class="nottickedoff">ELrs (l,r)</span>
<span class="lineno">  596 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; BQEComment [BlockComment $ &quot;case: ELrs (l,r)&quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;] $</span>
<span class="lineno">  597 </span><span class="spaces">         </span><span class="nottickedoff">selectExpr fSpec (EFlp (flp r .\. flp l))</span>
<span class="lineno">  598 </span><span class="spaces">    </span><span class="nottickedoff">EDia (l,r)</span>
<span class="lineno">  599 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; BQEComment [BlockComment $ &quot;case: EDia (l,r)&quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;] $</span>
<span class="lineno">  600 </span><span class="spaces">         </span><span class="nottickedoff">selectExpr fSpec ((flp l .\. r) ./\. (l ./. flp r))</span>
<span class="lineno">  601 </span><span class="spaces">    </span><span class="nottickedoff">ERad{}</span>
<span class="lineno">  602 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; BQEComment [BlockComment $ &quot;case: ERad (l,r)&quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;] $</span>
<span class="lineno">  603 </span><span class="spaces">        </span><span class="nottickedoff">selectExpr fSpec (deMorganERad expr)</span>
<span class="lineno">  604 </span><span class="spaces">    </span><span class="nottickedoff">EPrd (l,r)</span>
<span class="lineno">  605 </span><span class="spaces">     </span><span class="nottickedoff">-&gt; let v = EDcV (Sign (target l) (source r))</span>
<span class="lineno">  606 </span><span class="spaces">        </span><span class="nottickedoff">in BQEComment [BlockComment $ &quot;case: EPrd (l,r)&quot;++showADL expr++&quot; (&quot;++show (sign expr)++&quot;)&quot;] $</span>
<span class="lineno">  607 </span><span class="spaces">           </span><span class="nottickedoff">selectExpr fSpec (foldr1 (.:.) [l,v,r])</span></span>
<span class="lineno">  608 </span>
<span class="lineno">  609 </span>
<span class="lineno">  610 </span>
<span class="lineno">  611 </span>
<span class="lineno">  612 </span>toTableRef :: BinQueryExpr -&gt; TableRef
<span class="lineno">  613 </span><span class="decl"><span class="nottickedoff">toTableRef = TRQueryExpr . toSQL</span></span>
<span class="lineno">  614 </span>     
<span class="lineno">  615 </span>
<span class="lineno">  616 </span>selectDeclaration :: FSpec -&gt; Declaration -&gt; BinQueryExpr
<span class="lineno">  617 </span><span class="decl"><span class="nottickedoff">selectDeclaration fSpec dcl =</span>
<span class="lineno">  618 </span><span class="spaces">  </span><span class="nottickedoff">case dcl of</span>
<span class="lineno">  619 </span><span class="spaces">    </span><span class="nottickedoff">Sgn{}  -&gt; leafCode (getDeclarationTableInfo fSpec dcl)</span>
<span class="lineno">  620 </span><span class="spaces">    </span><span class="nottickedoff">Isn{}  -&gt; let (plug, c) = getConceptTableInfo fSpec (detyp dcl)</span>
<span class="lineno">  621 </span><span class="spaces">              </span><span class="nottickedoff">in leafCode (plug, c, c)</span>
<span class="lineno">  622 </span><span class="spaces">    </span><span class="nottickedoff">Vs sgn</span>
<span class="lineno">  623 </span><span class="spaces">     </span><span class="nottickedoff">| source sgn == ONE -&gt; fatal 468 &quot;ONE is not expected at this place&quot;</span>
<span class="lineno">  624 </span><span class="spaces">     </span><span class="nottickedoff">| target sgn == ONE -&gt; fatal 469 &quot;ONE is not expected at this place&quot;</span>
<span class="lineno">  625 </span><span class="spaces">     </span><span class="nottickedoff">| otherwise</span>
<span class="lineno">  626 </span><span class="spaces">           </span><span class="nottickedoff">-&gt; let src,trg :: ValueExpr</span>
<span class="lineno">  627 </span><span class="spaces">                  </span><span class="nottickedoff">src=Iden [Name &quot;vfst&quot;, sqlAttConcept fSpec (source sgn)]</span>
<span class="lineno">  628 </span><span class="spaces">                  </span><span class="nottickedoff">trg=Iden [Name &quot;vsnd&quot;, sqlAttConcept fSpec (target sgn)]</span>
<span class="lineno">  629 </span><span class="spaces">              </span><span class="nottickedoff">in BSE { bseSrc = src</span>
<span class="lineno">  630 </span><span class="spaces">                     </span><span class="nottickedoff">, bseTrg = trg</span>
<span class="lineno">  631 </span><span class="spaces">                     </span><span class="nottickedoff">, bseTbl = [sqlConceptTable fSpec (source sgn) `as` Name &quot;vfst&quot;</span>
<span class="lineno">  632 </span><span class="spaces">                                </span><span class="nottickedoff">,sqlConceptTable fSpec (target sgn) `as` Name &quot;vsnd&quot;]</span>
<span class="lineno">  633 </span><span class="spaces">                     </span><span class="nottickedoff">, bseWhr = Just (conjunctSQL (map notNull [src,trg]))</span>
<span class="lineno">  634 </span><span class="spaces">                     </span><span class="nottickedoff">}</span>
<span class="lineno">  635 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno">  636 </span><span class="spaces">     </span><span class="nottickedoff">leafCode :: (PlugSQL,SqlField,SqlField) -&gt; BinQueryExpr</span>
<span class="lineno">  637 </span><span class="spaces">     </span><span class="nottickedoff">leafCode (plug,s,t) </span>
<span class="lineno">  638 </span><span class="spaces">         </span><span class="nottickedoff">= BSE { bseSrc = Iden [QName (name s)]</span>
<span class="lineno">  639 </span><span class="spaces">               </span><span class="nottickedoff">, bseTrg = Iden [QName (name t)]</span>
<span class="lineno">  640 </span><span class="spaces">               </span><span class="nottickedoff">, bseTbl = [TRSimple [QName (name plug)]]</span>
<span class="lineno">  641 </span><span class="spaces">               </span><span class="nottickedoff">, bseWhr = if mayContainNulls plug</span>
<span class="lineno">  642 </span><span class="spaces">                          </span><span class="nottickedoff">then Just . conjunctSQL . map notNull $</span>
<span class="lineno">  643 </span><span class="spaces">                                </span><span class="nottickedoff">[Iden [QName (name c)] | c&lt;-nub [s,t]]</span>
<span class="lineno">  644 </span><span class="spaces">                          </span><span class="nottickedoff">else Nothing</span>
<span class="lineno">  645 </span><span class="spaces">               </span><span class="nottickedoff">}</span>
<span class="lineno">  646 </span><span class="spaces">      </span><span class="nottickedoff">where mayContainNulls TblSQL{} = True</span>
<span class="lineno">  647 </span><span class="spaces">            </span><span class="nottickedoff">mayContainNulls _        = False</span></span>
<span class="lineno">  648 </span>
<span class="lineno">  649 </span>
<span class="lineno">  650 </span>isNotIn :: ValueExpr -&gt; QueryExpr -&gt; ValueExpr
<span class="lineno">  651 </span><span class="decl"><span class="nottickedoff">isNotIn value = In False value . InQueryExpr</span></span> 
<span class="lineno">  652 </span>-- | select only the source of a binary expression
<span class="lineno">  653 </span>selectSource :: BinQueryExpr -&gt; QueryExpr
<span class="lineno">  654 </span><span class="decl"><span class="nottickedoff">selectSource = selectSorT sourceAlias</span></span>
<span class="lineno">  655 </span>
<span class="lineno">  656 </span>selectSorT :: Name -&gt; BinQueryExpr -&gt; QueryExpr
<span class="lineno">  657 </span><span class="decl"><span class="nottickedoff">selectSorT att binExp =</span>
<span class="lineno">  658 </span><span class="spaces">     </span><span class="nottickedoff">Select { qeSetQuantifier = SQDefault</span>
<span class="lineno">  659 </span><span class="spaces">            </span><span class="nottickedoff">, qeSelectList    = [(Iden [att],Nothing)]   </span>
<span class="lineno">  660 </span><span class="spaces">            </span><span class="nottickedoff">, qeFrom          = [TRQueryExpr (toSQL binExp) `as` att]</span>
<span class="lineno">  661 </span><span class="spaces">            </span><span class="nottickedoff">, qeWhere         = Nothing</span>
<span class="lineno">  662 </span><span class="spaces">            </span><span class="nottickedoff">, qeGroupBy       = []</span>
<span class="lineno">  663 </span><span class="spaces">            </span><span class="nottickedoff">, qeHaving        = Nothing</span>
<span class="lineno">  664 </span><span class="spaces">            </span><span class="nottickedoff">, qeOrderBy       = []</span>
<span class="lineno">  665 </span><span class="spaces">            </span><span class="nottickedoff">, qeOffset        = Nothing</span>
<span class="lineno">  666 </span><span class="spaces">            </span><span class="nottickedoff">, qeFetchFirst    = Nothing</span>
<span class="lineno">  667 </span><span class="spaces">            </span><span class="nottickedoff">}</span></span> 
<span class="lineno">  668 </span>
<span class="lineno">  669 </span>selectExists, selectNotExists
<span class="lineno">  670 </span>     :: TableRef        -- ^ tables
<span class="lineno">  671 </span>     -&gt; Maybe ValueExpr -- ^ the (optional) WHERE clause
<span class="lineno">  672 </span>     -&gt; ValueExpr
<span class="lineno">  673 </span><span class="decl"><span class="nottickedoff">selectNotExists tbl whr = PrefixOp [Name &quot;NOT&quot;] $ selectExists tbl whr</span></span>
<span class="lineno">  674 </span><span class="decl"><span class="nottickedoff">selectExists tbl whr = </span>
<span class="lineno">  675 </span><span class="spaces">  </span><span class="nottickedoff">SubQueryExpr SqExists</span>
<span class="lineno">  676 </span><span class="spaces">     </span><span class="nottickedoff">Select { qeSetQuantifier = SQDefault</span>
<span class="lineno">  677 </span><span class="spaces">            </span><span class="nottickedoff">, qeSelectList    = [(Star,Nothing)]   </span>
<span class="lineno">  678 </span><span class="spaces">            </span><span class="nottickedoff">, qeFrom          = [case tbl of </span>
<span class="lineno">  679 </span><span class="spaces">                                   </span><span class="nottickedoff">TRAlias{} -&gt; tbl</span>
<span class="lineno">  680 </span><span class="spaces">                                   </span><span class="nottickedoff">_  -&gt; tbl `as` Name &quot;aDummyName&quot; -- MySQL requires you to label the &quot;sub query&quot; instead of just leaving it like many other implementations.</span>
<span class="lineno">  681 </span><span class="spaces">                                </span><span class="nottickedoff">]</span>
<span class="lineno">  682 </span><span class="spaces">            </span><span class="nottickedoff">, qeWhere         = whr</span>
<span class="lineno">  683 </span><span class="spaces">            </span><span class="nottickedoff">, qeGroupBy       = []</span>
<span class="lineno">  684 </span><span class="spaces">            </span><span class="nottickedoff">, qeHaving        = Nothing</span>
<span class="lineno">  685 </span><span class="spaces">            </span><span class="nottickedoff">, qeOrderBy       = []</span>
<span class="lineno">  686 </span><span class="spaces">            </span><span class="nottickedoff">, qeOffset        = Nothing</span>
<span class="lineno">  687 </span><span class="spaces">            </span><span class="nottickedoff">, qeFetchFirst    = Nothing</span>
<span class="lineno">  688 </span><span class="spaces">            </span><span class="nottickedoff">}</span></span>
<span class="lineno">  689 </span>
<span class="lineno">  690 </span>-- | a (local) data structure to hold SQL info for binary expressions
<span class="lineno">  691 </span>data BinQueryExpr = BSE  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bseSrc</span></span></span> :: ValueExpr       -- ^ source field and table
<span class="lineno">  692 </span>                         , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bseTrg</span></span></span> :: ValueExpr       -- ^ target field and table
<span class="lineno">  693 </span>                         , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bseTbl</span></span></span> :: [TableRef]      -- ^ tables
<span class="lineno">  694 </span>                         , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bseWhr</span></span></span> :: Maybe ValueExpr -- ^ the (optional) WHERE clause
<span class="lineno">  695 </span>                         }
<span class="lineno">  696 </span>                  | BCQE { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bcqeOper</span></span></span> :: CombineOp     -- ^ The combine operator 
<span class="lineno">  697 </span>                         , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bcqe0</span></span></span> ::    BinQueryExpr  -- ^ Left  expression
<span class="lineno">  698 </span>                         , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bcqe1</span></span></span> ::    BinQueryExpr  -- ^ Right expression
<span class="lineno">  699 </span>                         }
<span class="lineno">  700 </span>                  | BQEComment [Comment] BinQueryExpr
<span class="lineno">  701 </span>                               
<span class="lineno">  702 </span>                        
<span class="lineno">  703 </span>toSQL :: BinQueryExpr -&gt; QueryExpr
<span class="lineno">  704 </span><span class="decl"><span class="nottickedoff">toSQL bqe </span>
<span class="lineno">  705 </span><span class="spaces"> </span><span class="nottickedoff">= case bqe of</span>
<span class="lineno">  706 </span><span class="spaces">    </span><span class="nottickedoff">BSE{} -&gt; Select { qeSetQuantifier = Distinct</span>
<span class="lineno">  707 </span><span class="spaces">                    </span><span class="nottickedoff">, qeSelectList    = [ (bseSrc bqe, Just sourceAlias)</span>
<span class="lineno">  708 </span><span class="spaces">                                        </span><span class="nottickedoff">, (bseTrg bqe, Just targetAlias)]</span>
<span class="lineno">  709 </span><span class="spaces">                    </span><span class="nottickedoff">, qeFrom          = bseTbl bqe</span>
<span class="lineno">  710 </span><span class="spaces">                    </span><span class="nottickedoff">, qeWhere         = bseWhr bqe</span>
<span class="lineno">  711 </span><span class="spaces">                    </span><span class="nottickedoff">, qeGroupBy       = []</span>
<span class="lineno">  712 </span><span class="spaces">                    </span><span class="nottickedoff">, qeHaving        = Nothing</span>
<span class="lineno">  713 </span><span class="spaces">                    </span><span class="nottickedoff">, qeOrderBy       = []</span>
<span class="lineno">  714 </span><span class="spaces">                    </span><span class="nottickedoff">, qeOffset        = Nothing</span>
<span class="lineno">  715 </span><span class="spaces">                    </span><span class="nottickedoff">, qeFetchFirst    = Nothing</span>
<span class="lineno">  716 </span><span class="spaces">                    </span><span class="nottickedoff">}</span>
<span class="lineno">  717 </span><span class="spaces">    </span><span class="nottickedoff">BCQE{} -&gt; CombineQueryExpr </span>
<span class="lineno">  718 </span><span class="spaces">                    </span><span class="nottickedoff">{ qe0 = toSQL (bcqe0 bqe)</span>
<span class="lineno">  719 </span><span class="spaces">                    </span><span class="nottickedoff">, qeCombOp = bcqeOper bqe</span>
<span class="lineno">  720 </span><span class="spaces">                    </span><span class="nottickedoff">, qeSetQuantifier = SQDefault</span>
<span class="lineno">  721 </span><span class="spaces">                    </span><span class="nottickedoff">, qeCorresponding = Respectively  -- ??? What does this mean?</span>
<span class="lineno">  722 </span><span class="spaces">                    </span><span class="nottickedoff">, qe1 = toSQL (bcqe1 bqe)</span>
<span class="lineno">  723 </span><span class="spaces">                    </span><span class="nottickedoff">}</span>
<span class="lineno">  724 </span><span class="spaces">    </span><span class="nottickedoff">(BQEComment c (BQEComment c' e)) -&gt; toSQL $ BQEComment (c++c') e</span>
<span class="lineno">  725 </span><span class="spaces">    </span><span class="nottickedoff">(BQEComment c e) -&gt; QEComment c (toSQL e)</span></span>
<span class="lineno">  726 </span>    
<span class="lineno">  727 </span>sqlConceptTable :: FSpec -&gt; A_Concept -&gt; TableRef
<span class="lineno">  728 </span><span class="decl"><span class="nottickedoff">sqlConceptTable fSpec a = TRSimple [sqlConcept fSpec a]</span></span>
<span class="lineno">  729 </span>
<span class="lineno">  730 </span>-- sqlConcept gives the name of the plug that contains all atoms of A_Concept c.
<span class="lineno">  731 </span>sqlConcept :: FSpec -&gt; A_Concept -&gt; Name
<span class="lineno">  732 </span><span class="decl"><span class="nottickedoff">sqlConcept fSpec = QName . name . sqlConceptPlug fSpec</span></span>
<span class="lineno">  733 </span>-- sqlConcept yields the plug that contains all atoms of A_Concept c. Since there may be more of them, the first one is returned.
<span class="lineno">  734 </span>sqlConceptPlug :: FSpec -&gt; A_Concept -&gt; PlugSQL
<span class="lineno">  735 </span><span class="decl"><span class="nottickedoff">sqlConceptPlug fSpec c | c==ONE = fatal 583 &quot;A_Concept ONE may not be represented in SQL.&quot;</span>
<span class="lineno">  736 </span><span class="spaces">                       </span><span class="nottickedoff">| otherwise</span>
<span class="lineno">  737 </span><span class="spaces">             </span><span class="nottickedoff">= if null ps then fatal 585 $ &quot;A_Concept \&quot;&quot;++show c++&quot;\&quot; does not occur in fSpec.&quot; else</span>
<span class="lineno">  738 </span><span class="spaces">               </span><span class="nottickedoff">head ps</span>
<span class="lineno">  739 </span><span class="spaces">               </span><span class="nottickedoff">where ps = [plug |InternalPlug plug&lt;-plugInfos fSpec</span>
<span class="lineno">  740 </span><span class="spaces">                                </span><span class="nottickedoff">, not (null (case plug of ScalarSQL{} -&gt; [c |c==cLkp plug]; _ -&gt; [c' |(c',_)&lt;-cLkpTbl plug, c'==c]))]</span></span>
<span class="lineno">  741 </span>
<span class="lineno">  742 </span>sqlAttConcept :: FSpec -&gt; A_Concept -&gt; Name
<span class="lineno">  743 </span><span class="decl"><span class="nottickedoff">sqlAttConcept fSpec c | c==ONE = QName &quot;ONE&quot;</span>
<span class="lineno">  744 </span><span class="spaces">                      </span><span class="nottickedoff">| otherwise</span>
<span class="lineno">  745 </span><span class="spaces">             </span><span class="nottickedoff">= if null cs then fatal 594 $ &quot;A_Concept \&quot;&quot;++show c++&quot;\&quot; does not occur in its plug in fSpec \&quot;&quot;++name fSpec++&quot;\&quot;&quot; else</span>
<span class="lineno">  746 </span><span class="spaces">               </span><span class="nottickedoff">QName (head cs)</span>
<span class="lineno">  747 </span><span class="spaces">               </span><span class="nottickedoff">where cs = [name f |f&lt;-plugFields (sqlConceptPlug fSpec c), c'&lt;-concs f,c==c']</span></span>
<span class="lineno">  748 </span>
<span class="lineno">  749 </span>
<span class="lineno">  750 </span>stringOfName :: Name -&gt; String
<span class="lineno">  751 </span><span class="decl"><span class="nottickedoff">stringOfName (Name s)   =  s</span>
<span class="lineno">  752 </span><span class="spaces"></span><span class="nottickedoff">stringOfName (QName s)  =  s</span>
<span class="lineno">  753 </span><span class="spaces"></span><span class="nottickedoff">stringOfName (UQName s) =  s</span>
<span class="lineno">  754 </span><span class="spaces"></span><span class="nottickedoff">stringOfName _          = fatal 659 &quot;This kind of a Name wasn't used before in Ampersand. &quot;</span></span>
<span class="lineno">  755 </span>
<span class="lineno">  756 </span>sqlAtomQuote :: String -&gt; ValueExpr
<span class="lineno">  757 </span><span class="decl"><span class="nottickedoff">sqlAtomQuote s = StringLit s</span></span>
<span class="lineno">  758 </span>
<span class="lineno">  759 </span>conjunctSQL :: [ValueExpr] -&gt; ValueExpr
<span class="lineno">  760 </span><span class="decl"><span class="nottickedoff">conjunctSQL [] = fatal 57 &quot;nothing to `AND`.&quot;</span>
<span class="lineno">  761 </span><span class="spaces"></span><span class="nottickedoff">conjunctSQL [ve] = ve</span>
<span class="lineno">  762 </span><span class="spaces"></span><span class="nottickedoff">conjunctSQL (ve:ves) = BinOp ve [Name &quot;AND&quot;] (conjunctSQL ves)</span></span>
<span class="lineno">  763 </span>
<span class="lineno">  764 </span>disjunctSQL :: [ValueExpr] -&gt; ValueExpr
<span class="lineno">  765 </span><span class="decl"><span class="nottickedoff">disjunctSQL [] = fatal 57 &quot;nothing to `OR`.&quot;</span>
<span class="lineno">  766 </span><span class="spaces"></span><span class="nottickedoff">disjunctSQL [ve] = ve</span>
<span class="lineno">  767 </span><span class="spaces"></span><span class="nottickedoff">disjunctSQL (ve:ves) = BinOp ve [Name &quot;OR&quot;] (conjunctSQL ves)</span></span>
<span class="lineno">  768 </span>
<span class="lineno">  769 </span>as :: TableRef -&gt; Name -&gt; TableRef
<span class="lineno">  770 </span><span class="decl"><span class="nottickedoff">as ve a = -- TRAlias ve (Alias a Nothing)</span>
<span class="lineno">  771 </span><span class="spaces">  </span><span class="nottickedoff">case ve of </span>
<span class="lineno">  772 </span><span class="spaces">    </span><span class="nottickedoff">TRSimple [n] -&gt; if stringOfName n == stringOfName a then withoutAlias else withAlias</span>
<span class="lineno">  773 </span><span class="spaces">    </span><span class="nottickedoff">_            -&gt; withAlias</span>
<span class="lineno">  774 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno">  775 </span><span class="spaces">   </span><span class="nottickedoff">withoutAlias = ve</span>
<span class="lineno">  776 </span><span class="spaces">   </span><span class="nottickedoff">withAlias = TRAlias ve (Alias a Nothing)</span></span>
<span class="lineno">  777 </span>    
<span class="lineno">  778 </span>notNull :: ValueExpr -&gt; ValueExpr
<span class="lineno">  779 </span><span class="decl"><span class="nottickedoff">notNull ve = PostfixOp [Name &quot;IS NOT NULL&quot;] ve</span></span>                         
<span class="lineno">  780 </span>isNull  :: ValueExpr -&gt; ValueExpr
<span class="lineno">  781 </span><span class="decl"><span class="nottickedoff">isNull ve = PostfixOp [Name &quot;IS NULL&quot;] ve</span></span>
<span class="lineno">  782 </span>emptySet :: BinQueryExpr
<span class="lineno">  783 </span><span class="decl"><span class="nottickedoff">emptySet = BQEComment [BlockComment &quot;this will quaranteed return 0 rows:&quot;] $</span>
<span class="lineno">  784 </span><span class="spaces">           </span><span class="nottickedoff">BSE { </span>
<span class="lineno">  785 </span><span class="spaces">               </span><span class="nottickedoff">-- select 1 as src, 1 as trg from (select 1) dummy where false</span>
<span class="lineno">  786 </span><span class="spaces">                 </span><span class="nottickedoff">bseSrc = Iden [a]</span>
<span class="lineno">  787 </span><span class="spaces">               </span><span class="nottickedoff">, bseTrg = Iden [a]</span>
<span class="lineno">  788 </span><span class="spaces">               </span><span class="nottickedoff">, bseTbl = [TRQueryExpr (QEComment [BlockComment &quot;Select nothing...&quot;] </span>
<span class="lineno">  789 </span><span class="spaces">                                       </span><span class="nottickedoff">(Select { qeSetQuantifier = SQDefault</span>
<span class="lineno">  790 </span><span class="spaces">                                               </span><span class="nottickedoff">, qeSelectList = [(NumLit &quot;1&quot;, Just a)]</span>
<span class="lineno">  791 </span><span class="spaces">                                               </span><span class="nottickedoff">, qeFrom = []</span>
<span class="lineno">  792 </span><span class="spaces">                                               </span><span class="nottickedoff">, qeWhere = Nothing</span>
<span class="lineno">  793 </span><span class="spaces">                                               </span><span class="nottickedoff">, qeGroupBy = []</span>
<span class="lineno">  794 </span><span class="spaces">                                               </span><span class="nottickedoff">, qeHaving = Nothing</span>
<span class="lineno">  795 </span><span class="spaces">                                               </span><span class="nottickedoff">, qeOrderBy = []</span>
<span class="lineno">  796 </span><span class="spaces">                                               </span><span class="nottickedoff">, qeOffset = Nothing</span>
<span class="lineno">  797 </span><span class="spaces">                                               </span><span class="nottickedoff">, qeFetchFirst = Nothing</span>
<span class="lineno">  798 </span><span class="spaces">                                               </span><span class="nottickedoff">})) `as` Name &quot;nothing&quot;]</span>
<span class="lineno">  799 </span><span class="spaces">               </span><span class="nottickedoff">, bseWhr = Just (BinOp (Iden [a]) [Name &quot;&lt;&gt;&quot;] (NumLit &quot;1&quot;))</span>
<span class="lineno">  800 </span><span class="spaces">               </span><span class="nottickedoff">}</span>
<span class="lineno">  801 </span><span class="spaces">            </span><span class="nottickedoff">where a = Name &quot;a&quot;</span></span>
<span class="lineno">  802 </span>
<span class="lineno">  803 </span>
<span class="lineno">  804 </span>one :: BinQueryExpr
<span class="lineno">  805 </span><span class="decl"><span class="nottickedoff">one = BQEComment [BlockComment &quot;Just ONE&quot;] $</span>
<span class="lineno">  806 </span><span class="spaces">      </span><span class="nottickedoff">BSE {  -- select distinct 1 as src, 1 as tgt from (select 1) as a</span>
<span class="lineno">  807 </span><span class="spaces">            </span><span class="nottickedoff">bseSrc = NumLit &quot;1&quot;</span>
<span class="lineno">  808 </span><span class="spaces">          </span><span class="nottickedoff">, bseTrg = NumLit &quot;1&quot;</span>
<span class="lineno">  809 </span><span class="spaces">          </span><span class="nottickedoff">, bseTbl = [(TRQueryExpr  Select { qeSetQuantifier = SQDefault</span>
<span class="lineno">  810 </span><span class="spaces">                                          </span><span class="nottickedoff">, qeSelectList = [(NumLit &quot;1&quot;, Nothing)]</span>
<span class="lineno">  811 </span><span class="spaces">                                          </span><span class="nottickedoff">, qeFrom = []</span>
<span class="lineno">  812 </span><span class="spaces">                                          </span><span class="nottickedoff">, qeWhere = Nothing</span>
<span class="lineno">  813 </span><span class="spaces">                                          </span><span class="nottickedoff">, qeGroupBy = []</span>
<span class="lineno">  814 </span><span class="spaces">                                          </span><span class="nottickedoff">, qeHaving = Nothing</span>
<span class="lineno">  815 </span><span class="spaces">                                          </span><span class="nottickedoff">, qeOrderBy = []</span>
<span class="lineno">  816 </span><span class="spaces">                                          </span><span class="nottickedoff">, qeOffset = Nothing</span>
<span class="lineno">  817 </span><span class="spaces">                                          </span><span class="nottickedoff">, qeFetchFirst = Nothing</span>
<span class="lineno">  818 </span><span class="spaces">                                          </span><span class="nottickedoff">}) `as` Name &quot;ONE&quot; ]</span>
<span class="lineno">  819 </span><span class="spaces">          </span><span class="nottickedoff">, bseWhr = Nothing</span>
<span class="lineno">  820 </span><span class="spaces">          </span><span class="nottickedoff">}</span></span>
<span class="lineno">  821 </span>
<span class="lineno">  822 </span>theDialect :: Dialect 
<span class="lineno">  823 </span><span class="decl"><span class="nottickedoff">theDialect = MySQL</span></span>  -- maybe in the future other dialects will be supported. This depends on package `simple-sql-parser`

</pre>
</body>
</html>
