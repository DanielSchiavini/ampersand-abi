<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=CP850">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE ScopedTypeVariables, OverloadedStrings #-}
<span class="lineno">    2 </span>module Database.Design.Ampersand.FSpec.ToFSpec.Calc
<span class="lineno">    3 </span>            ( deriveProofs
<span class="lineno">    4 </span>            , showProof, showPrf, assembleECAs, conjuncts, genPAclause
<span class="lineno">    5 </span>            , commaEngPandoc, commaNLPandoc, commaEngPandoc', commaNLPandoc', commaPandocAnd --TODO: this shouldt be here!
<span class="lineno">    6 </span>            , quadsOfRules
<span class="lineno">    7 </span>          --  , testInterface
<span class="lineno">    8 </span>            ) where
<span class="lineno">    9 </span>
<span class="lineno">   10 </span>import Database.Design.Ampersand.Basics
<span class="lineno">   11 </span>import Data.List hiding (head)
<span class="lineno">   12 </span>import Data.Monoid
<span class="lineno">   13 </span>import GHC.Exts (sortWith)
<span class="lineno">   14 </span>--import Data.ByteString.Char8
<span class="lineno">   15 </span>--import Data.ByteString.Lazy.Char8
<span class="lineno">   16 </span>import Database.Design.Ampersand.Core.AbstractSyntaxTree hiding (sortWith)
<span class="lineno">   17 </span>import Database.Design.Ampersand.ADL1
<span class="lineno">   18 </span>import Database.Design.Ampersand.ADL1.Expression
<span class="lineno">   19 </span>import Database.Design.Ampersand.Classes
<span class="lineno">   20 </span>import Database.Design.Ampersand.FSpec.FSpec
<span class="lineno">   21 </span>import Database.Design.Ampersand.FSpec.ShowADL (ShowADL(..), showREL)
<span class="lineno">   22 </span>import Database.Design.Ampersand.FSpec.ShowECA (showECA)
<span class="lineno">   23 </span>import Database.Design.Ampersand.FSpec.ToFSpec.NormalForms
<span class="lineno">   24 </span>import Database.Design.Ampersand.Misc (Lang(..),Options(..),PandocFormat(ReST),string2Blocks)
<span class="lineno">   25 </span>import Text.Pandoc.Builder
<span class="lineno">   26 </span>import Prelude hiding (head)
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>fatal :: Int -&gt; String -&gt; a
<span class="lineno">   29 </span><span class="decl"><span class="nottickedoff">fatal = fatalMsg &quot;FSpec.ToFSpec.Calc&quot;</span></span>
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>head :: [a] -&gt; a
<span class="lineno">   32 </span><span class="decl"><span class="nottickedoff">head [] = fatal 30 &quot;head must not be used on an empty list!&quot;</span>
<span class="lineno">   33 </span><span class="spaces"></span><span class="nottickedoff">head (a:_) = a</span></span>
<span class="lineno">   34 </span>
<span class="lineno">   35 </span>-- testInterface :: FSpec -&gt; Interface -&gt; String
<span class="lineno">   36 </span>-- Deze functie is bedoeld om te bedenken hoe interfaces moeten worden afgeleid uit een vers vertaalde ObjectDef.
<span class="lineno">   37 </span>-- Nadat deze goed werkt kunnen de bewijsgenerator en de codegenerator worden gemaakt.
<span class="lineno">   38 </span>--   testInterface :: FSpec -&gt; Interface -&gt; String
<span class="lineno">   39 </span>--   testInterface fSpec ifc
<span class="lineno">   40 </span>--    = &quot;\nInterface &quot;++ name ifc++&quot;(&quot;++intercalate &quot;, &quot; [showADL r++&quot;:&quot;++name (target r) | r&lt;-rels]++&quot;)\n&quot;++
<span class="lineno">   41 </span>--      &quot; - The parameters correspond to editable fields in a user interface.\n   &quot;++
<span class="lineno">   42 </span>--      showADL ifc++&quot;\n&quot;++
<span class="lineno">   43 </span>--      &quot; - Invariants:\n   &quot;++intercalate &quot;\n   &quot; [showADL rule    | rule&lt;-invs]++&quot;\n&quot;++
<span class="lineno">   44 </span>--      &quot; - Derivation of clauses for ECA-rules:&quot;   ++
<span class="lineno">   45 </span>--      concat [showClause fSpec (makeCjcts (getOpts fSpec) rule) | rule&lt;-invs]++&quot;\n&quot;++
<span class="lineno">   46 </span>--{-
<span class="lineno">   47 </span>--      &quot; - ECA rules:&quot;++concat  [ &quot;\n\n     &quot;++showECA &quot;\n     &quot;  (eca{ecaAction=normPA (getOpts fSpec) (ecaAction eca)})
<span class="lineno">   48 </span>--                                 ++&quot;\n------ Derivation -----&gt;&quot;++showProof (codeBlock . (&quot;\n     &quot;++) . showECA &quot;\n     &quot;) (proofPA (getOpts fSpec) (ecaAction eca))++&quot;\n&lt;------End Derivation --&quot;
<span class="lineno">   49 </span>--                               | eca&lt;-ecaRs]++&quot;\n\n&quot;++
<span class="lineno">   50 </span>---}
<span class="lineno">   51 </span>--      &quot; - Visible relations:\n   &quot;++intercalate &quot;\n   &quot; (spread 80 &quot;, &quot; [showADL r  | r&lt;-vis])++&quot;\n&quot;
<span class="lineno">   52 </span>--    where
<span class="lineno">   53 </span>----        showQ i (rel, shs,conj,r)
<span class="lineno">   54 </span>----         = &quot;\nQuad &quot;++show i++&quot;:\nrelation: &quot;++showADL rel++&quot;:\nshifts: &quot;++concat [&quot;\n&quot;++showADLe s |s&lt;-shs]++&quot;\nconjunct: &quot;++showADL conj++&quot;\nrule: &quot;++showADL r++&quot;&quot;
<span class="lineno">   55 </span>----TODO: Deze code komt ook voor in ADL2FSpec.hs. Dat lijkt dubbelop, en derhalve niet goed.
<span class="lineno">   56 </span>--        rels = nub (recur (ifcObj ifc))
<span class="lineno">   57 </span>--         where recur obj = [editMph (objctx o) | o&lt;-attributes obj, editable (objctx o)]++[r | o&lt;-attributes obj, r&lt;-recur o]
<span class="lineno">   58 </span>--        vis        = nub (rels++map (I . target) rels)
<span class="lineno">   59 </span>--   --     visible r  = r `elem` vis
<span class="lineno">   60 </span>--        invs       = [rule | rule&lt;-invariants fSpec, (not.null) (map makeDeclaration (relsUsedIn rule) `isc` vis)]
<span class="lineno">   61 </span>--   --     qs         = vquads fSpec
<span class="lineno">   62 </span>--   --     (ecaRs, _) = assembleECAs fSpec (allDecls fSpec)
<span class="lineno">   63 </span>----        editable (ERel Rel{} _)  = True    --WHY?? Stef, welke functie is de juiste?? TODO deze functie staat ook in ADL2FSpec.hs, maar is daar ANDERS(!)...
<span class="lineno">   64 </span>----        editable _               = False
<span class="lineno">   65 </span>----        editMph (ERel r@Rel{} _) = r       --WHY?? Stef, welke functie is de juiste?? TODO deze functie staat ook in ADL2FSpec.hs, maar is daar ANDERS(!)...
<span class="lineno">   66 </span>----        editMph e                = fatal 64 $ &quot;cannot determine an editable declaration in a composite expression: &quot;++show e
<span class="lineno">   67 </span>--        -- De functie spread verspreidt strings over kolommen met een breedte van n.
<span class="lineno">   68 </span>--        -- Deze functie garandeert dat alle strings worden afgedrukt in de aangegeven volgorde.
<span class="lineno">   69 </span>--        -- Hij probeert daarbij zo weinig mogelijk regels te gebruiken,
<span class="lineno">   70 </span>--        -- en alleen de grens van n te overschrijden als een string zelf langer is dan n.
<span class="lineno">   71 </span>--        spread :: Int -&gt; String -&gt; [String] -&gt; [String]
<span class="lineno">   72 </span>--        spread n str = f &quot;&quot;
<span class="lineno">   73 </span>--         where f stored []       = [stored | not (null stored)]
<span class="lineno">   74 </span>--               f [] (cs:css)     = f cs css
<span class="lineno">   75 </span>--               f stored (cs:css) | length stored &gt; n = stored: f cs css
<span class="lineno">   76 </span>--                                 | length new   &lt;= n = f new css
<span class="lineno">   77 </span>--                                 | otherwise         = stored: f cs css
<span class="lineno">   78 </span>--                                   where new = stored++str++cs
<span class="lineno">   79 </span>testConfluence :: A_Context -&gt; Blocks
<span class="lineno">   80 </span><span class="decl"><span class="nottickedoff">testConfluence context</span>
<span class="lineno">   81 </span><span class="spaces"> </span><span class="nottickedoff">= let tcss = [(expr,tcs) | expr&lt;-expressionsIn context, let tcs=dfProofs expr, length tcs&gt;1]</span>
<span class="lineno">   82 </span><span class="spaces">       </span><span class="nottickedoff">sumt = sum (map (length.snd) tcss)</span>
<span class="lineno">   83 </span><span class="spaces">   </span><span class="nottickedoff">in</span>
<span class="lineno">   84 </span><span class="spaces">   </span><span class="nottickedoff">para (&quot;Confluence analysis statistics from &quot;&lt;&gt;(str.show.length.expressionsIn) context&lt;&gt;&quot; expressions.&quot;&lt;&gt;linebreak)&lt;&gt;</span>
<span class="lineno">   85 </span><span class="spaces">   </span><span class="nottickedoff">para (&quot;This script contains &quot;&lt;&gt;linebreak&lt;&gt;(str.show.length) tcss&lt;&gt; &quot; non-confluent expressions &quot;&lt;&gt;linebreak)&lt;&gt;</span>
<span class="lineno">   86 </span><span class="spaces">   </span><span class="nottickedoff">para (linebreak&lt;&gt;&quot;Total number of derived expressions: &quot;&lt;&gt;(str.show) sumt&lt;&gt;linebreak)&lt;&gt;</span>
<span class="lineno">   87 </span><span class="spaces">   </span><span class="nottickedoff">para (&quot;Confluence analysis for &quot;&lt;&gt;(str.name) context)&lt;&gt;</span>
<span class="lineno">   88 </span><span class="spaces">   </span><span class="nottickedoff">mconcat</span>
<span class="lineno">   89 </span><span class="spaces">     </span><span class="nottickedoff">[ para (linebreak&lt;&gt;&quot;expression:   &quot;&lt;&gt;(str . showADL) expr&lt;&gt;linebreak)&lt;&gt;</span>
<span class="lineno">   90 </span><span class="spaces">       </span><span class="nottickedoff">bulletList [ showProof (para.str.showADL) prf | (_,prf)&lt;-tcs ]</span>
<span class="lineno">   91 </span><span class="spaces">     </span><span class="nottickedoff">| (expr,tcs)&lt;-tcss]</span></span>
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>deriveProofs :: Options -&gt; A_Context -&gt; Blocks
<span class="lineno">   94 </span><span class="decl"><span class="nottickedoff">deriveProofs opts context</span>
<span class="lineno">   95 </span><span class="spaces"> </span><span class="nottickedoff">= testConfluence context&lt;&gt;</span>
<span class="lineno">   96 </span><span class="spaces">   </span><span class="nottickedoff">para (linebreak&lt;&gt;&quot;--------------&quot;&lt;&gt;linebreak)&lt;&gt;</span>
<span class="lineno">   97 </span><span class="spaces">   </span><span class="nottickedoff">para (&quot;Rules and their conjuncts for &quot;&lt;&gt;(str.name) context)&lt;&gt;</span>
<span class="lineno">   98 </span><span class="spaces">   </span><span class="nottickedoff">bulletList [ para (&quot;rule r:   &quot;&lt;&gt;str (showADL r)&lt;&gt;linebreak&lt;&gt;</span>
<span class="lineno">   99 </span><span class="spaces">                      </span><span class="nottickedoff">&quot;rrexp r:  &quot;&lt;&gt;str (showADL (rrexp r))&lt;&gt;linebreak&lt;&gt;</span>
<span class="lineno">  100 </span><span class="spaces">                      </span><span class="nottickedoff">&quot;conjNF:   &quot;&lt;&gt;str (showADL (conjNF opts (rrexp r)))&lt;&gt;linebreak&lt;&gt;</span>
<span class="lineno">  101 </span><span class="spaces">                      </span><span class="nottickedoff">interText linebreak [ &quot;     conj: &quot;&lt;&gt;str (showADL conj) | conj&lt;-conjuncts opts r ]</span>
<span class="lineno">  102 </span><span class="spaces">                     </span><span class="nottickedoff">)</span>
<span class="lineno">  103 </span><span class="spaces">              </span><span class="nottickedoff">| r&lt;-allRules context]&lt;&gt;</span>
<span class="lineno">  104 </span><span class="spaces">   </span><span class="nottickedoff">para (&quot;Transformation of user specified rules into ECA rules for &quot;&lt;&gt;(str.name) context)&lt;&gt;</span>
<span class="lineno">  105 </span><span class="spaces">   </span><span class="nottickedoff">para (linebreak&lt;&gt;&quot;--------------&quot;&lt;&gt;linebreak&lt;&gt;&quot;First step: determine the &quot;&lt;&gt;(str.show.length) quads&lt;&gt;&quot; quads:&quot;)&lt;&gt;</span>
<span class="lineno">  106 </span><span class="spaces">   </span><span class="nottickedoff">bulletList [ para ( &quot;-- quad ------------&quot;&lt;&gt;linebreak&lt;&gt;&quot;When relation &quot;&lt;&gt;(str . showADL . qDcl) q&lt;&gt;&quot; is changed,&quot;</span>
<span class="lineno">  107 </span><span class="spaces">                       </span><span class="nottickedoff">&lt;&gt;linebreak&lt;&gt;(str . showADL . qRule) q</span>
<span class="lineno">  108 </span><span class="spaces">                       </span><span class="nottickedoff">&lt;&gt;(if (length . qConjuncts) q&lt;=1 then space else &quot; (&quot;&lt;&gt;(str . show . length . qConjuncts) q&lt;&gt;&quot; conjuncts)&quot;)</span>
<span class="lineno">  109 </span><span class="spaces">                       </span><span class="nottickedoff">&lt;&gt;&quot; must be restored.&quot;&lt;&gt;linebreak&lt;&gt;&quot;This quad has conjunct: &quot;&lt;&gt;(str . showADL . rc_conjunct) x</span>
<span class="lineno">  110 </span><span class="spaces">                       </span><span class="nottickedoff">&lt;&gt;&quot; and &quot;&lt;&gt;(str.show.length.rc_dnfClauses) x&lt;&gt;&quot; dnf clauses.&quot;</span>
<span class="lineno">  111 </span><span class="spaces">                     </span><span class="nottickedoff">) &lt;&gt;</span>
<span class="lineno">  112 </span><span class="spaces">                </span><span class="nottickedoff">bulletList [ para (linebreak&lt;&gt;&quot;Dnf clause &quot;&lt;&gt;str (showADL dc)) | dc&lt;-rc_dnfClauses x]</span>
<span class="lineno">  113 </span><span class="spaces">              </span><span class="nottickedoff">| q&lt;-quads, x&lt;-qConjuncts q ] &lt;&gt;</span>
<span class="lineno">  114 </span><span class="spaces">   </span><span class="nottickedoff">para (linebreak&lt;&gt;linebreak&lt;&gt;&quot;Second step: assemble dnf clauses.&quot;) &lt;&gt;</span>
<span class="lineno">  115 </span><span class="spaces">   </span><span class="nottickedoff">bulletList [ para ( &quot;Dnf clause &quot;&lt;&gt;str (showADL dc)</span>
<span class="lineno">  116 </span><span class="spaces">                       </span><span class="nottickedoff">&lt;&gt;linebreak&lt;&gt;&quot;is derived from rule &quot;&lt;&gt;str (showADL r)</span>
<span class="lineno">  117 </span><span class="spaces">                       </span><span class="nottickedoff">&lt;&gt;linebreak</span>
<span class="lineno">  118 </span><span class="spaces">                       </span><span class="nottickedoff">&lt;&gt;case ms of</span>
<span class="lineno">  119 </span><span class="spaces">                            </span><span class="nottickedoff">[]    -&gt; &quot;No relations affect this clause.&quot;</span>
<span class="lineno">  120 </span><span class="spaces">                            </span><span class="nottickedoff">[rel] -&gt; &quot;It can be called when relation &quot; &lt;&gt;str (showADL rel)&lt;&gt;&quot; is affected.&quot;</span>
<span class="lineno">  121 </span><span class="spaces">                            </span><span class="nottickedoff">_     -&gt; &quot;It can be called when relations &quot;&lt;&gt;str (commaEng &quot;or&quot; [showADL rel | rel&lt;-ms])&lt;&gt;&quot; are affected.&quot;</span>
<span class="lineno">  122 </span><span class="spaces">                     </span><span class="nottickedoff">)</span>
<span class="lineno">  123 </span><span class="spaces">              </span><span class="nottickedoff">| (ms,dc,r)&lt;-</span>
<span class="lineno">  124 </span><span class="spaces">                    </span><span class="nottickedoff">[ (nub [ dcl |(dcl,_,_)&lt;-cl],dc,r)</span>
<span class="lineno">  125 </span><span class="spaces">                    </span><span class="nottickedoff">| cl&lt;-eqCl (\(_,_,dc)-&gt;dc) [(qDcl q,dc,qRule q) |q&lt;-quads, x&lt;-qConjuncts q, dc&lt;-rc_dnfClauses x]</span>
<span class="lineno">  126 </span><span class="spaces">                    </span><span class="nottickedoff">, let (_,dc,r) = head cl</span>
<span class="lineno">  127 </span><span class="spaces">                    </span><span class="nottickedoff">]</span>
<span class="lineno">  128 </span><span class="spaces">              </span><span class="nottickedoff">]&lt;&gt;</span>
<span class="lineno">  129 </span><span class="spaces">   </span><span class="nottickedoff">para (linebreak&lt;&gt;&quot;Third step: determine &quot;&lt;&gt;(str.show.length.udefrules) context&lt;&gt;&quot; ECA rules&quot;&lt;&gt;</span>
<span class="lineno">  130 </span><span class="spaces">         </span><span class="nottickedoff">if verboseP opts</span>
<span class="lineno">  131 </span><span class="spaces">          </span><span class="nottickedoff">then &quot; (Turn --verbose off if you want to see ECA rules only)&quot;</span>
<span class="lineno">  132 </span><span class="spaces">          </span><span class="nottickedoff">else &quot; (Turn on --verbose if you want to see more detail)&quot;</span>
<span class="lineno">  133 </span><span class="spaces">        </span><span class="nottickedoff">)&lt;&gt;</span>
<span class="lineno">  134 </span><span class="spaces">   </span><span class="nottickedoff">( if verboseP opts then para ( &quot;--------------&quot;&lt;&gt;linebreak)&lt;&gt;bulletList derivations else fromList [] )&lt;&gt;</span>
<span class="lineno">  135 </span><span class="spaces">   </span><span class="nottickedoff">bulletList [ para ( &quot;-- ECA Rule &quot;&lt;&gt;(str.show.ecaNum) ecarule&lt;&gt;&quot; ---------&quot;)&lt;&gt;</span>
<span class="lineno">  136 </span><span class="spaces">                </span><span class="nottickedoff">codeBlock (&quot;\n  &quot;++showECA &quot;\n  &quot; ecarule{ecaAction=normPA opts (ecaAction ecarule)})&lt;&gt;</span>
<span class="lineno">  137 </span><span class="spaces">                </span><span class="nottickedoff">bulletList [ para (linebreak&lt;&gt;&quot;delta expression&quot;&lt;&gt;linebreak&lt;&gt;space&lt;&gt;str (showADL d)</span>
<span class="lineno">  138 </span><span class="spaces">                                   </span><span class="nottickedoff">&lt;&gt;linebreak&lt;&gt;&quot;derivation:&quot;</span>
<span class="lineno">  139 </span><span class="spaces">                                  </span><span class="nottickedoff">)&lt;&gt;</span>
<span class="lineno">  140 </span><span class="spaces">                             </span><span class="nottickedoff">(showProof (para.str.showADL).dfProof opts) d&lt;&gt;  -- Produces its result in disjunctive normal form</span>
<span class="lineno">  141 </span><span class="spaces">                             </span><span class="nottickedoff">para (&quot;disjunctly normalized delta expression&quot;&lt;&gt;linebreak&lt;&gt;(str.showADL.disjNF opts) d)</span>
<span class="lineno">  142 </span><span class="spaces">                           </span><span class="nottickedoff">| verboseP opts, e@Do{}&lt;-[ecaAction ecarule], let d = paDelta e ]</span>
<span class="lineno">  143 </span><span class="spaces">              </span><span class="nottickedoff">| ecarule &lt;- ecaRs]</span>
<span class="lineno">  144 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno">  145 </span><span class="spaces">      </span><span class="nottickedoff">++</span>
<span class="lineno">  146 </span><span class="spaces">      </span><span class="nottickedoff">[ linebreak&lt;&gt;&quot;--------------&quot;, linebreak, linebreak&lt;&gt;&quot;Fourth step: cascade blocking rules&quot;</span>
<span class="lineno">  147 </span><span class="spaces">      </span><span class="nottickedoff">, linebreak</span>
<span class="lineno">  148 </span><span class="spaces">      </span><span class="nottickedoff">]++</span>
<span class="lineno">  149 </span><span class="spaces">      </span><span class="nottickedoff">interText []</span>
<span class="lineno">  150 </span><span class="spaces">        </span><span class="nottickedoff">[ [linebreak&lt;&gt;&quot;-- Raw ECA rule &quot;&lt;&gt;(str.show.ecaNum) er&lt;&gt;&quot;------------&quot;&lt;&gt;linebreak&lt;&gt;str (showECA &quot;\n  &quot; er)]</span>
<span class="lineno">  151 </span><span class="spaces">        </span><span class="nottickedoff">| er&lt;- ecaRs]</span>
<span class="lineno">  152 </span><span class="spaces">      </span><span class="nottickedoff">++</span>
<span class="lineno">  153 </span><span class="spaces">      </span><span class="nottickedoff">[ linebreak&lt;&gt;&quot;--------------&quot;, linebreak, linebreak&lt;&gt;&quot;Fifth step: preEmpt the rules (= optimize)&quot;</span>
<span class="lineno">  154 </span><span class="spaces">      </span><span class="nottickedoff">, linebreak</span>
<span class="lineno">  155 </span><span class="spaces">      </span><span class="nottickedoff">]++</span>
<span class="lineno">  156 </span><span class="spaces"></span><span class="nottickedoff">{- TODO: readdress preEmpt. It is wrong</span>
<span class="lineno">  157 </span><span class="spaces">      </span><span class="nottickedoff">interText []</span>
<span class="lineno">  158 </span><span class="spaces">        </span><span class="nottickedoff">[ [linebreak&lt;&gt;&quot;-- Preempted ECA rule &quot;&lt;&gt;(str.show.ecaNum) er&lt;&gt;&quot;------------&quot;&lt;&gt;linebreak&lt;&gt;str (showECA &quot;\n  &quot; er)]</span>
<span class="lineno">  159 </span><span class="spaces">        </span><span class="nottickedoff">| er&lt;- preEmpt opts ecaRs]</span>
<span class="lineno">  160 </span><span class="spaces">      </span><span class="nottickedoff">++ -}</span>
<span class="lineno">  161 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno">  162 </span><span class="spaces">      </span><span class="nottickedoff">[ linebreak&lt;&gt;&quot;--------------&quot;, linebreak]</span>
<span class="lineno">  163 </span><span class="spaces">      </span><span class="nottickedoff">++ -- TODO: make an ontological analysis, which explains the delete behaviour.</span>
<span class="lineno">  164 </span><span class="spaces">      </span><span class="nottickedoff">[ Str &quot;Ontological analysis: &quot;, linebreak&lt;&gt;&quot;  &quot;]</span>
<span class="lineno">  165 </span><span class="spaces">      </span><span class="nottickedoff">++</span>
<span class="lineno">  166 </span><span class="spaces">      </span><span class="nottickedoff">interText [linebreak, linebreak&lt;&gt;&quot;  &quot;]</span>
<span class="lineno">  167 </span><span class="spaces">          </span><span class="nottickedoff">[ [Str (name ifc)&lt;&gt;&quot;(&quot;]</span>
<span class="lineno">  168 </span><span class="spaces">            </span><span class="nottickedoff">++ interText &quot;, &quot;</span>
<span class="lineno">  169 </span><span class="spaces">                 </span><span class="nottickedoff">[str (name a)&lt;&gt;&quot;[&quot;&lt;&gt;(str.name.target.ctx) a&lt;&gt;&quot;]&quot;</span>
<span class="lineno">  170 </span><span class="spaces">                 </span><span class="nottickedoff">|a&lt;-attributes (ifcObj ifc)]</span>
<span class="lineno">  171 </span><span class="spaces">            </span><span class="nottickedoff">++ [Str &quot;):&quot;, linebreak&lt;&gt;&quot;  &quot;]</span>
<span class="lineno">  172 </span><span class="spaces">          </span><span class="nottickedoff">| ifc&lt;-interfaceS fSpec]</span>
<span class="lineno">  173 </span><span class="spaces">      </span><span class="nottickedoff">++</span>
<span class="lineno">  174 </span><span class="spaces">      </span><span class="nottickedoff">[ linebreak&lt;&gt;&quot;--------------&quot;, linebreak</span>
<span class="lineno">  175 </span><span class="spaces">      </span><span class="nottickedoff">&lt;&gt;&quot;Analyzing interfaces:&quot;, linebreak&lt;&gt;&quot;     &quot;]</span>
<span class="lineno">  176 </span><span class="spaces">      </span><span class="nottickedoff">++</span>
<span class="lineno">  177 </span><span class="spaces">      </span><span class="nottickedoff">interText [linebreak&lt;&gt;&quot;     &quot;]</span>
<span class="lineno">  178 </span><span class="spaces">         </span><span class="nottickedoff">[[Str (testInterface fSpec ifc)]</span>
<span class="lineno">  179 </span><span class="spaces">         </span><span class="nottickedoff">| ifc&lt;-take 1 (interfaceG fSpec)]</span>
<span class="lineno">  180 </span><span class="spaces">      </span><span class="nottickedoff">++</span>
<span class="lineno">  181 </span><span class="spaces">      </span><span class="nottickedoff">[ linebreak&lt;&gt;&quot;--------------&quot;, linebreak]</span>
<span class="lineno">  182 </span><span class="spaces">      </span><span class="nottickedoff">-}</span>
<span class="lineno">  183 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno">  184 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno">  185 </span><span class="spaces"></span><span class="nottickedoff">--    visible _  = True -- We take all quads into account.</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="nottickedoff">quads  = quadsOfRules opts (allRules context) -- the quads that are derived for this fSpec specify dnf clauses, meant to maintain rule r, to be called when relation rel is affected (rel is in r).</span>
<span class="lineno">  187 </span><span class="spaces"></span><span class="nottickedoff">--    interText :: (Data.String.IsString a, Data.Monoid.Monoid a) =&gt; a -&gt; [a] -&gt; a</span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="nottickedoff">interText _ [] = &quot;&quot;</span>
<span class="lineno">  189 </span><span class="spaces">    </span><span class="nottickedoff">interText inbetween (xs:xss) = xs&lt;&gt;inbetween&lt;&gt;interText inbetween xss</span>
<span class="lineno">  190 </span><span class="spaces">    </span><span class="nottickedoff">derivations :: [Blocks]</span>
<span class="lineno">  191 </span><span class="spaces">    </span><span class="nottickedoff">ecaRs :: [ECArule]</span>
<span class="lineno">  192 </span><span class="spaces">    </span><span class="nottickedoff">(ecaRs, derivations) = assembleECAs opts context (relsDefdIn context)</span></span>
<span class="lineno">  193 </span>{-
<span class="lineno">  194 </span>           [ str (&quot;Available code fragments on rule &quot;&lt;&gt;name rule&lt;&gt;&quot;:&quot;, linebreak ]&lt;&gt;
<span class="lineno">  195 </span>           interText [linebreak] [showADL rule&lt;&gt; &quot; yields\n&quot;&lt;&gt;interText &quot;\n\n&quot;
<span class="lineno">  196 </span>                                   [ [&quot;event = &quot;, str (show ev), space, str (showADL rel), linebreak ] &lt;&gt;
<span class="lineno">  197 </span>                                     [str (showADL r&lt;&gt;&quot;[&quot;&lt;&gt;showADL rel&lt;&gt;&quot;:=&quot;&lt;&gt;showADL (actSem opts ev (EDcD rel) (delta (sign rel)))&lt;&gt;&quot;] = r'&quot;), linebreak ] &lt;&gt;
<span class="lineno">  198 </span>                                     [&quot;r'    = &quot;] &lt;&gt; conjProof r' &lt;&gt; [linebreak ] &lt;&gt;
<span class="lineno">  199 </span>                                     [&quot;viols = r'-&quot;] &lt;&gt; disjProof (ECpl r') &lt;&gt; [ linebreak ] &lt;&gt;
<span class="lineno">  200 </span>                                     &quot;violations, considering that the valuation of &quot;&lt;&gt;showADL rel&lt;&gt;&quot; has just been changed to &quot;&lt;&gt;showADL (actSem opts ev (EDcD rel) (delta (sign rel)))&lt;&gt;
<span class="lineno">  201 </span>                                     &quot;            &quot;&lt;&gt;conjProof (ECpl r) &lt;&gt;&quot;\n&quot;&lt;&gt;
<span class="lineno">  202 </span>                                     &quot;reaction? evaluate r |- r' (&quot;&lt;&gt;(str.showADL.conjNF opts) (notCpl r .\/. r')&lt;&gt;&quot;)&quot;&lt;&gt;
<span class="lineno">  203 </span>                                        conjProof (notCpl r .\/. r')&lt;&gt;&quot;\n&quot;&lt;&gt;
<span class="lineno">  204 </span>                                     &quot;delta: r-/\\r' = &quot;&lt;&gt;conjProof (EIsc[notCpl r,r'])&lt;&gt;
<span class="lineno">  205 </span>                                     &quot;\nNow compute a reaction\n(isTrue.conjNF opts) (notCpl r .\/. r') = &quot;&lt;&gt;show ((isTrue.conjNF opts) (notCpl r .\/. r'))&lt;&gt;&quot;\n&quot;&lt;&gt;
<span class="lineno">  206 </span>                                     (if null (lambda ev (ERel rel ) r)
<span class="lineno">  207 </span>                                      then &quot;lambda &quot;&lt;&gt;showADL rel&lt;&gt;&quot; (&quot;&lt;&gt;showADL r&lt;&gt;&quot;) = empty\n&quot;
<span class="lineno">  208 </span>                                      else -- for debug purposes:
<span class="lineno">  209 </span>                                           -- &quot;lambda &quot;&lt;&gt;show ev&lt;&gt;&quot; &quot;&lt;&gt;showADL rel&lt;&gt;&quot; (&quot;&lt;&gt;showADL r&lt;&gt;&quot;) = \n&quot;&lt;&gt;(interText &quot;\n\n&quot;.map showPr.lambda ev (ERel rel)) r&lt;&gt;&quot;\n&quot;&lt;&gt;
<span class="lineno">  210 </span>                                           -- &quot;derivMono (&quot;&lt;&gt;showADL r&lt;&gt;&quot;) &quot;&lt;&gt;show ev&lt;&gt;&quot; &quot;&lt;&gt;showADL rel&lt;&gt;&quot;\n = &quot;&lt;&gt;({-interText &quot;\n&quot;. map -}showPr.derivMono r ev) rel&lt;&gt;&quot;\n&quot;&lt;&gt;
<span class="lineno">  211 </span>                                           -- &quot;\nNow compute checkMono opts r ev rel = \n&quot;&lt;&gt;show (checkMono opts r ev rel)&lt;&gt;&quot;\n&quot;&lt;&gt;
<span class="lineno">  212 </span>                                           if (isTrue.conjNF opts) (notCpl r .\/. r')
<span class="lineno">  213 </span>                                           then &quot;A reaction is not required, because  r |- r'. Proof:&quot;&lt;&gt;conjProof (notCpl r .\/. r')&lt;&gt;&quot;\n&quot;
<span class="lineno">  214 </span>                                           else if checkMono opts r ev rel
<span class="lineno">  215 </span>                                           then &quot;A reaction is not required, because  r |- r'. Proof:&quot;{-&lt;&gt;(str.showPr.derivMono r ev) rel-}&lt;&gt;&quot;NIET TYPECORRECT: (showPr.derivMono r ev) rel&quot;&lt;&gt;&quot;\n&quot;  --WHY? Stef, gaarne herstellen...Deze fout vond ik nadat ik het type van showProof had opgegeven.
<span class="lineno">  216 </span>                                           else let ERel _ _ = delta (sign rel) in
<span class="lineno">  217 </span>                                                &quot;An appropriate reaction on this event is required.&quot;
<span class="lineno">  218 </span>                                           --     showECA &quot;\n  &quot; (ECA (On ev rel) delt (genPAclause visible Ins r viols conj [rule]) 0)
<span class="lineno">  219 </span>                                     )
<span class="lineno">  220 </span>                                   | rel&lt;-relsUsedIn r   -- nub [x |x&lt;-relsUsedIn r, not (isIdent x)] -- TODO: include proofs that allow: isIdent rel'
<span class="lineno">  221 </span>                                   , ev&lt;-[Ins,Del]
<span class="lineno">  222 </span>                                   , r'&lt;-[subst (rel, actSem opts ev (EDcD rel) (delta (sign rel))) r]
<span class="lineno">  223 </span>                        --        , viols&lt;-[conjNF opts (ECpl r')]
<span class="lineno">  224 </span>                                   , True ]  -- (isTrue.conjNF opts) (notCpl r .\/. r')
<span class="lineno">  225 </span>                                  | r&lt;-[dc | cs&lt;-[makeCjcts opts rule], (_,dnfClauses)&lt;-cs, dc&lt;-dnfClauses]
<span class="lineno">  226 </span>                                  ]
<span class="lineno">  227 </span>           where e = rrexp rule
<span class="lineno">  228 </span>                 prf = cfProof (getOpts fSpec) e
<span class="lineno">  229 </span>                 (exx',_,_) = last prf
<span class="lineno">  230 </span>            --     conjProof = showProof (para.str.showADL) . cfProof (getOpts fSpec)
<span class="lineno">  231 </span>                 disjProof = showProof (para.str.showADL) . dfProof (getOpts fSpec)
<span class="lineno">  232 </span>--                 showPr    = showProof (para.str.showADL)  -- hoort bij de uitgecommentaarde code hierboven...
<span class="lineno">  233 </span>       --TODO: See ticket #105
<span class="lineno">  234 </span>-}
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>-- Stel we voeren een actie a uit, die een(1) van de volgende twee is:
<span class="lineno">  237 </span>--        {r} INS rel INTO expr {r'}       ofwel
<span class="lineno">  238 </span>--        {r} DEL rel FROM expr {r'}
<span class="lineno">  239 </span>-- Dan toetst checkMono of r|-r' waar is op grond van de afleiding uit derivMono.
<span class="lineno">  240 </span>-- Als dat waar is, betekent dat dat invariant r waar blijft wanneer actie a wordt uitgevoerd.
<span class="lineno">  241 </span>checkMono :: Options
<span class="lineno">  242 </span>          -&gt; Expression
<span class="lineno">  243 </span>          -&gt; InsDel
<span class="lineno">  244 </span>          -&gt; Declaration
<span class="lineno">  245 </span>          -&gt; Bool
<span class="lineno">  246 </span><span class="decl"><span class="nottickedoff">checkMono opts expr ev dcl</span>
<span class="lineno">  247 </span><span class="spaces">  </span><span class="nottickedoff">= case ruleType conclusion of</span>
<span class="lineno">  248 </span><span class="spaces">     </span><span class="nottickedoff">Truth -&gt; fatal 247 &quot;derivMono came up with a Truth!&quot;</span>
<span class="lineno">  249 </span><span class="spaces">     </span><span class="nottickedoff">_     -&gt; simplify expr == simplify (antecedent conclusion) &amp;&amp;</span>
<span class="lineno">  250 </span><span class="spaces">              </span><span class="nottickedoff">simplify (subst (dcl, actSem opts ev (EDcD dcl) (delta (sign dcl))) expr) ==</span>
<span class="lineno">  251 </span><span class="spaces">              </span><span class="nottickedoff">simplify (consequent conclusion)</span>
<span class="lineno">  252 </span><span class="spaces">  </span><span class="nottickedoff">where (conclusion,_,_) = last (derivMono expr ev dcl)</span></span>
<span class="lineno">  253 </span>
<span class="lineno">  254 </span>type Proof expr = [(expr,[String],String)]
<span class="lineno">  255 </span>reversePrf :: Proof e -&gt; Proof e
<span class="lineno">  256 </span><span class="decl"><span class="nottickedoff">reversePrf [] = []</span>
<span class="lineno">  257 </span><span class="spaces"></span><span class="nottickedoff">reversePrf [s] = [s]</span>
<span class="lineno">  258 </span><span class="spaces"></span><span class="nottickedoff">reversePrf ((r,cs,e'):prf@((r',_ ,_):_)) = init rp++[(r',cs,rev e'),(r,[],&quot;&quot;)]</span>
<span class="lineno">  259 </span><span class="spaces">  </span><span class="nottickedoff">where rp = reversePrf prf</span>
<span class="lineno">  260 </span><span class="spaces">        </span><span class="nottickedoff">rev &quot;==&gt;&quot; = &quot;&lt;==&quot;</span>
<span class="lineno">  261 </span><span class="spaces">        </span><span class="nottickedoff">rev &quot;&lt;==&quot; = &quot;==&gt;&quot;</span>
<span class="lineno">  262 </span><span class="spaces">        </span><span class="nottickedoff">rev &quot;--&gt;&quot; = &quot;&lt;--&quot;</span>
<span class="lineno">  263 </span><span class="spaces">        </span><span class="nottickedoff">rev &quot;&lt;--&quot; = &quot;--&gt;&quot;</span>
<span class="lineno">  264 </span><span class="spaces">        </span><span class="nottickedoff">rev x = x</span></span>
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>showProof :: (expr-&gt;Blocks) -&gt; Proof expr -&gt; Blocks
<span class="lineno">  267 </span><span class="decl"><span class="nottickedoff">showProof shw [(expr,ss,_)]       = shw expr&lt;&gt; para ( str(&quot; { &quot;++intercalate &quot; and &quot; ss++&quot; }&quot;))</span>
<span class="lineno">  268 </span><span class="spaces"></span><span class="nottickedoff">showProof shw ((expr,ss,equ):prf) = shw expr&lt;&gt;</span>
<span class="lineno">  269 </span><span class="spaces">                                    </span><span class="nottickedoff">para (if null ss  then str equ else</span>
<span class="lineno">  270 </span><span class="spaces">                                          </span><span class="nottickedoff">if null equ then str (unwords ss) else</span>
<span class="lineno">  271 </span><span class="spaces">                                          </span><span class="nottickedoff">str equ&lt;&gt;str (&quot; { &quot;++intercalate &quot; and &quot; ss++&quot; }&quot;))&lt;&gt;</span>
<span class="lineno">  272 </span><span class="spaces">                                    </span><span class="nottickedoff">showProof shw prf</span>
<span class="lineno">  273 </span><span class="spaces">                                    </span><span class="nottickedoff">--where e'= if null prf then &quot;&quot; else let (expr,_,_):_ = prf in showHS options &quot;&quot; expr</span>
<span class="lineno">  274 </span><span class="spaces"></span><span class="nottickedoff">showProof _  []                   = fromList []</span></span>
<span class="lineno">  275 </span>
<span class="lineno">  276 </span>showPrf :: (expr-&gt;String) -&gt; Proof expr -&gt; [String]
<span class="lineno">  277 </span><span class="decl"><span class="nottickedoff">showPrf shw [(expr,_ ,_)]       = [ &quot;    &quot;++shw expr]</span>
<span class="lineno">  278 </span><span class="spaces"></span><span class="nottickedoff">showPrf shw ((expr,ss,equ):prf) = [ &quot;    &quot;++shw expr] ++</span>
<span class="lineno">  279 </span><span class="spaces">                                  </span><span class="nottickedoff">(if null ss  then [ equ ] else</span>
<span class="lineno">  280 </span><span class="spaces">                                   </span><span class="nottickedoff">if null equ then [ unwords ss ] else</span>
<span class="lineno">  281 </span><span class="spaces">                                   </span><span class="nottickedoff">[ equ++&quot; { &quot;++intercalate &quot; and &quot; ss++&quot; }&quot; ])++</span>
<span class="lineno">  282 </span><span class="spaces">                                  </span><span class="nottickedoff">showPrf shw prf</span>
<span class="lineno">  283 </span><span class="spaces"></span><span class="nottickedoff">showPrf _  []                   = []</span></span>
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>-- derivMono provides a derivation to prove that (precondition) r is a subset of (postcondition) r'.
<span class="lineno">  286 </span>-- This is useful in proving that an action {expr} a {expr'} maintains its invariant, i.e. that  expr|-expr'  holds (proven by monotony properties)
<span class="lineno">  287 </span>-- Derivmono gives a derivation only.
<span class="lineno">  288 </span>derivMono :: Expression -&gt; InsDel -&gt; Declaration -&gt; [(Rule, [String], String)]
<span class="lineno">  289 </span><span class="decl"><span class="nottickedoff">derivMono expr -- preconditie van actie a</span>
<span class="lineno">  290 </span><span class="spaces">          </span><span class="nottickedoff">tOp  -- de actie (Ins of Del)</span>
<span class="lineno">  291 </span><span class="spaces">          </span><span class="nottickedoff">dcl' -- re relatie, zodat de actie bestaat uit INSERT rel' INTO expr of DELETE rel' FROM expr</span>
<span class="lineno">  292 </span><span class="spaces"> </span><span class="nottickedoff">= f (head (lambda tOp (EDcD dcl') expr++[[]])) (start tOp)</span>
<span class="lineno">  293 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno">  294 </span><span class="spaces">  </span><span class="nottickedoff">f :: [(Expression, [String], whatever)]</span>
<span class="lineno">  295 </span><span class="spaces">     </span><span class="nottickedoff">-&gt; (Expression, Expression)</span>
<span class="lineno">  296 </span><span class="spaces">     </span><span class="nottickedoff">-&gt; [(Rule, [String], String)]</span>
<span class="lineno">  297 </span><span class="spaces">  </span><span class="nottickedoff">f [] (_,_) = []</span>
<span class="lineno">  298 </span><span class="spaces">  </span><span class="nottickedoff">f [(e',_,_)] (neg',pos')</span>
<span class="lineno">  299 </span><span class="spaces">   </span><span class="nottickedoff">= [(rule (subst (dcl',neg') e') (subst (dcl',pos') e'),[],&quot;&quot;)]</span>
<span class="lineno">  300 </span><span class="spaces">  </span><span class="nottickedoff">f ((e',[&quot;invert&quot;],_): prf@((_,_,_):_)) (neg',pos')</span>
<span class="lineno">  301 </span><span class="spaces">   </span><span class="nottickedoff">= (rule (subst (dcl',neg') e') (subst (dcl',pos') e'),[&quot;r |- s  &lt;=&gt;  s- |- r-&quot;],&quot;&lt;=&gt;&quot;):</span>
<span class="lineno">  302 </span><span class="spaces">      </span><span class="nottickedoff">f prf (pos',neg')</span>
<span class="lineno">  303 </span><span class="spaces">  </span><span class="nottickedoff">f ((e1,_,_): prf@((e2,_,_):_)) (neg',pos')</span>
<span class="lineno">  304 </span><span class="spaces">   </span><span class="nottickedoff">= (rule (subst (dcl',neg') e1) (subst (dcl',pos') e1),[&quot;Monotony of &quot;++showOp e2],&quot;==&gt;&quot;):</span>
<span class="lineno">  305 </span><span class="spaces">      </span><span class="nottickedoff">f prf (neg',pos')</span>
<span class="lineno">  306 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  307 </span><span class="spaces">  </span><span class="nottickedoff">start Ins  = (EDcD dcl',EDcD dcl' .\/. delta (sign dcl'))</span>
<span class="lineno">  308 </span><span class="spaces">  </span><span class="nottickedoff">start Del  = (EDcD dcl' ./\. notCpl (delta (sign dcl')),EDcD dcl')</span>
<span class="lineno">  309 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  310 </span><span class="spaces">  </span><span class="nottickedoff">rule :: Expression -&gt; Expression -&gt; Rule</span>
<span class="lineno">  311 </span><span class="spaces">  </span><span class="nottickedoff">rule neg' pos' | isTrue neg' = Ru { rrnm  = &quot;&quot;</span>
<span class="lineno">  312 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrfps = Origin &quot;rule generated for isTrue neg' by Calc&quot;</span>
<span class="lineno">  313 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrexp = pos'</span>
<span class="lineno">  314 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrmean = AMeaning</span>
<span class="lineno">  315 </span><span class="spaces">                                               </span><span class="nottickedoff">[A_Markup Dutch   ReST (string2Blocks ReST &quot;Waarom wordt deze regel hier aangemaakt? (In Calc.hs, regel 402)&quot;)</span>
<span class="lineno">  316 </span><span class="spaces">                                               </span><span class="nottickedoff">,A_Markup English ReST (string2Blocks ReST &quot;Why is this rule created? (In Calc.hs, line 403)&quot;)]  --TODO Stef, gaarne de explanations aanvullen/verwijderen. Dank! Han.</span>
<span class="lineno">  317 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrmsg = []</span>
<span class="lineno">  318 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrviol = Nothing</span>
<span class="lineno">  319 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrtyp = sign neg' {- (neg `meet` pos) -}</span>
<span class="lineno">  320 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrdcl = Nothing</span>
<span class="lineno">  321 </span><span class="spaces">                                    </span><span class="nottickedoff">, r_env = &quot;&quot;</span>
<span class="lineno">  322 </span><span class="spaces">                                    </span><span class="nottickedoff">, r_usr = Multiplicity</span>
<span class="lineno">  323 </span><span class="spaces">                                    </span><span class="nottickedoff">, isSignal = fatal 336 $ &quot;erroneous reference to isSignal in rule (&quot;++showADL neg'++&quot;) |- (&quot;++showADL pos'++&quot;)&quot;</span>
<span class="lineno">  324 </span><span class="spaces">                                    </span><span class="nottickedoff">}</span>
<span class="lineno">  325 </span><span class="spaces">                 </span><span class="nottickedoff">| otherwise   = Ru { rrnm  = &quot;&quot;</span>
<span class="lineno">  326 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrfps = Origin &quot;rule generated for not(isTrue neg') by Calc&quot;</span>
<span class="lineno">  327 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrexp = neg' .|-. pos'</span>
<span class="lineno">  328 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrmean = AMeaning</span>
<span class="lineno">  329 </span><span class="spaces">                                               </span><span class="nottickedoff">[A_Markup Dutch   ReST (string2Blocks ReST &quot;Waarom wordt deze regel hier aangemaakt? (In Calc.hs, regel 332)&quot;)</span>
<span class="lineno">  330 </span><span class="spaces">                                               </span><span class="nottickedoff">,A_Markup English ReST (string2Blocks ReST &quot;Why is this rule created? (In Calc.hs, line 333)&quot;)]  --TODO Stef, gaarne de explanations aanvullen/verwijderen. Dank! Han.</span>
<span class="lineno">  331 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrmsg = []</span>
<span class="lineno">  332 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrviol = Nothing</span>
<span class="lineno">  333 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrtyp = sign neg' {- (neg `meet` pos) -}</span>
<span class="lineno">  334 </span><span class="spaces">                                    </span><span class="nottickedoff">, rrdcl = Nothing</span>
<span class="lineno">  335 </span><span class="spaces">                                    </span><span class="nottickedoff">, r_env = &quot;&quot;</span>
<span class="lineno">  336 </span><span class="spaces">                                    </span><span class="nottickedoff">, r_usr = Multiplicity</span>
<span class="lineno">  337 </span><span class="spaces">                                    </span><span class="nottickedoff">, isSignal = fatal 352 $ &quot;illegal reference to isSignal in rule (&quot;++showADL neg'++&quot;) |- (&quot;++showADL pos'++&quot;)&quot;</span>
<span class="lineno">  338 </span><span class="spaces">                                    </span><span class="nottickedoff">}</span>
<span class="lineno">  339 </span><span class="spaces">  </span><span class="nottickedoff">showOp expr' = case expr' of</span>
<span class="lineno">  340 </span><span class="spaces">                  </span><span class="nottickedoff">EEqu{} -&gt; &quot;=&quot;</span>
<span class="lineno">  341 </span><span class="spaces">                  </span><span class="nottickedoff">EImp{} -&gt; &quot;|-&quot;</span>
<span class="lineno">  342 </span><span class="spaces">                  </span><span class="nottickedoff">EIsc{} -&gt; &quot;/\\&quot;</span>
<span class="lineno">  343 </span><span class="spaces">                  </span><span class="nottickedoff">EUni{} -&gt; &quot;\\/&quot;</span>
<span class="lineno">  344 </span><span class="spaces">                  </span><span class="nottickedoff">EDif{} -&gt; &quot;-&quot;</span>
<span class="lineno">  345 </span><span class="spaces">                  </span><span class="nottickedoff">ELrs{} -&gt; &quot;/&quot;</span>
<span class="lineno">  346 </span><span class="spaces">                  </span><span class="nottickedoff">ERrs{} -&gt; &quot;\\&quot;</span>
<span class="lineno">  347 </span><span class="spaces">                  </span><span class="nottickedoff">EDia{} -&gt; &quot;&lt;&gt;&quot;</span>
<span class="lineno">  348 </span><span class="spaces">                  </span><span class="nottickedoff">ECps{} -&gt; &quot;;&quot;</span>
<span class="lineno">  349 </span><span class="spaces">                  </span><span class="nottickedoff">ERad{} -&gt; &quot;!&quot;</span>
<span class="lineno">  350 </span><span class="spaces">                  </span><span class="nottickedoff">EPrd{} -&gt; &quot;*&quot;</span>
<span class="lineno">  351 </span><span class="spaces">                  </span><span class="nottickedoff">EKl0{} -&gt; &quot;*&quot;</span>
<span class="lineno">  352 </span><span class="spaces">                  </span><span class="nottickedoff">EKl1{} -&gt; &quot;+&quot;</span>
<span class="lineno">  353 </span><span class="spaces">                  </span><span class="nottickedoff">EFlp{} -&gt; &quot;~&quot;</span>
<span class="lineno">  354 </span><span class="spaces">                  </span><span class="nottickedoff">ECpl{} -&gt; &quot;-&quot;</span>
<span class="lineno">  355 </span><span class="spaces">                  </span><span class="nottickedoff">_      -&gt; &quot;&quot;</span></span>
<span class="lineno">  356 </span>
<span class="lineno">  357 </span>{- The purpose of function lambda is to generate a derivation.
<span class="lineno">  358 </span>Rewrite rules:
<span class="lineno">  359 </span>-r;-s -&gt; -(r!s)
<span class="lineno">  360 </span>-}
<span class="lineno">  361 </span>lambda :: InsDel -&gt; Expression
<span class="lineno">  362 </span>                 -&gt; Expression
<span class="lineno">  363 </span>                 -&gt; [Proof Expression]
<span class="lineno">  364 </span><span class="decl"><span class="nottickedoff">lambda tOp' e' expr' = [reversePrf[(e'',txt,op)</span>
<span class="lineno">  365 </span><span class="spaces">                       </span><span class="nottickedoff">| (e'',_,txt,op)&lt;-prf]</span>
<span class="lineno">  366 </span><span class="spaces">                       </span><span class="nottickedoff">| prf&lt;-lam tOp' e' expr' ]</span>
<span class="lineno">  367 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno">  368 </span><span class="spaces">  </span><span class="nottickedoff">lam :: InsDel -&gt; Expression -&gt; Expression -&gt;</span>
<span class="lineno">  369 </span><span class="spaces">         </span><span class="nottickedoff">[[(Expression,Expression -&gt; Expression,[String],String)]]</span>
<span class="lineno">  370 </span><span class="spaces">  </span><span class="nottickedoff">lam tOp e3 expr =</span>
<span class="lineno">  371 </span><span class="spaces">       </span><span class="nottickedoff">case expr of</span>
<span class="lineno">  372 </span><span class="spaces">          </span><span class="nottickedoff">EIsc{}  | e3==expr             -&gt; [[(e3,id,[],&quot;&quot;)]]</span>
<span class="lineno">  373 </span><span class="spaces">                  </span><span class="nottickedoff">| length (const' expr)&gt;0 -&gt; [(expr,\_-&gt;expr,      [derivtext tOp &quot;mono&quot; (inter' expr) expr],&quot;&lt;--&quot;) :prf</span>
<span class="lineno">  374 </span><span class="spaces">                                              </span><span class="nottickedoff">| prf&lt;-lam tOp e3 (inter' expr)</span>
<span class="lineno">  375 </span><span class="spaces">                                              </span><span class="nottickedoff">]</span>
<span class="lineno">  376 </span><span class="spaces">                  </span><span class="nottickedoff">| and [isNeg f |f&lt;-exprIsc2list expr]</span>
<span class="lineno">  377 </span><span class="spaces">                                         </span><span class="nottickedoff">-&gt; let deMrg = deMorganEIsc expr in</span>
<span class="lineno">  378 </span><span class="spaces">                                            </span><span class="nottickedoff">[(expr, deMorganEIsc, [derivtext tOp &quot;equal&quot; deMrg expr],&quot;==&quot;) :prf | prf&lt;-lam tOp e3 deMrg]</span>
<span class="lineno">  379 </span><span class="spaces">                  </span><span class="nottickedoff">| or[null p |p&lt;-fPrfs] -&gt; []</span>
<span class="lineno">  380 </span><span class="spaces">                  </span><span class="nottickedoff">| otherwise            -&gt; [(expr,\_-&gt;expr,    [derivtext tOp &quot;mono&quot; (first lc) expr],&quot;&lt;--&quot;) : lc]</span>
<span class="lineno">  381 </span><span class="spaces">          </span><span class="nottickedoff">EUni{}  | e3==expr             -&gt; [[(e3,id,[],&quot;&quot;)]]</span>
<span class="lineno">  382 </span><span class="spaces">                  </span><span class="nottickedoff">| length (const' expr)&gt;0 -&gt; [(expr,\_-&gt;expr, [derivtext tOp &quot;mono&quot; (inter' expr) expr],&quot;&lt;--&quot;) :prf</span>
<span class="lineno">  383 </span><span class="spaces">                                                   </span><span class="nottickedoff">| prf&lt;-lam tOp e3 (inter' expr)</span>
<span class="lineno">  384 </span><span class="spaces">                                                   </span><span class="nottickedoff">]</span>
<span class="lineno">  385 </span><span class="spaces">                  </span><span class="nottickedoff">| and [isNeg f |f&lt;-exprUni2list expr]</span>
<span class="lineno">  386 </span><span class="spaces">                                         </span><span class="nottickedoff">-&gt; let deMrg = deMorganEUni expr in</span>
<span class="lineno">  387 </span><span class="spaces">                                            </span><span class="nottickedoff">[(expr, deMorganEUni, [derivtext tOp &quot;equal&quot; deMrg expr],&quot;==&quot;) :prf | prf&lt;-lam tOp e3 deMrg]</span>
<span class="lineno">  388 </span><span class="spaces">                  </span><span class="nottickedoff">| or[null p |p&lt;-fPrfs] -&gt; []</span>
<span class="lineno">  389 </span><span class="spaces">                  </span><span class="nottickedoff">| otherwise            -&gt; [(expr,\_-&gt;expr,    [derivtext tOp &quot;mono&quot; (first lc) expr],&quot;&lt;--&quot;) : lc]</span>
<span class="lineno">  390 </span><span class="spaces">          </span><span class="nottickedoff">ECps{}  | e3==expr             -&gt; [[(e3,id,[],&quot;&quot;)]]</span>
<span class="lineno">  391 </span><span class="spaces">                  </span><span class="nottickedoff">| and [isNeg f |f&lt;-exprCps2list expr]</span>
<span class="lineno">  392 </span><span class="spaces">                                         </span><span class="nottickedoff">-&gt; let deMrg = deMorganECps expr in</span>
<span class="lineno">  393 </span><span class="spaces">                                            </span><span class="nottickedoff">[(expr, deMorganECps, [derivtext tOp &quot;equal&quot; deMrg expr],&quot;==&quot;)</span>
<span class="lineno">  394 </span><span class="spaces">                                            </span><span class="nottickedoff">:prf</span>
<span class="lineno">  395 </span><span class="spaces">                                            </span><span class="nottickedoff">| prf&lt;-lam tOp e3 deMrg</span>
<span class="lineno">  396 </span><span class="spaces">                                            </span><span class="nottickedoff">] -- isNeg is nog niet helemaal correct.</span>
<span class="lineno">  397 </span><span class="spaces">                  </span><span class="nottickedoff">| or[null p|p&lt;-fPrfs]  -&gt; []</span>
<span class="lineno">  398 </span><span class="spaces">                  </span><span class="nottickedoff">| otherwise            -&gt; [(expr,\_-&gt;expr,    [derivtext tOp &quot;mono&quot; (first lc) expr],&quot;&lt;--&quot;): lc]</span>
<span class="lineno">  399 </span><span class="spaces">          </span><span class="nottickedoff">ERad{}  | e3==expr             -&gt; [[(e3,id,[],&quot;&quot;)]]</span>
<span class="lineno">  400 </span><span class="spaces">                  </span><span class="nottickedoff">| and [isNeg f |f&lt;-exprRad2list expr]</span>
<span class="lineno">  401 </span><span class="spaces">                                         </span><span class="nottickedoff">-&gt; let deMrg = deMorganERad expr in</span>
<span class="lineno">  402 </span><span class="spaces">                                            </span><span class="nottickedoff">[(expr, deMorganERad, [derivtext tOp &quot;equal&quot; deMrg expr],&quot;==&quot;) :prf | prf&lt;-lam tOp e3 deMrg] -- isNeg is nog niet helemaal correct.</span>
<span class="lineno">  403 </span><span class="spaces">                  </span><span class="nottickedoff">| or[null p |p&lt;-fPrfs] -&gt; []</span>
<span class="lineno">  404 </span><span class="spaces">                  </span><span class="nottickedoff">| otherwise            -&gt; [(expr,\_-&gt;expr,    [derivtext tOp &quot;mono&quot; (first lc) expr],&quot;&lt;--&quot;): lc]</span>
<span class="lineno">  405 </span><span class="spaces">          </span><span class="nottickedoff">EKl0 x                         -&gt; [(expr,\e-&gt;EKl0 e,[derivtext tOp &quot;mono&quot; x expr],&quot;&lt;--&quot;) :prf   | prf&lt;-lam tOp e3 x]</span>
<span class="lineno">  406 </span><span class="spaces">          </span><span class="nottickedoff">EKl1 x                         -&gt; [(expr,\e-&gt;EKl1 e,[derivtext tOp &quot;mono&quot; x expr],&quot;&lt;--&quot;) :prf   | prf&lt;-lam tOp e3 x]</span>
<span class="lineno">  407 </span><span class="spaces">          </span><span class="nottickedoff">ECpl x                         -&gt; [(expr,\e-&gt;ECpl e,[&quot;invert&quot;],&quot;&lt;--&quot;) :prf | prf&lt;-lam (inv tOp) e3 x]</span>
<span class="lineno">  408 </span><span class="spaces">          </span><span class="nottickedoff">EBrk x                         -&gt; lam tOp e3 x</span>
<span class="lineno">  409 </span><span class="spaces">          </span><span class="nottickedoff">_                              -&gt; [[(e3,id,[],&quot;&quot;)]]</span>
<span class="lineno">  410 </span><span class="spaces">        </span><span class="nottickedoff">where</span>
<span class="lineno">  411 </span><span class="spaces">            </span><span class="nottickedoff">sgn   = sign expr</span>
<span class="lineno">  412 </span><span class="spaces">            </span><span class="nottickedoff">fPrfs = case expr of</span>
<span class="lineno">  413 </span><span class="spaces">                     </span><span class="nottickedoff">EUni{} -&gt; [lam tOp e3 f |f&lt;-exprUni2list expr, isVar f e3]</span>
<span class="lineno">  414 </span><span class="spaces">                     </span><span class="nottickedoff">EIsc{} -&gt; [lam tOp e3 f |f&lt;-exprIsc2list expr, isVar f e3]</span>
<span class="lineno">  415 </span><span class="spaces">                     </span><span class="nottickedoff">ECps{} -&gt; [lam tOp e3 f |f&lt;-exprCps2list expr, isVar f e3]</span>
<span class="lineno">  416 </span><span class="spaces">                     </span><span class="nottickedoff">ERad{} -&gt; [lam tOp e3 f |f&lt;-exprRad2list expr, isVar f e3]</span>
<span class="lineno">  417 </span><span class="spaces">                     </span><span class="nottickedoff">_      -&gt; fatal 428 (&quot;fPrfs  is not defined.Consult your dealer!&quot;)</span>
<span class="lineno">  418 </span><span class="spaces">            </span><span class="nottickedoff">lc = longstcomn vars++concat (drop (length rc-1) (sortWith length rc))</span>
<span class="lineno">  419 </span><span class="spaces">            </span><span class="nottickedoff">rc = remainders vars vars</span>
<span class="lineno">  420 </span><span class="spaces">            </span><span class="nottickedoff">vars = map head fPrfs</span>
<span class="lineno">  421 </span><span class="spaces">            </span><span class="nottickedoff">const' e@EUni{} = [f |f&lt;-exprUni2list e, isConst f e3]</span>
<span class="lineno">  422 </span><span class="spaces">            </span><span class="nottickedoff">const' e@EIsc{} = [f |f&lt;-exprIsc2list e, isConst f e3]</span>
<span class="lineno">  423 </span><span class="spaces">            </span><span class="nottickedoff">const' expr'' = fatal 440 $ &quot;'const'(&quot;++ show expr''++&quot;)' is not defined.Consult your dealer!&quot;</span>
<span class="lineno">  424 </span><span class="spaces">            </span><span class="nottickedoff">inter' e@EUni{} = foldr (.\/.) (notCpl (EDcV sgn)) [f |f&lt;-exprUni2list e, isVar f e3]</span>
<span class="lineno">  425 </span><span class="spaces">            </span><span class="nottickedoff">inter' e@EIsc{} = if and [sgn==sign f | f&lt;-exprIsc2list e, isVar f e3]</span>
<span class="lineno">  426 </span><span class="spaces">                              </span><span class="nottickedoff">then foldr (./\.) (EDcV sgn) [f | f&lt;-exprIsc2list e, isVar f e3]</span>
<span class="lineno">  427 </span><span class="spaces">                              </span><span class="nottickedoff">else fatal 532 (&quot;signature error in inter'  &quot;++show [(showADL f,showSign (sign f)) | f&lt;-exprIsc2list e, isVar f e3])</span>
<span class="lineno">  428 </span><span class="spaces">            </span><span class="nottickedoff">inter' expr'' = fatal 443 $ &quot;'inter'(&quot;++ show expr''++&quot;)' is not defined.Consult your dealer!&quot;</span>
<span class="lineno">  429 </span><span class="spaces"></span><span class="nottickedoff">--      lam tOp e f       = []</span>
<span class="lineno">  430 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  431 </span><span class="spaces"></span><span class="nottickedoff">-- longstcomn determines the longest prefix common to all xs in xss.</span>
<span class="lineno">  432 </span><span class="spaces">  </span><span class="nottickedoff">longstcomn :: (Eq a) =&gt; [[(a, b, c, d)]] -&gt; [(a, b, c, d)]</span>
<span class="lineno">  433 </span><span class="spaces">  </span><span class="nottickedoff">longstcomn xss | or [null xs | xs&lt;-xss]      = []</span>
<span class="lineno">  434 </span><span class="spaces">                 </span><span class="nottickedoff">| length (eqCl first xss)==1 = head [head prf | prf&lt;-xss]: longstcomn [tail prf | prf&lt;-xss]</span>
<span class="lineno">  435 </span><span class="spaces">                 </span><span class="nottickedoff">| otherwise                  = []</span>
<span class="lineno">  436 </span><span class="spaces"> </span><span class="nottickedoff">-- remainders determines the remainders.</span>
<span class="lineno">  437 </span><span class="spaces">  </span><span class="nottickedoff">remainders :: (Eq a) =&gt; [[(a, b, c, d)]] -&gt; [[(a, b, c, d)]] -&gt; [[(a, b, c, d)]]</span>
<span class="lineno">  438 </span><span class="spaces">  </span><span class="nottickedoff">remainders _ xss | or [null xs | xs&lt;-xss]      = xss</span>
<span class="lineno">  439 </span><span class="spaces">                   </span><span class="nottickedoff">| length (eqCl first xss)==1 = remainders xss [tail prf | prf&lt;-xss]</span>
<span class="lineno">  440 </span><span class="spaces">                   </span><span class="nottickedoff">| otherwise                  = xss</span>
<span class="lineno">  441 </span><span class="spaces">  </span><span class="nottickedoff">isConst :: (ConceptStructure a, ConceptStructure b) =&gt; a-&gt;b-&gt;Bool</span>
<span class="lineno">  442 </span><span class="spaces">  </span><span class="nottickedoff">isConst e f = null (relsUsedIn e `isc` relsUsedIn f)</span>
<span class="lineno">  443 </span><span class="spaces">  </span><span class="nottickedoff">isVar :: (ConceptStructure a, ConceptStructure b) =&gt; a-&gt;b-&gt;Bool</span>
<span class="lineno">  444 </span><span class="spaces">  </span><span class="nottickedoff">isVar e f   = not (isConst e f)</span>
<span class="lineno">  445 </span><span class="spaces">  </span><span class="nottickedoff">derivtext :: InsDel -&gt; String -&gt; Expression -&gt; Expression -&gt; String</span>
<span class="lineno">  446 </span><span class="spaces">  </span><span class="nottickedoff">derivtext tOp &quot;invert&quot; e'' expr = sh tOp++showADL e''++&quot; means &quot;++sh (inv tOp)++showADL expr++&quot;.&quot;</span>
<span class="lineno">  447 </span><span class="spaces">  </span><span class="nottickedoff">derivtext tOp &quot;mono&quot;    e'' expr = &quot;(&quot;++showADL e''++&quot;-&gt;&quot;++showADL expr++&quot;) is monotonous, so &quot;++sh tOp++showADL e''++&quot; means &quot;++sh tOp++showADL expr++&quot;.&quot;</span>
<span class="lineno">  448 </span><span class="spaces">  </span><span class="nottickedoff">derivtext _ txt _ _ = txt</span>
<span class="lineno">  449 </span><span class="spaces">  </span><span class="nottickedoff">sh :: InsDel -&gt; String</span>
<span class="lineno">  450 </span><span class="spaces">  </span><span class="nottickedoff">sh Ins  = &quot;insert into &quot;</span>
<span class="lineno">  451 </span><span class="spaces">  </span><span class="nottickedoff">sh Del  = &quot;delete from &quot;</span>
<span class="lineno">  452 </span><span class="spaces">  </span><span class="nottickedoff">inv :: InsDel -&gt; InsDel</span>
<span class="lineno">  453 </span><span class="spaces">  </span><span class="nottickedoff">inv Ins = Del</span>
<span class="lineno">  454 </span><span class="spaces">  </span><span class="nottickedoff">inv Del = Ins</span>
<span class="lineno">  455 </span><span class="spaces">  </span><span class="nottickedoff">first :: [(a,b,c,d)] -&gt; a</span>
<span class="lineno">  456 </span><span class="spaces">  </span><span class="nottickedoff">first ((e'',_,_,_):_) = e''</span>
<span class="lineno">  457 </span><span class="spaces">  </span><span class="nottickedoff">first _ = fatal 472 &quot;wrong pattern in first&quot;</span></span>
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>ruleType :: Rule -&gt; RuleType
<span class="lineno">  460 </span><span class="decl"><span class="nottickedoff">ruleType r = case rrexp r of</span>
<span class="lineno">  461 </span><span class="spaces">              </span><span class="nottickedoff">EEqu{} -&gt; Equivalence</span>
<span class="lineno">  462 </span><span class="spaces">              </span><span class="nottickedoff">EImp{} -&gt; Implication</span>
<span class="lineno">  463 </span><span class="spaces">              </span><span class="nottickedoff">_      -&gt; Truth</span></span>
<span class="lineno">  464 </span>
<span class="lineno">  465 </span>-- | Action semantics for inserting a delta into a relation dcl.
<span class="lineno">  466 </span>actSem :: Options -&gt; InsDel -&gt; Expression -&gt; Expression -&gt; Expression
<span class="lineno">  467 </span><span class="decl"><span class="nottickedoff">actSem opts Ins dcl delt | sign dcl/=sign delt = fatal 598 &quot;Type error in actSem Ins&quot;</span>
<span class="lineno">  468 </span><span class="spaces">                         </span><span class="nottickedoff">| dcl==delt           = dcl</span>
<span class="lineno">  469 </span><span class="spaces">                         </span><span class="nottickedoff">| otherwise           = disjNF opts (dcl .\/. delt)</span>
<span class="lineno">  470 </span><span class="spaces"></span><span class="nottickedoff">actSem opts Del dcl delt | sign dcl/=sign delt = fatal 598 &quot;Type error in actSem Del&quot;</span>
<span class="lineno">  471 </span><span class="spaces">                         </span><span class="nottickedoff">| dcl==delt           = notCpl (EDcV (sign dcl))</span>
<span class="lineno">  472 </span><span class="spaces">                         </span><span class="nottickedoff">| otherwise           = conjNF opts (dcl ./\. notCpl delt)</span></span>
<span class="lineno">  473 </span>
<span class="lineno">  474 </span>-- | assembleECAs  assembles larger chunks of code, because it combines acts that are triggered by the same event.
<span class="lineno">  475 </span>assembleECAs :: Options -&gt; A_Context -&gt; [Declaration] -&gt; ([ECArule],[Blocks])
<span class="lineno">  476 </span><span class="decl"><span class="nottickedoff">assembleECAs options context editables</span>
<span class="lineno">  477 </span><span class="spaces"> </span><span class="nottickedoff">= unzip [eca i | (eca,i) &lt;- zip ecas [(1::Int)..]]</span>
<span class="lineno">  478 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno">  479 </span><span class="spaces">    </span><span class="nottickedoff">ecas :: [Int-&gt;(ECArule,Blocks)]</span>
<span class="lineno">  480 </span><span class="spaces">    </span><span class="nottickedoff">ecas</span>
<span class="lineno">  481 </span><span class="spaces">      </span><span class="nottickedoff">= [ (\ruleNr-&gt;( ECA ecaEvt delt normEcaAct ruleNr</span>
<span class="lineno">  482 </span><span class="spaces">                    </span><span class="nottickedoff">, para (&quot;Let us analyse what happens &quot;&lt;&gt;str (show (On ev rel))&lt;&gt;&quot;.&quot;)&lt;&gt;</span>
<span class="lineno">  483 </span><span class="spaces">                      </span><span class="nottickedoff">bulletList [ txt | (_,_,_,txt)&lt;-acts]&lt;&gt;</span>
<span class="lineno">  484 </span><span class="spaces">                      </span><span class="nottickedoff">( if length ecaProof&gt;1</span>
<span class="lineno">  485 </span><span class="spaces">                        </span><span class="nottickedoff">then para (&quot;The resulting action is:\n     &quot;)&lt;&gt;</span>
<span class="lineno">  486 </span><span class="spaces">                             </span><span class="nottickedoff">showProof (codeBlock . (&quot;\n     &quot;++) . showECA &quot;\n     &quot;) ecaProof</span>
<span class="lineno">  487 </span><span class="spaces">                        </span><span class="nottickedoff">else fromList []</span>
<span class="lineno">  488 </span><span class="spaces">                      </span><span class="nottickedoff">)&lt;&gt;</span>
<span class="lineno">  489 </span><span class="spaces">                      </span><span class="nottickedoff">para (&quot;These results lead to the following ECA-rule:\n     &quot;)&lt;&gt;</span>
<span class="lineno">  490 </span><span class="spaces">                      </span><span class="nottickedoff">(codeBlock . (&quot;\n     &quot;++) . showECA &quot;\n     &quot;.ecaRule) ruleNr</span>
<span class="lineno">  491 </span><span class="spaces">                    </span><span class="nottickedoff">)</span>
<span class="lineno">  492 </span><span class="spaces">          </span><span class="nottickedoff">)</span>
<span class="lineno">  493 </span><span class="spaces">        </span><span class="nottickedoff">| rel &lt;- editables -- allDecls fSpec ++ [ Isn c | c&lt;-allConcepts fSpec, c/=ONE] -- This is the relation in which a delta is being inserted or deleted.</span>
<span class="lineno">  494 </span><span class="spaces"> </span><span class="nottickedoff">--       , let relEq = [ q | q&lt;-vquads fSpec, qDcl q==rel] -- Gather the quads with the same declaration (qDcl). A quad has a declaration (qDcl), a rule (qRule) and clauses qConjuncts</span>
<span class="lineno">  495 </span><span class="spaces">        </span><span class="nottickedoff">, let EDcD delt = delta (sign rel)                -- delt is a placeholder for the pairs that have been inserted or deleted in rel.</span>
<span class="lineno">  496 </span><span class="spaces">        </span><span class="nottickedoff">, ev&lt;-[Ins,Del]</span>
<span class="lineno">  497 </span><span class="spaces">        </span><span class="nottickedoff">, let acts = [ -- go through all the events that affect that clause:</span>
<span class="lineno">  498 </span><span class="spaces">                       </span><span class="nottickedoff">( normPA options act   -- a normalized action for this event-conjunct combination</span>
<span class="lineno">  499 </span><span class="spaces">                       </span><span class="nottickedoff">, conjunct             -- the conjunct</span>
<span class="lineno">  500 </span><span class="spaces">                       </span><span class="nottickedoff">, map snd conjEqClass  -- the rule-expression of which conjunct is a part</span>
<span class="lineno">  501 </span><span class="spaces">                       </span><span class="nottickedoff">, para (&quot;Let us analyse clause &quot;&lt;&gt;str (showADL expr)&lt;&gt;&quot; from rule &quot;&lt;&gt;commaEngPandoc' &quot;and&quot; (map (singleQuoted.str.name.snd) conjEqClass)&lt;&gt;&quot;.&quot;)&lt;&gt;</span>
<span class="lineno">  502 </span><span class="spaces">                         </span><span class="nottickedoff">para (&quot;event = &quot;&lt;&gt;str (show ev)&lt;&gt;space&lt;&gt;str (showREL rel)&lt;&gt;&quot; means doing the following substitution&quot;)&lt;&gt;</span>
<span class="lineno">  503 </span><span class="spaces">                         </span><span class="nottickedoff">para (str (showADL clause&lt;&gt;&quot;[&quot;&lt;&gt;showREL rel&lt;&gt;&quot;:=&quot;&lt;&gt;showADL (actSem options ev (EDcD rel) (delta (sign rel)))&lt;&gt;&quot;] = clause'&quot;))&lt;&gt;</span>
<span class="lineno">  504 </span><span class="spaces">                         </span><span class="nottickedoff">para (&quot;clause' = &quot;&lt;&gt;str (showADL ex')&lt;&gt;</span>
<span class="lineno">  505 </span><span class="spaces">                               </span><span class="nottickedoff">if clause'==ex'</span>
<span class="lineno">  506 </span><span class="spaces">                               </span><span class="nottickedoff">then &quot;, which is already in conjunctive normal form.&quot;&lt;&gt;linebreak</span>
<span class="lineno">  507 </span><span class="spaces">                               </span><span class="nottickedoff">else &quot;, which has conjunctive normal form: &quot;&lt;&gt;linebreak&lt;&gt;str (showADL clause')</span>
<span class="lineno">  508 </span><span class="spaces">                              </span><span class="nottickedoff">)&lt;&gt;</span>
<span class="lineno">  509 </span><span class="spaces">                         </span><span class="nottickedoff">para (&quot;Let us compute the violations to see whether invariance is maintained.&quot;&lt;&gt;linebreak&lt;&gt;</span>
<span class="lineno">  510 </span><span class="spaces">                               </span><span class="nottickedoff">&quot;This means to negate the result (notClau = notCpl clause'): &quot;)&lt;&gt;</span>
<span class="lineno">  511 </span><span class="spaces">                         </span><span class="nottickedoff">(showProof (para.str.showADL). cfProof options) notClau&lt;&gt;</span>
<span class="lineno">  512 </span><span class="spaces">                         </span><span class="nottickedoff">para (&quot;So, notClau has CNF: &quot;&lt;&gt;str (showADL viols )&lt;&gt;linebreak&lt;&gt;</span>
<span class="lineno">  513 </span><span class="spaces">                               </span><span class="nottickedoff">( if viols==viols'</span>
<span class="lineno">  514 </span><span class="spaces">                                 </span><span class="nottickedoff">then &quot;This expression is in disjunctive normal form as well.&quot;</span>
<span class="lineno">  515 </span><span class="spaces">                                 </span><span class="nottickedoff">else str (&quot;In DNF, notClau is:  &quot;&lt;&gt;showADL viols'&lt;&gt;&quot;.&quot;)))&lt;&gt;</span>
<span class="lineno">  516 </span><span class="spaces">                         </span><span class="nottickedoff">( if isTrue clause'</span>
<span class="lineno">  517 </span><span class="spaces">                           </span><span class="nottickedoff">then para (&quot;This result proves the absence of violations, so a reaction of doing nothing is appropriate.&quot;&lt;&gt;linebreak</span>
<span class="lineno">  518 </span><span class="spaces">                                      </span><span class="nottickedoff">&lt;&gt;&quot;Just for fun, let us try to derive whether clause |- clause' is true... &quot;)&lt;&gt;</span>
<span class="lineno">  519 </span><span class="spaces">                                </span><span class="nottickedoff">(showProof (para.str.showADL). cfProof options) (expr .|-. clause')</span>
<span class="lineno">  520 </span><span class="spaces">                           </span><span class="nottickedoff">else para (&quot;This result does not prove the absence of violations, so we cannot conclude that invariance is maintained.&quot;&lt;&gt;linebreak&lt;&gt;</span>
<span class="lineno">  521 </span><span class="spaces">                                      </span><span class="nottickedoff">&quot;We must compute a reaction to compensate for violations...&quot;&lt;&gt;linebreak&lt;&gt;</span>
<span class="lineno">  522 </span><span class="spaces">                                      </span><span class="nottickedoff">&quot;That would be to reinsert violations that originate from &quot;&lt;&gt;</span>
<span class="lineno">  523 </span><span class="spaces">                                      </span><span class="nottickedoff">( if ev==Ins</span>
<span class="lineno">  524 </span><span class="spaces">                                        </span><span class="nottickedoff">then str (showADL (conjNF options negs))&lt;&gt;&quot; into &quot;&lt;&gt; str (showADL (disjNF options poss))&lt;&gt;&quot;.&quot;</span>
<span class="lineno">  525 </span><span class="spaces">                                        </span><span class="nottickedoff">else str (showADL (disjNF options poss))&lt;&gt;&quot; into &quot;&lt;&gt; str (showADL (conjNF options negs))&lt;&gt;&quot;.&quot;</span>
<span class="lineno">  526 </span><span class="spaces">                                      </span><span class="nottickedoff">)&lt;&gt;linebreak&lt;&gt;&quot;deltFr: &quot;)&lt;&gt;</span>
<span class="lineno">  527 </span><span class="spaces">                                </span><span class="nottickedoff">(showProof (para.str.showADL). dfProof options) deltFr&lt;&gt;</span>
<span class="lineno">  528 </span><span class="spaces">                                </span><span class="nottickedoff">( let pr=proofPA options act in</span>
<span class="lineno">  529 </span><span class="spaces">                                  </span><span class="nottickedoff">if length pr&gt;1</span>
<span class="lineno">  530 </span><span class="spaces">                                  </span><span class="nottickedoff">then para &quot;Now let us remove redundancy from the ECA action:\n     &quot;&lt;&gt;</span>
<span class="lineno">  531 </span><span class="spaces">                                       </span><span class="nottickedoff">showProof (codeBlock . (&quot;\n     &quot;++) . showECA &quot;\n     &quot;) (proofPA options act)</span>
<span class="lineno">  532 </span><span class="spaces">                                  </span><span class="nottickedoff">else fromList []</span>
<span class="lineno">  533 </span><span class="spaces">                                </span><span class="nottickedoff">)</span>
<span class="lineno">  534 </span><span class="spaces">                         </span><span class="nottickedoff">{-     &lt;&gt; &quot;To finish the analysis of case &quot;&lt;&gt;str (show ev)&lt;&gt;space&lt;&gt;str (showADL rel)</span>
<span class="lineno">  535 </span><span class="spaces">                                   </span><span class="nottickedoff">&lt;&gt;&quot;, let us compute the contents of &quot;&lt;&gt;str (showADL toExpr)&lt;&gt;&quot; after insertion of viols.&quot;&lt;&gt;linebreak</span>
<span class="lineno">  536 </span><span class="spaces">                                   </span><span class="nottickedoff">&lt;&gt;</span>
<span class="lineno">  537 </span><span class="spaces">                                </span><span class="nottickedoff">( if length (nub [sign viols, sign viols', sign toExpr])&gt;1</span>
<span class="lineno">  538 </span><span class="spaces">                                  </span><span class="nottickedoff">then fatal 248 (&quot;viols&quot;&lt;&gt;showSign (sign viols) &lt;&gt;&quot;   &quot;&lt;&gt;showADL viols &lt;&gt;&quot;\n&quot;&lt;&gt;</span>
<span class="lineno">  539 </span><span class="spaces">                                                  </span><span class="nottickedoff">&quot;viols'&quot;&lt;&gt;showSign (sign viols')&lt;&gt;&quot;  &quot;&lt;&gt;showADL viols'&lt;&gt;&quot;\n&quot;&lt;&gt;</span>
<span class="lineno">  540 </span><span class="spaces">                                                  </span><span class="nottickedoff">&quot;toExpr&quot;&lt;&gt;showSign (sign toExpr)&lt;&gt;&quot;  &quot;&lt;&gt;showADL toExpr)</span>
<span class="lineno">  541 </span><span class="spaces">                                  </span><span class="nottickedoff">else if ev==Ins</span>
<span class="lineno">  542 </span><span class="spaces">                                  </span><span class="nottickedoff">then (showProof (para.str.showADL). cfProof options) (viols'.\/.toExpr)&lt;&gt;linebreak</span>
<span class="lineno">  543 </span><span class="spaces">                                  </span><span class="nottickedoff">else (showProof (para.str.showADL). dfProof options) (notCpl viols./\.toExpr)&lt;&gt;linebreak</span>
<span class="lineno">  544 </span><span class="spaces">                                </span><span class="nottickedoff">) -}</span>
<span class="lineno">  545 </span><span class="spaces">                         </span><span class="nottickedoff">)</span>
<span class="lineno">  546 </span><span class="spaces">                       </span><span class="nottickedoff">)</span>
<span class="lineno">  547 </span><span class="spaces">                     </span><span class="nottickedoff">| conjEqClass &lt;- [] -- TODO: implement this once we can test it (note: computing eq. class is no longer necessary)</span>
<span class="lineno">  548 </span><span class="spaces">                    </span><span class="nottickedoff">-- conjEqClass &lt;- eqCl fst [ (qConjuncts q, qRule q) | q&lt;-relEq ]</span>
<span class="lineno">  549 </span><span class="spaces">                     </span><span class="nottickedoff">, conjunct &lt;- (fst.head) conjEqClass                  -- get conjuncts from the clauses</span>
<span class="lineno">  550 </span><span class="spaces">                     </span><span class="nottickedoff">, clause &lt;- rc_dnfClauses conjunct  -- the DNF form of each clause</span>
<span class="lineno">  551 </span><span class="spaces">                     </span><span class="nottickedoff">, let expr    = dnf2expr clause                       -- Note that this differs from:  rc_conjunct conjunct, because the type may be different.</span>
<span class="lineno">  552 </span><span class="spaces">                     </span><span class="nottickedoff">, let vee     = EDcV (sign expr)</span>
<span class="lineno">  553 </span><span class="spaces">                     </span><span class="nottickedoff">, let ex'     = subst (rel, actSem options ev (EDcD rel) (delta (sign rel))) expr -- the clause after the edit action</span>
<span class="lineno">  554 </span><span class="spaces">                     </span><span class="nottickedoff">, let clause' = conjNF options ex'                                                -- its CNF</span>
<span class="lineno">  555 </span><span class="spaces">                     </span><span class="nottickedoff">, not (isTrue clause')</span>
<span class="lineno">  556 </span><span class="spaces">                     </span><span class="nottickedoff">, let notClau = notCpl clause'                                            -- the violations after the edit action</span>
<span class="lineno">  557 </span><span class="spaces">                     </span><span class="nottickedoff">, let viols   = conjNF options notClau                                            -- the violations after the edit action</span>
<span class="lineno">  558 </span><span class="spaces">                     </span><span class="nottickedoff">, let viols'  = disjNF options notClau                                            -- the violations after the edit action</span>
<span class="lineno">  559 </span><span class="spaces">                     </span><span class="nottickedoff">, let negs    = if (length.nub.map sign) (vee:antcs clause)&gt;1</span>
<span class="lineno">  560 </span><span class="spaces">                                     </span><span class="nottickedoff">then fatal 265 (&quot;type inconsistencies in antcs: &quot;++show (map showADL (vee:antcs clause)))</span>
<span class="lineno">  561 </span><span class="spaces">                                     </span><span class="nottickedoff">else foldr (./\.) vee (antcs clause)</span>
<span class="lineno">  562 </span><span class="spaces">                     </span><span class="nottickedoff">, let poss    = if (length.nub.map sign) (vee:conss clause)&gt;1</span>
<span class="lineno">  563 </span><span class="spaces">                                     </span><span class="nottickedoff">then fatal 265 (&quot;type inconsistencies in conss: &quot;++show (map showADL (vee:conss clause)))</span>
<span class="lineno">  564 </span><span class="spaces">                                     </span><span class="nottickedoff">else foldr (.\/.) (notCpl vee) (conss clause)</span>
<span class="lineno">  565 </span><span class="spaces">                     </span><span class="nottickedoff">, let frExpr  = case ev of</span>
<span class="lineno">  566 </span><span class="spaces">                                      </span><span class="nottickedoff">Ins -&gt; disjNF options (notCpl negs)</span>
<span class="lineno">  567 </span><span class="spaces">                                      </span><span class="nottickedoff">Del -&gt; disjNF options poss</span>
<span class="lineno">  568 </span><span class="spaces">                     </span><span class="nottickedoff">, let deltFr  = if sign poss/=sign negs</span>
<span class="lineno">  569 </span><span class="spaces">                                     </span><span class="nottickedoff">then fatal 274 (&quot;type inconsistencies in deltFr: &quot;++showADL clause)</span>
<span class="lineno">  570 </span><span class="spaces">                                     </span><span class="nottickedoff">else if ev==Ins</span>
<span class="lineno">  571 </span><span class="spaces">                                     </span><span class="nottickedoff">then (subst (rel, actSem options ev (EDcD rel) (delta (sign rel)))) negs ./\. notCpl poss</span>
<span class="lineno">  572 </span><span class="spaces">                                     </span><span class="nottickedoff">else (notCpl . subst (rel, actSem options ev (EDcD rel) (delta (sign rel)))) poss ./\. negs</span>
<span class="lineno">  573 </span><span class="spaces">                     </span><span class="nottickedoff">, let deltFr' = disjNF options deltFr</span>
<span class="lineno">  574 </span><span class="spaces">                     </span><span class="nottickedoff">, rel `elem` relsMentionedIn frExpr</span>
<span class="lineno">  575 </span><span class="spaces">                     </span><span class="nottickedoff">, let toExpr  = if ev==Ins</span>
<span class="lineno">  576 </span><span class="spaces">                                     </span><span class="nottickedoff">then disjNF options poss</span>
<span class="lineno">  577 </span><span class="spaces">                                     </span><span class="nottickedoff">else disjNF options (notCpl negs)</span>
<span class="lineno">  578 </span><span class="spaces">                     </span><span class="nottickedoff">, let visible r = r `elem` editables</span>
<span class="lineno">  579 </span><span class="spaces">                     </span><span class="nottickedoff">, if length (nub (map sign [toExpr, deltFr', expr]))&gt;1</span>
<span class="lineno">  580 </span><span class="spaces">                       </span><span class="nottickedoff">then fatal 285 &quot;type problem&quot;</span>
<span class="lineno">  581 </span><span class="spaces">                       </span><span class="nottickedoff">else True</span>
<span class="lineno">  582 </span><span class="spaces">                     </span><span class="nottickedoff">, let act = genPAclause visible Ins toExpr deltFr' [(expr, map snd conjEqClass)]</span>
<span class="lineno">  583 </span><span class="spaces">                     </span><span class="nottickedoff">]</span>
<span class="lineno">  584 </span><span class="spaces">        </span><span class="nottickedoff">, let ecaAct = ALL (map fst4 acts</span>
<span class="lineno">  585 </span><span class="spaces">        </span><span class="nottickedoff">-- The following acts add the implicit rules, which allows the user to add and delete atoms from concepts in a safe way.</span>
<span class="lineno">  586 </span><span class="spaces">                            </span><span class="nottickedoff">++ [act' | (ev',rel',act')&lt;-rulesDecls++rulesGens rel, ev==ev', rel==rel' ]</span>
<span class="lineno">  587 </span><span class="spaces">                           </span><span class="nottickedoff">)</span>
<span class="lineno">  588 </span><span class="spaces">                           </span><span class="nottickedoff">[ (rc_conjunct conj,ruls) | (_,conj,ruls,_)&lt;-acts] --motivation is of type [(Expression,[Rule])]</span>
<span class="lineno">  589 </span><span class="spaces">        </span><span class="nottickedoff">, let normEcaAct = normPA options ecaAct</span>
<span class="lineno">  590 </span><span class="spaces">        </span><span class="nottickedoff">, let ecaProof = proofPA options ecaAct</span>
<span class="lineno">  591 </span><span class="spaces">        </span><span class="nottickedoff">, let ecaEvt = On ev rel</span>
<span class="lineno">  592 </span><span class="spaces">        </span><span class="nottickedoff">, let ecaRule = ECA ecaEvt delt normEcaAct</span>
<span class="lineno">  593 </span><span class="spaces">        </span><span class="nottickedoff">]</span>
<span class="lineno">  594 </span><span class="spaces"></span><span class="nottickedoff">--   the following eca-rules are derived from the typing rules, rather than explicit rules specified by users.</span>
<span class="lineno">  595 </span><span class="spaces"></span><span class="nottickedoff">--   This concerns the following rules:</span>
<span class="lineno">  596 </span><span class="spaces"></span><span class="nottickedoff">--   Each declaration &quot;RELATION r[A*B]&quot; represents the rule &quot;RULE r[A*B] |- V[A*B]&quot;</span>
<span class="lineno">  597 </span><span class="spaces"></span><span class="nottickedoff">--   Besides, for every A, B:   &quot;RULE  I[A]*I[B] = V[A*B]&quot;</span>
<span class="lineno">  598 </span><span class="spaces"></span><span class="nottickedoff">--   For every &quot;CLASSIFY A ISA B&quot; we get  &quot;RULE  I[A] |- I[B]&quot;</span>
<span class="lineno">  599 </span><span class="spaces"></span><span class="nottickedoff">--   For every &quot;CLASSIFY A IS B /\ C&quot; we get &quot;RULE  I[A] |- I[B]&quot; and &quot;RULE  I[A] |- I[C]&quot;</span>
<span class="lineno">  600 </span><span class="spaces"></span><span class="nottickedoff">--   The results of both classify statements are available through vgens.</span>
<span class="lineno">  601 </span><span class="spaces"></span><span class="nottickedoff">--   Finally, for every Atom c a there is a rule  &quot;RULE  'a' |- I[c]&quot;</span>
<span class="lineno">  602 </span><span class="spaces"></span><span class="nottickedoff">--   The eca-rules that can be derived from these rules are produced by  ecasFromTypes</span>
<span class="lineno">  603 </span><span class="spaces">   </span><span class="nottickedoff">{- V[A*B] is implicit, so we don't generate ECA (On Ins rel) delt (Do Ins (Vs (Sign a b)) delt motive).</span>
<span class="lineno">  604 </span><span class="spaces">                        </span><span class="nottickedoff">Neither do we generate ECA (On Del (Vs (Sign a b))) delt (Do Del rel delt motive).</span>
<span class="lineno">  605 </span><span class="spaces">      </span><span class="nottickedoff">However, we do generate:                 ECA (On Ins rel) delt (Do Ins (Isn a) ((dlt.&lt;&gt;.flp dlt).-.EDcI a) motive)</span>
<span class="lineno">  606 </span><span class="spaces">                                         </span><span class="nottickedoff">and:  ECA (On Ins rel) delt (Do Ins (Isn b) ((flp dlt.&lt;&gt;.dlt).-.EDcI b) motive),</span>
<span class="lineno">  607 </span><span class="spaces">      </span><span class="nottickedoff">because the delta to be inserted might contain new atoms.</span>
<span class="lineno">  608 </span><span class="spaces">      </span><span class="nottickedoff">Similarly, upon deletion of an atom from a concept we must delete the appropriate links from relations that share this concept.</span>
<span class="lineno">  609 </span><span class="spaces">      </span><span class="nottickedoff">So, we generate                          ECA (On Del (Isn a)) delt (Do Del rel (delt.:.V[A*B]) motive)</span>
<span class="lineno">  610 </span><span class="spaces">                                         </span><span class="nottickedoff">and:  ECA (On Del (Isn b)) delt (Do Del rel (V[A*B].:.delt) motive)</span>
<span class="lineno">  611 </span><span class="spaces">      </span><span class="nottickedoff">ECA-rules that are derivable from relation declarations are generated by rulesDecls</span>
<span class="lineno">  612 </span><span class="spaces">   </span><span class="nottickedoff">-}</span>
<span class="lineno">  613 </span><span class="spaces">    </span><span class="nottickedoff">rulesDecls :: [(InsDel, Declaration, PAclause)]</span>
<span class="lineno">  614 </span><span class="spaces">    </span><span class="nottickedoff">rulesDecls</span>
<span class="lineno">  615 </span><span class="spaces">      </span><span class="nottickedoff">= concat</span>
<span class="lineno">  616 </span><span class="spaces">        </span><span class="nottickedoff">[ [ (Ins, rel, Do Ins (Isn a) ((dlt.:.flp dlt ./\. EDcI a).-.EDcI a) [])</span>
<span class="lineno">  617 </span><span class="spaces">          </span><span class="nottickedoff">, (Ins, rel, Do Ins (Isn b) ((flp dlt.:.dlt ./\. EDcI b).-.EDcI b) [])</span>
<span class="lineno">  618 </span><span class="spaces">          </span><span class="nottickedoff">, (Del, Isn a, Do Del rel (delta (Sign a a).:.vee) [])</span>
<span class="lineno">  619 </span><span class="spaces">          </span><span class="nottickedoff">, (Del, Isn b, Do Del rel (vee.:.delta (Sign b b)) [])</span>
<span class="lineno">  620 </span><span class="spaces">          </span><span class="nottickedoff">]</span>
<span class="lineno">  621 </span><span class="spaces">        </span><span class="nottickedoff">| rel &lt;- relsDefdIn context</span>
<span class="lineno">  622 </span><span class="spaces">        </span><span class="nottickedoff">, let dlt = delta (sign rel)</span>
<span class="lineno">  623 </span><span class="spaces">        </span><span class="nottickedoff">, let a=source rel, let b=target rel</span>
<span class="lineno">  624 </span><span class="spaces">        </span><span class="nottickedoff">, let vee = (EDcV . sign) rel</span>
<span class="lineno">  625 </span><span class="spaces">        </span><span class="nottickedoff">]</span>
<span class="lineno">  626 </span><span class="spaces"></span><span class="nottickedoff">{- We generate:</span>
<span class="lineno">  627 </span><span class="spaces">     </span><span class="nottickedoff">for every &quot;RULE  I[A] |- I[B]&quot;:        ECA (On Ins (Isn a)) delt (Do Ins (Isn b) (EDcD delt) motive)</span>
<span class="lineno">  628 </span><span class="spaces">                                </span><span class="nottickedoff">and:        ECA (On Del (Isn b)) delt (Do Del (Isn a) (EDcD delt) motive)</span>
<span class="lineno">  629 </span><span class="spaces">     </span><span class="nottickedoff">for every &quot;RULE   'a' |- I[c]&quot;:        ECA (On Del (Isn c)) ('a','a') (Blk motive)</span>
<span class="lineno">  630 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno">  631 </span><span class="spaces">    </span><span class="nottickedoff">rulesGens :: Declaration -&gt; [(InsDel, Declaration, PAclause)]</span>
<span class="lineno">  632 </span><span class="spaces">    </span><span class="nottickedoff">rulesGens rel</span>
<span class="lineno">  633 </span><span class="spaces">      </span><span class="nottickedoff">= concat</span>
<span class="lineno">  634 </span><span class="spaces">        </span><span class="nottickedoff">[ [ (Ins, Isn s, Do Ins (Isn g) dlt [])</span>
<span class="lineno">  635 </span><span class="spaces">          </span><span class="nottickedoff">, (Del, Isn g, Do Del (Isn s) dlt [])</span>
<span class="lineno">  636 </span><span class="spaces">          </span><span class="nottickedoff">]</span>
<span class="lineno">  637 </span><span class="spaces">        </span><span class="nottickedoff">| let dlt = delta (sign rel), (s,g) &lt;- concatMap genericAndSpecifics (gens context)</span>
<span class="lineno">  638 </span><span class="spaces">        </span><span class="nottickedoff">]</span>
<span class="lineno">  639 </span><span class="spaces">    </span><span class="nottickedoff">fst4 (x,_,_,_) = x</span></span>
<span class="lineno">  640 </span>
<span class="lineno">  641 </span>-- | de functie genPAclause beschrijft de voornaamste mogelijkheden om een expressie delta' te verwerken in expr (met tOp'==Ins of tOp==Del)
<span class="lineno">  642 </span>-- TODO: Vind een wetenschappelijk artikel waar de hier beschreven transformatie uitputtend wordt behandeld.
<span class="lineno">  643 </span>-- TODO: Deze code is onvolledig en misschien zelfs fout....
<span class="lineno">  644 </span>genPAclause :: (Declaration-&gt;Bool)        -- ^True if a relation may be changed (i.e. is editable)
<span class="lineno">  645 </span>               -&gt; InsDel                  -- ^the type of action: Insert or Delete
<span class="lineno">  646 </span>               -&gt; Expression              -- ^the expression in which a delete or insert takes place
<span class="lineno">  647 </span>               -&gt; Expression              -- ^the delta to be inserted or deleted
<span class="lineno">  648 </span>               -&gt; [(Expression,[Rule])]   -- ^the motivation, consisting of the conjuncts (traced back to their rules) that are being restored by this code fragment.
<span class="lineno">  649 </span>               -&gt; PAclause
<span class="lineno">  650 </span><span class="decl"><span class="nottickedoff">genPAclause editAble tOp' expr1 delta1 motive = genPAcl delta1 tOp' expr1</span>
<span class="lineno">  651 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno">  652 </span><span class="spaces">   </span><span class="nottickedoff">testPA i l r ex</span>
<span class="lineno">  653 </span><span class="spaces">    </span><span class="nottickedoff">= if (source l,target r)/=(source ex,target ex)</span>
<span class="lineno">  654 </span><span class="spaces">      </span><span class="nottickedoff">then fatal i (&quot;test with sign deltaX = [&quot;++show (source l)++&quot;*&quot;++show (target r)++&quot;],  and sign expr = &quot;++show (sign ex)++&quot;:\ndeltaX = &quot;++showADL (l.:.r)++&quot;\nexpr = &quot;++show ex)</span>
<span class="lineno">  655 </span><span class="spaces">      </span><span class="nottickedoff">else if source r/=target l</span>
<span class="lineno">  656 </span><span class="spaces">      </span><span class="nottickedoff">then fatal i (&quot;test with source r = &quot;++show (source r)++&quot;,  and target l = &quot;++show (target l)++&quot;:\nl&quot;++showSign (sign l)++&quot; = &quot;++showADL l++&quot;\nr&quot;++showSign (sign r)++&quot; = &quot;++showADL r++&quot;\nexpr = &quot;++show ex)</span>
<span class="lineno">  657 </span><span class="spaces">      </span><span class="nottickedoff">else id</span>
<span class="lineno">  658 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  659 </span><span class="spaces">   </span><span class="nottickedoff">genPAcl deltaX tOp expr =</span>
<span class="lineno">  660 </span><span class="spaces">     </span><span class="nottickedoff">case (tOp, expr) of</span>
<span class="lineno">  661 </span><span class="spaces">       </span><span class="nottickedoff">(_  , EEqu{})     -&gt; Blk [(expr, nub [r |(_,rs)&lt;-motive, r&lt;-rs])]</span>
<span class="lineno">  662 </span><span class="spaces">       </span><span class="nottickedoff">(_  , EImp{})     -&gt; Blk [(expr, nub [r |(_,rs)&lt;-motive, r&lt;-rs])]</span>
<span class="lineno">  663 </span><span class="spaces">       </span><span class="nottickedoff">(_ ,  EFlp x)     -&gt; genPAcl (flp deltaX) tOp x</span>
<span class="lineno">  664 </span><span class="spaces">       </span><span class="nottickedoff">(_ ,  EBrk x)     -&gt; genPAcl deltaX tOp x</span>
<span class="lineno">  665 </span><span class="spaces">       </span><span class="nottickedoff">(Ins, ECpl x)     -&gt; genPAcl deltaX Del x</span>
<span class="lineno">  666 </span><span class="spaces">       </span><span class="nottickedoff">(Del, ECpl x)     -&gt; genPAcl deltaX Ins x</span>
<span class="lineno">  667 </span><span class="spaces">       </span><span class="nottickedoff">(Ins, EUni{})     -&gt; CHC [ genPAcl deltaX Ins f | f&lt;-exprUni2list expr{-, not (f==expr1 &amp;&amp; Ins/=tOp') -}] motive -- the filter prevents self compensating PA-clauses.</span>
<span class="lineno">  668 </span><span class="spaces">       </span><span class="nottickedoff">(Ins, EIsc{})     -&gt; ALL [ genPAcl deltaX Ins f | f&lt;-exprIsc2list expr ] motive</span>
<span class="lineno">  669 </span><span class="spaces">       </span><span class="nottickedoff">(Del, EUni{})     -&gt; ALL [ genPAcl deltaX Del f | f&lt;-exprUni2list expr {-, not (f==expr1 &amp;&amp; Del/=tOp') -}] motive -- the filter prevents self compensating PA-clauses.</span>
<span class="lineno">  670 </span><span class="spaces">       </span><span class="nottickedoff">(Del, EIsc{})     -&gt; CHC [ genPAcl deltaX Del f | f&lt;-exprIsc2list expr ] motive</span>
<span class="lineno">  671 </span><span class="spaces">       </span><span class="nottickedoff">(Ins, EDif (l,r)) -&gt; CHC [ genPAcl deltaX Ins l, genPAcl deltaX Del r ] motive</span>
<span class="lineno">  672 </span><span class="spaces">       </span><span class="nottickedoff">(Del, EDif (l,r)) -&gt; CHC [ genPAcl deltaX Del l, genPAcl deltaX Ins r ] motive</span>
<span class="lineno">  673 </span><span class="spaces">       </span><span class="nottickedoff">(Ins, EDia (l,r)) -&gt; CHC [ ALL [ genPAcl (testPA 986 (deltaX) (flp r)          l $ deltaX.:.flp r         ) Ins l</span>
<span class="lineno">  674 </span><span class="spaces">                                      </span><span class="nottickedoff">, genPAcl (testPA 987 (flp l) (deltaX)          r $ flp l.:.deltaX         ) Ins r] motive</span>
<span class="lineno">  675 </span><span class="spaces">                                </span><span class="nottickedoff">, ALL [ genPAcl (testPA 988 (deltaX) (notCpl (flp r)) l $ deltaX.:.notCpl (flp r)) Del l</span>
<span class="lineno">  676 </span><span class="spaces">                                      </span><span class="nottickedoff">, genPAcl (testPA 989 (deltaX) (flp r)          l $ deltaX.:.flp r         ) Ins l] motive</span>
<span class="lineno">  677 </span><span class="spaces">                                </span><span class="nottickedoff">, ALL [ genPAcl (testPA 990 (notCpl (flp l)) (deltaX) r $ notCpl (flp l).:.deltaX) Del r</span>
<span class="lineno">  678 </span><span class="spaces">                                      </span><span class="nottickedoff">, genPAcl (testPA 991 (flp l) (deltaX)          r $ flp l.:.deltaX         ) Ins r] motive</span>
<span class="lineno">  679 </span><span class="spaces">                                </span><span class="nottickedoff">, ALL [ genPAcl (testPA 992 (deltaX) (notCpl (flp r)) l $ deltaX.:.notCpl (flp r)) Del l</span>
<span class="lineno">  680 </span><span class="spaces">                                      </span><span class="nottickedoff">, genPAcl (testPA 993 (notCpl (flp l)) (deltaX) r $ notCpl (flp l).:.deltaX) Del r] motive</span>
<span class="lineno">  681 </span><span class="spaces">                                </span><span class="nottickedoff">] motive</span>
<span class="lineno">  682 </span><span class="spaces">       </span><span class="nottickedoff">(Del, EDia (l,r)) -&gt; GCH [ (Del, (testPA 995 (deltaX) (flp r)          l $ deltaX.:.flp r),          genPAcl (EMp1 &quot;a&quot; (source l).*.EMp1 &quot;b&quot; (target l)) tOp l)</span>
<span class="lineno">  683 </span><span class="spaces">                                </span><span class="nottickedoff">, (Ins, (testPA 996 (deltaX) (flp (notCpl r)) l $ deltaX.:.flp (notCpl r)), genPAcl (EMp1 &quot;a&quot; (source l).*.EMp1 &quot;b&quot; (target l)) tOp l)</span>
<span class="lineno">  684 </span><span class="spaces">                                </span><span class="nottickedoff">, (Del, (testPA 997 (flp l) (deltaX)          r $ flp l.:.deltaX),          genPAcl (EMp1 &quot;a&quot; (source r).*.EMp1 &quot;b&quot; (target r)) tOp r)</span>
<span class="lineno">  685 </span><span class="spaces">                                </span><span class="nottickedoff">, (Ins, (testPA 998 (notCpl (flp l)) (deltaX) r $ notCpl (flp l).:.deltaX), genPAcl (EMp1 &quot;a&quot; (source r).*.EMp1 &quot;b&quot; (target r)) tOp r)</span>
<span class="lineno">  686 </span><span class="spaces">                                </span><span class="nottickedoff">] motive</span>
<span class="lineno">  687 </span><span class="spaces">       </span><span class="nottickedoff">(Ins, ERrs (l,r)) -&gt; CHC [ genPAcl (testPA 1000 (notCpl r) (flp deltaX) l $ notCpl r.:.flp deltaX) Del l</span>
<span class="lineno">  688 </span><span class="spaces">                                </span><span class="nottickedoff">, genPAcl (testPA 1001 (l) (deltaX)            r $ l.:.deltaX)            Ins r</span>
<span class="lineno">  689 </span><span class="spaces">                                </span><span class="nottickedoff">] motive</span>
<span class="lineno">  690 </span><span class="spaces">       </span><span class="nottickedoff">(Del, ERrs (l,r)) -&gt; GCH [ (Ins, (testPA 1003 (notCpl r) (flp deltaX) l $ notCpl r.:.flp deltaX), genPAcl (EMp1 &quot;a&quot; (source l).*.EMp1 &quot;b&quot; (target l)) tOp l)</span>
<span class="lineno">  691 </span><span class="spaces">                                </span><span class="nottickedoff">, (Del, (testPA 1004 (l) (deltaX)            r $ l.:.deltaX),            genPAcl (EMp1 &quot;a&quot; (source r).*.EMp1 &quot;b&quot; (target r)) tOp r)</span>
<span class="lineno">  692 </span><span class="spaces">                                </span><span class="nottickedoff">] motive</span>
<span class="lineno">  693 </span><span class="spaces">       </span><span class="nottickedoff">(Ins, ELrs (l,r)) -&gt; CHC [ genPAcl (testPA 1006 (flp deltaX) (notCpl l) r $ flp deltaX.:.notCpl l) Del r</span>
<span class="lineno">  694 </span><span class="spaces">                                </span><span class="nottickedoff">, genPAcl (testPA 1007 (deltaX) (r)            l $ deltaX.:.r           ) Ins l</span>
<span class="lineno">  695 </span><span class="spaces">                                </span><span class="nottickedoff">] motive</span>
<span class="lineno">  696 </span><span class="spaces">       </span><span class="nottickedoff">(Del, ELrs (l,r)) -&gt; GCH [ (Ins, (testPA 1009 (flp deltaX) (notCpl l) r $ flp deltaX.:.notCpl l), genPAcl (EMp1 &quot;a&quot; (source r).*.EMp1 &quot;b&quot; (target r)) tOp r)</span>
<span class="lineno">  697 </span><span class="spaces">                                </span><span class="nottickedoff">, (Del, (testPA 1010 (deltaX) (r)            l $ deltaX.:.r),            genPAcl (EMp1 &quot;a&quot; (source l).*.EMp1 &quot;b&quot; (target l)) tOp l)</span>
<span class="lineno">  698 </span><span class="spaces">                                </span><span class="nottickedoff">] motive</span>
<span class="lineno">  699 </span><span class="spaces">       </span><span class="nottickedoff">(Ins, ECps (l,r)) -&gt; CHC [ GCH [ (Ins, (testPA 1012 (deltaX) (flp r) l $ deltaX.:.flp r), genPAcl (EMp1 &quot;a&quot; (source l).*.EMp1 &quot;b&quot; (target l)) tOp l)</span>
<span class="lineno">  700 </span><span class="spaces">                                      </span><span class="nottickedoff">, (Ins, (testPA 1013 (flp l) (deltaX) r $ flp l.:.deltaX), genPAcl (EMp1 &quot;a&quot; (source r).*.EMp1 &quot;b&quot; (target r)) tOp r)</span>
<span class="lineno">  701 </span><span class="spaces">                                      </span><span class="nottickedoff">] motive</span>
<span class="lineno">  702 </span><span class="spaces">                                </span><span class="nottickedoff">, New (source r) (\x-&gt;ALL [ genPAcl (deltaX.*.EMp1 x (target l)) Ins l</span>
<span class="lineno">  703 </span><span class="spaces">                                                          </span><span class="nottickedoff">, genPAcl (EMp1 x (source r).*.deltaX) Ins r] motive) motive</span>
<span class="lineno">  704 </span><span class="spaces">                                </span><span class="nottickedoff">] motive</span>
<span class="lineno">  705 </span><span class="spaces">       </span><span class="nottickedoff">(Del, ECps (l,r)) -&gt; CHC [ genPAcl (testPA 1018 (deltaX) (flp r) l $ deltaX.:.flp r) Del l</span>
<span class="lineno">  706 </span><span class="spaces">                                </span><span class="nottickedoff">, genPAcl (testPA 1019 (flp l) (deltaX) r $ flp l.:.deltaX) Del r</span>
<span class="lineno">  707 </span><span class="spaces">                                </span><span class="nottickedoff">] motive</span>
<span class="lineno">  708 </span><span class="spaces">       </span><span class="nottickedoff">(Ins, ERad (l,r)) -&gt; CHC [ genPAcl (testPA 1021 (deltaX) (notCpl (flp r)) l $ deltaX.:.notCpl (flp r)) Ins l</span>
<span class="lineno">  709 </span><span class="spaces">                                </span><span class="nottickedoff">, genPAcl (testPA 1022 (notCpl (flp l)) (deltaX) r $ notCpl (flp l).:.deltaX) Ins r</span>
<span class="lineno">  710 </span><span class="spaces">                                </span><span class="nottickedoff">] motive</span>
<span class="lineno">  711 </span><span class="spaces">       </span><span class="nottickedoff">(Del, ERad (l,r)) -&gt; CHC [ GCH [ (Del, (testPA 1024 (deltaX) (flp r) l $ deltaX.:.flp r), genPAcl (EMp1 &quot;a&quot; (source l).*.EMp1 &quot;b&quot; (target l)) tOp l)</span>
<span class="lineno">  712 </span><span class="spaces">                                      </span><span class="nottickedoff">, (Del, (testPA 1025 (flp l) (deltaX) r $ flp l.:.deltaX), genPAcl (EMp1 &quot;a&quot; (source r).*.EMp1 &quot;b&quot; (target r)) tOp r)</span>
<span class="lineno">  713 </span><span class="spaces">                                      </span><span class="nottickedoff">] motive</span>
<span class="lineno">  714 </span><span class="spaces">                                </span><span class="nottickedoff">, New (source r) (\_-&gt;Nop motive) motive</span>
<span class="lineno">  715 </span><span class="spaces">                                </span><span class="nottickedoff">] motive</span>
<span class="lineno">  716 </span><span class="spaces">       </span><span class="nottickedoff">(Ins, EPrd (l,r)) -&gt; ALL [ genPAcl (EDcV (Sign ONE (source deltaX)).:.deltaX) Ins (EDcV (Sign ONE (source r)).:.r)</span>
<span class="lineno">  717 </span><span class="spaces">                                </span><span class="nottickedoff">, genPAcl (deltaX.:.EDcV (Sign (target deltaX) ONE)) Ins (l.:.EDcV (Sign (target l) ONE))</span>
<span class="lineno">  718 </span><span class="spaces">                                </span><span class="nottickedoff">] motive</span>
<span class="lineno">  719 </span><span class="spaces">       </span><span class="nottickedoff">(Del, EPrd (l,r)) -&gt; ALL [ genPAcl (EDcV (Sign ONE (source deltaX)).:.deltaX) Del (EDcV (Sign ONE (source r)).:.r)</span>
<span class="lineno">  720 </span><span class="spaces">                                </span><span class="nottickedoff">, genPAcl (deltaX.:.EDcV (Sign (target deltaX) ONE)) Del (l.:.EDcV (Sign (target l) ONE))</span>
<span class="lineno">  721 </span><span class="spaces">                                </span><span class="nottickedoff">] motive</span>
<span class="lineno">  722 </span><span class="spaces">       </span><span class="nottickedoff">(_  , EKl0 x )    -&gt; genPAcl (deltaK0 deltaX tOp x) tOp x</span>
<span class="lineno">  723 </span><span class="spaces">       </span><span class="nottickedoff">(_  , EKl1 x )    -&gt; genPAcl (deltaK1 deltaX tOp x) tOp x</span>
<span class="lineno">  724 </span><span class="spaces">       </span><span class="nottickedoff">(_  , EDcD d)     -&gt; if editAble d then Do tOp d deltaX motive else Blk [(expr, nub [r |(_,rs)&lt;-motive, r&lt;-rs])]</span>
<span class="lineno">  725 </span><span class="spaces">       </span><span class="nottickedoff">(_  , EDcI c)     -&gt; if editAble (Isn c) then Do tOp (Isn c) deltaX motive else Blk [(expr, nub [r |(_,rs)&lt;-motive, r&lt;-rs])]</span>
<span class="lineno">  726 </span><span class="spaces">       </span><span class="nottickedoff">(_  , EDcV{})     -&gt; Blk [(expr, nub [r |(_,rs)&lt;-motive, r&lt;-rs])]</span>
<span class="lineno">  727 </span><span class="spaces">       </span><span class="nottickedoff">(_  , EMp1{})     -&gt; Blk [(expr, nub [r |(_,rs)&lt;-motive, r&lt;-rs])]</span>
<span class="lineno">  728 </span><span class="spaces">       </span><span class="nottickedoff">(_  , EEps{})     -&gt; Nop [(expr, nub [r |(_,rs)&lt;-motive, r&lt;-rs])]</span>
<span class="lineno">  729 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  730 </span><span class="spaces"></span><span class="nottickedoff">{-        (_ , _)           -&gt; fatal 767 ( &quot;(Stef?) Non-exhaustive patterns in the recursive call\n&quot;</span>
<span class="lineno">  731 </span><span class="spaces">                                    </span><span class="nottickedoff">++&quot;doCod (&quot;++showADL deltaX++&quot;) -- deltaX\n      &quot;++show tOp++&quot;  -- tOp\n      (&quot;++showADL expr++&quot;) -- expr\n&quot;++</span>
<span class="lineno">  732 </span><span class="spaces">                                      </span><span class="nottickedoff">&quot;within function\ndoCode &quot;++show tOp'++&quot;  -- tOp'\n       (&quot;++showADL expr1++&quot;) -- expr1\n       (&quot;++showADL delta1++&quot;) -- delta1\n&quot;++</span>
<span class="lineno">  733 </span><span class="spaces">                                      </span><span class="nottickedoff">concat</span>
<span class="lineno">  734 </span><span class="spaces">                                      </span><span class="nottickedoff">[ &quot;while trying to maintain conjunct &quot;++showADL conjunct++</span>
<span class="lineno">  735 </span><span class="spaces">                                        </span><span class="nottickedoff">&quot;\nfrom rule &quot;++intercalate &quot;\n          &quot; [show r | r&lt;-rs]</span>
<span class="lineno">  736 </span><span class="spaces">                                      </span><span class="nottickedoff">| (conjunct,rs)&lt;-motive ] ++</span>
<span class="lineno">  737 </span><span class="spaces">                                      </span><span class="nottickedoff">if null motive then &quot;null motive&quot; else &quot;&quot;</span>
<span class="lineno">  738 </span><span class="spaces">                                      </span><span class="nottickedoff">)</span>
<span class="lineno">  739 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno">  740 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  741 </span><span class="spaces">   </span><span class="nottickedoff">deltaK0 :: t -&gt; InsDel -&gt; t1 -&gt; t</span>
<span class="lineno">  742 </span><span class="spaces">   </span><span class="nottickedoff">deltaK0 delta' Ins _ = delta'  -- error! (tijdelijk... moet berekenen welke paren in x gezet moeten worden zodat delta |- x*)</span>
<span class="lineno">  743 </span><span class="spaces">   </span><span class="nottickedoff">deltaK0 delta' Del _ = delta'  -- error! (tijdelijk... moet berekenen welke paren uit x verwijderd moeten worden zodat delta/\x* leeg is)</span>
<span class="lineno">  744 </span><span class="spaces">   </span><span class="nottickedoff">deltaK1 :: t -&gt; InsDel -&gt; t1 -&gt; t</span>
<span class="lineno">  745 </span><span class="spaces">   </span><span class="nottickedoff">deltaK1 delta' Ins _ = delta'  -- error! (tijdelijk... moet berekenen welke paren in x gezet moeten worden zodat delta |- x+)</span>
<span class="lineno">  746 </span><span class="spaces">   </span><span class="nottickedoff">deltaK1 delta' Del _ = delta'</span></span>  -- error! (tijdelijk... moet berekenen welke paren uit x verwijderd moeten worden zodat delta/\x+ leeg is)
<span class="lineno">  747 </span>
<span class="lineno">  748 </span>commaEngPandoc' :: Inlines -&gt; [Inlines] -&gt; Inlines
<span class="lineno">  749 </span><span class="decl"><span class="nottickedoff">commaEngPandoc' s [a,b,c] = a &lt;&gt; &quot;, &quot; &lt;&gt; b &lt;&gt; &quot;, &quot; &lt;&gt; s &lt;&gt; space &lt;&gt; c</span>
<span class="lineno">  750 </span><span class="spaces"></span><span class="nottickedoff">commaEngPandoc' s [a,b]   = a &lt;&gt; space &lt;&gt; s &lt;&gt; space &lt;&gt; b</span>
<span class="lineno">  751 </span><span class="spaces"></span><span class="nottickedoff">commaEngPandoc' _   [a]   = a</span>
<span class="lineno">  752 </span><span class="spaces"></span><span class="nottickedoff">commaEngPandoc' s (a:as)  = a &lt;&gt; &quot;, &quot; &lt;&gt; commaEngPandoc' s as</span>
<span class="lineno">  753 </span><span class="spaces"></span><span class="nottickedoff">commaEngPandoc' _   []    = mempty</span></span>
<span class="lineno">  754 </span>
<span class="lineno">  755 </span>commaEngPandoc :: Inline -&gt; [Inline] -&gt; [Inline]
<span class="lineno">  756 </span><span class="decl"><span class="nottickedoff">commaEngPandoc s [a,b,c] = [a,Str &quot;, &quot;,b,Str &quot;, &quot;,s, Str &quot; &quot;, c]</span>
<span class="lineno">  757 </span><span class="spaces"></span><span class="nottickedoff">commaEngPandoc s [a,b]   = [a,Str &quot; &quot;,s, Str &quot; &quot;, b]</span>
<span class="lineno">  758 </span><span class="spaces"></span><span class="nottickedoff">commaEngPandoc _   [a]   = [a]</span>
<span class="lineno">  759 </span><span class="spaces"></span><span class="nottickedoff">commaEngPandoc s (a:as)  = [a, Str &quot;, &quot;]++commaEngPandoc s as</span>
<span class="lineno">  760 </span><span class="spaces"></span><span class="nottickedoff">commaEngPandoc _   []    = []</span></span>
<span class="lineno">  761 </span>
<span class="lineno">  762 </span>commaNLPandoc' :: Inlines -&gt; [Inlines] -&gt; Inlines
<span class="lineno">  763 </span><span class="decl"><span class="nottickedoff">commaNLPandoc' s [a,b]  = a &lt;&gt; space &lt;&gt; s &lt;&gt; space &lt;&gt; b</span>
<span class="lineno">  764 </span><span class="spaces"></span><span class="nottickedoff">commaNLPandoc'  _  [a]  = a</span>
<span class="lineno">  765 </span><span class="spaces"></span><span class="nottickedoff">commaNLPandoc' s (a:as) = a &lt;&gt; &quot;, &quot; &lt;&gt; commaNLPandoc' s as</span>
<span class="lineno">  766 </span><span class="spaces"></span><span class="nottickedoff">commaNLPandoc'  _  []   = mempty</span></span>
<span class="lineno">  767 </span>commaNLPandoc :: Inline -&gt; [Inline] -&gt; [Inline]
<span class="lineno">  768 </span><span class="decl"><span class="nottickedoff">commaNLPandoc s [a,b]  = [a,Str &quot; &quot;,s, Str &quot; &quot;, b]</span>
<span class="lineno">  769 </span><span class="spaces"></span><span class="nottickedoff">commaNLPandoc  _  [a]  = [a]</span>
<span class="lineno">  770 </span><span class="spaces"></span><span class="nottickedoff">commaNLPandoc s (a:as) = [a, Str &quot;, &quot;]++commaNLPandoc s as</span>
<span class="lineno">  771 </span><span class="spaces"></span><span class="nottickedoff">commaNLPandoc  _  []   = []</span></span>
<span class="lineno">  772 </span>   
<span class="lineno">  773 </span>commaPandocAnd :: Lang -&gt; [Inlines] -&gt; Inlines
<span class="lineno">  774 </span><span class="decl"><span class="nottickedoff">commaPandocAnd Dutch = commaEngPandoc' &quot;en&quot;</span>
<span class="lineno">  775 </span><span class="spaces"></span><span class="nottickedoff">commaPandocAnd English = commaNLPandoc' &quot;and&quot;</span></span>
<span class="lineno">  776 </span>
<span class="lineno">  777 </span>quadsOfRules :: Options -&gt; [Rule] -&gt; [Quad]
<span class="lineno">  778 </span><span class="decl"><span class="nottickedoff">quadsOfRules opts rules </span>
<span class="lineno">  779 </span><span class="spaces">  </span><span class="nottickedoff">= makeAllQuads (converse [ (conj, rc_orgRules conj) | conj &lt;- makeAllConjs opts rules ])</span></span>
<span class="lineno">  780 </span>
<span class="lineno">  781 </span>        -- Quads embody the &quot;switchboard&quot; of rules. A quad represents a &quot;proto-rule&quot; with the following meaning:
<span class="lineno">  782 </span>        -- whenever relation r is affected (i.e. tuples in r are inserted or deleted),
<span class="lineno">  783 </span>        -- the rule may have to be restored using functionality from one of the clauses.
<span class="lineno">  784 </span>makeAllQuads :: [(Rule, [Conjunct])] -&gt; [Quad]
<span class="lineno">  785 </span><span class="decl"><span class="nottickedoff">makeAllQuads conjsPerRule =</span>
<span class="lineno">  786 </span><span class="spaces">  </span><span class="nottickedoff">[ Quad { qDcl     = d</span>
<span class="lineno">  787 </span><span class="spaces">         </span><span class="nottickedoff">, qRule    = rule</span>
<span class="lineno">  788 </span><span class="spaces">         </span><span class="nottickedoff">, qConjuncts = conjs</span>
<span class="lineno">  789 </span><span class="spaces">         </span><span class="nottickedoff">}</span>
<span class="lineno">  790 </span><span class="spaces">  </span><span class="nottickedoff">| (rule,conjs) &lt;- conjsPerRule, d &lt;-relsUsedIn rule</span>
<span class="lineno">  791 </span><span class="spaces">  </span><span class="nottickedoff">]</span></span>
<span class="lineno">  792 </span>  
<span class="lineno">  793 </span>{-
<span class="lineno">  794 </span>-- If one rule r blocks upon an event, e.g. e@(ON Ins rel), while another ECA rule r'
<span class="lineno">  795 </span>-- maintains something else with that same event e, we can save r' the trouble.
<span class="lineno">  796 </span>-- After all, event e will block anyway.
<span class="lineno">  797 </span>-- preEmpt tries to simplify ECArules by predicting whether a rule will block.
<span class="lineno">  798 </span>preEmpt :: Options -&gt; [ECArule] -&gt; [ECArule]
<span class="lineno">  799 </span>preEmpt opts ers = pr [length ers] (10::Int)
<span class="lineno">  800 </span> where
<span class="lineno">  801 </span>  pr :: [Int] -&gt; Int -&gt; [ECArule]
<span class="lineno">  802 </span>  pr ls n
<span class="lineno">  803 </span>    | n == 0              = fatal 633 $ &quot;too many cascading levels in preEmpt &quot;++show ls
<span class="lineno">  804 </span>    | (not.null) cascaded = pr (length cascaded:ls)
<span class="lineno">  805 </span>                            -- ([er{ecaAction=normPA opts (ecaAction er)} | er&lt;-cascaded] ++uncasced)
<span class="lineno">  806 </span>                               (n-1)
<span class="lineno">  807 </span>    | otherwise           = [er{ecaAction=normPA opts (ecaAction er)} | er&lt;-uncasced]
<span class="lineno">  808 </span>   where
<span class="lineno">  809 </span>-- preEmpt divides all ECA rules in uncascaded rules and cascaded rules.
<span class="lineno">  810 </span>-- cascaded rules are those rules that have a Do component with event e, where e is known to block (for some other reason)
<span class="lineno">  811 </span>    new  = [er{ecaAction=normPA opts (ecaAction er)} | er&lt;-ers]
<span class="lineno">  812 </span>    cascaded = [er{ecaAction=action'} | er&lt;-new, let (c,action') = cascade (eDcl (ecaTriggr er)) (ecaAction er), c]
<span class="lineno">  813 </span>    uncasced = [er |                    er&lt;-new, let (c,_)       = cascade (eDcl (ecaTriggr er)) (ecaAction er), not c]
<span class="lineno">  814 </span>-- cascade inserts a block on the place where a Do component exists that matches the blocking event.
<span class="lineno">  815 </span>--  cascade :: Relation -&gt; PAclause -&gt; (Bool, PAclause)
<span class="lineno">  816 </span>  cascade dcl (Do srt to _ _) | (not.null) blkErs = (True, ecaAction (head blkErs))
<span class="lineno">  817 </span>   where blkErs = [er | er&lt;-ers
<span class="lineno">  818 </span>                      , Blk _&lt;-[ecaAction er]
<span class="lineno">  819 </span>                      , let t = ecaTriggr er
<span class="lineno">  820 </span>                      , eSrt t == srt
<span class="lineno">  821 </span>                      , eDcl t == to
<span class="lineno">  822 </span>                      , not (dcl ==to)
<span class="lineno">  823 </span>                      ]
<span class="lineno">  824 </span>  cascade  _  c@Do{}           = (False, c)
<span class="lineno">  825 </span>  cascade rel (New c clause m) = ((fst.cascade rel.clause) &quot;dummystr&quot;, New c (snd.cascade rel.clause) m)
<span class="lineno">  826 </span>  cascade rel (Rmv c clause m) = ((fst.cascade rel.clause) &quot;dummystr&quot;, Rmv c (snd.cascade rel.clause) m)
<span class="lineno">  827 </span>--cascade rel (Sel c e cl m)   = ((fst.cascade rel.cl) &quot;dummystr&quot;,     Sel c e (snd.cascade rel.cl)   m)
<span class="lineno">  828 </span>  cascade rel (CHC ds m)       = (any (fst.cascade rel) ds, CHC (map (snd.cascade rel) ds) m)
<span class="lineno">  829 </span>  cascade rel (ALL ds m)       = (any (fst.cascade rel) ds, ALL (map (snd.cascade rel) ds) m)
<span class="lineno">  830 </span>  cascade  _  (Nop m)          = (False, Nop m)
<span class="lineno">  831 </span>  cascade  _  (Blk m)          = (False, Blk m)
<span class="lineno">  832 </span>  cascade  _  (Let _ _ _)  = fatal 611 &quot;Deze constructor is niet gedefinieerd&quot; -- HJO, 20131205:Toegevoegd om warning te verwijderen
<span class="lineno">  833 </span>  cascade  _  (Ref _)      = fatal 612 &quot;Deze constructor is niet gedefinieerd&quot; -- HJO, 20131205:Toegevoegd om warning te verwijderen
<span class="lineno">  834 </span>  cascade  _  (GCH{})      = fatal 655 &quot;Deze constructor is niet gedefinieerd&quot; -- SJO, 20140428:Toegevoegd om warning te verwijderen
<span class="lineno">  835 </span>-}
<span class="lineno">  836 </span>
<span class="lineno">  837 </span>   

</pre>
</body>
</html>
