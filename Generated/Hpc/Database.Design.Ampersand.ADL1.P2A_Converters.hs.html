<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=CP850">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="lineno">    1 </span>{-# OPTIONS_GHC -Wall #-}
<span class="lineno">    2 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    3 </span>module Database.Design.Ampersand.ADL1.P2A_Converters (pCtx2aCtx,pCpt2aCpt)
<span class="lineno">    4 </span>where
<span class="lineno">    5 </span>import Database.Design.Ampersand.ADL1.Disambiguate
<span class="lineno">    6 </span>import Database.Design.Ampersand.Core.ParseTree -- (P_Context(..), A_Context(..))
<span class="lineno">    7 </span>import Database.Design.Ampersand.Input.ADL1.CtxError
<span class="lineno">    8 </span>import Database.Design.Ampersand.ADL1.Lattices -- used for type-checking
<span class="lineno">    9 </span>import Database.Design.Ampersand.Core.AbstractSyntaxTree hiding (sortWith, maxima, greatest)
<span class="lineno">   10 </span>import Database.Design.Ampersand.Classes.ViewPoint hiding (gens)
<span class="lineno">   11 </span>import Database.Design.Ampersand.Classes.ConceptStructure
<span class="lineno">   12 </span>import Database.Design.Ampersand.Basics
<span class="lineno">   13 </span>import Database.Design.Ampersand.Misc
<span class="lineno">   14 </span>import Prelude hiding (sequence, mapM)
<span class="lineno">   15 </span>import Control.Applicative
<span class="lineno">   16 </span>import Data.Traversable
<span class="lineno">   17 </span>import qualified Data.Set as Set
<span class="lineno">   18 </span>import qualified Data.Map as Map
<span class="lineno">   19 </span>import Data.Function
<span class="lineno">   20 </span>import Data.Maybe
<span class="lineno">   21 </span>import Data.List(nub)
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>fatal :: Int -&gt; String -&gt; a
<span class="lineno">   24 </span><span class="decl"><span class="nottickedoff">fatal = fatalMsg &quot;ADL1.P2A_Converters&quot;</span></span>
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>newtype SignOrd = SignOrd Sign
<span class="lineno">   27 </span>instance Ord SignOrd where
<span class="lineno">   28 </span>  <span class="decl"><span class="istickedoff">compare (SignOrd (Sign a b)) (SignOrd (Sign c d)) = compare (name a,name b) (name c,name d)</span></span>
<span class="lineno">   29 </span>instance Eq SignOrd where
<span class="lineno">   30 </span>  <span class="decl"><span class="nottickedoff">(==) (SignOrd (Sign a b)) (SignOrd (Sign c d)) = (name a,name b) == (name c,name d)</span></span>
<span class="lineno">   31 </span>
<span class="lineno">   32 </span>-- pCtx2aCtx has three tasks:
<span class="lineno">   33 </span>-- 1) Disambiguate the structures.
<span class="lineno">   34 </span>--    Disambiguation means replacing every &quot;TermPrim&quot; (the parsed expression) with the correct Expression (available through DisambPrim)
<span class="lineno">   35 </span>--    This is done by using the function &quot;disambiguate&quot; on the outer-most structure.
<span class="lineno">   36 </span>--    In order to do this, its data type must be polymorphic, as in &quot;P_ViewSegmt a&quot;.
<span class="lineno">   37 </span>--    After parsing, the type has TermPrim for the type variable. In our example: &quot;P_ViewSegmt TermPrim&quot;. Note that &quot;type P_ViewSegment = P_ViewSegmt TermPrim&quot;.
<span class="lineno">   38 </span>--    After disambiguation, the type variable is (TermPrim, DisambPrim), as in &quot;P_ViewSegmt (TermPrim, DisambPrim)&quot;
<span class="lineno">   39 </span>-- 2) Typecheck the structures.
<span class="lineno">   40 </span>--    This changes the data-structure entirely, changing the P_ into the A_
<span class="lineno">   41 </span>--    A &quot;Guarded&quot; will be added on the outside, in order to catch both type errors and disambiguation errors.
<span class="lineno">   42 </span>--    Using the Applicative operations &lt;$&gt; and &lt;*&gt; causes these errors to be in parallel
<span class="lineno">   43 </span>-- 3) Check everything else on the A_-structure: interface references should not be cyclic, rules e.a. must have unique names, etc.
<span class="lineno">   44 </span>-- Part 3 is done below, the other two are done in pCtx2aCtx'
<span class="lineno">   45 </span>pCtx2aCtx :: Options -&gt; P_Context -&gt; Guarded A_Context
<span class="lineno">   46 </span><span class="decl"><span class="istickedoff">pCtx2aCtx opts = checkOtherAtomsInSessionConcept</span>
<span class="lineno">   47 </span><span class="spaces">               </span><span class="istickedoff">. checkPurposes             -- Check whether all purposes refer to existing objects</span>
<span class="lineno">   48 </span><span class="spaces">               </span><span class="istickedoff">. checkDanglingRulesInRuleRoles -- Check whether all rules in MAINTAIN statements are declared</span>
<span class="lineno">   49 </span><span class="spaces">               </span><span class="istickedoff">. checkInterfaceCycles      -- Check that interface references are not cyclic</span>
<span class="lineno">   50 </span><span class="spaces">               </span><span class="istickedoff">. checkMultipleDefaultViews -- Check whether each concept has at most one default view</span>
<span class="lineno">   51 </span><span class="spaces">               </span><span class="istickedoff">. checkUnique udefrules     -- Check uniquene names of: rules,</span>
<span class="lineno">   52 </span><span class="spaces">               </span><span class="istickedoff">. checkUnique patterns      --                          patterns,</span>
<span class="lineno">   53 </span><span class="spaces">               </span><span class="istickedoff">. checkUnique ctxvs         --                          view defs,</span>
<span class="lineno">   54 </span><span class="spaces">               </span><span class="istickedoff">. checkUnique ctxifcs       --                          and interfaces.</span>
<span class="lineno">   55 </span><span class="spaces">               </span><span class="istickedoff">. pCtx2aCtx' <span class="nottickedoff">opts</span></span>
<span class="lineno">   56 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">   57 </span><span class="spaces">    </span><span class="istickedoff">checkUnique f gCtx =</span>
<span class="lineno">   58 </span><span class="spaces">     </span><span class="istickedoff">case gCtx of</span>
<span class="lineno">   59 </span><span class="spaces">       </span><span class="istickedoff">Checked ctx -&gt; case uniqueNames (f ctx) of</span>
<span class="lineno">   60 </span><span class="spaces">                         </span><span class="istickedoff">Checked () -&gt; gCtx</span>
<span class="lineno">   61 </span><span class="spaces">                         </span><span class="istickedoff">Errors err -&gt; Errors err</span>
<span class="lineno">   62 </span><span class="spaces">       </span><span class="istickedoff">Errors err -&gt; Errors err</span></span>
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>-- NOTE: Static checks like checkPurposes should ideally occur on the P-structure before type-checking, as it makes little
<span class="lineno">   65 </span>-- sense to do type checking when there are static errors. However, in Ampersand all collect functions (e.g. in ViewPoint)
<span class="lineno">   66 </span>-- only exist on the A-Structure, so we do it afterwards. Static purpose errors won't affect types, so in this case it is no problem. 
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>-- Check whether all purposes refer to existing objects.
<span class="lineno">   69 </span>checkPurposes :: Guarded A_Context -&gt; Guarded A_Context
<span class="lineno">   70 </span><span class="decl"><span class="istickedoff">checkPurposes gCtx =</span>
<span class="lineno">   71 </span><span class="spaces">  </span><span class="istickedoff">case gCtx of</span>
<span class="lineno">   72 </span><span class="spaces">    </span><span class="istickedoff">Errors err  -&gt; Errors err</span>
<span class="lineno">   73 </span><span class="spaces">    </span><span class="istickedoff">Checked ctx -&gt; let topLevelPurposes = ctxps ctx</span>
<span class="lineno">   74 </span><span class="spaces">                       </span><span class="istickedoff">purposesInPatterns = concatMap ptxps (ctxpats ctx)</span>
<span class="lineno">   75 </span><span class="spaces">                       </span><span class="istickedoff">allPurposes = topLevelPurposes ++ purposesInPatterns</span>
<span class="lineno">   76 </span><span class="spaces">                       </span><span class="istickedoff">danglingPurposes = filter (isDanglingPurpose ctx) allPurposes</span>
<span class="lineno">   77 </span><span class="spaces">                   </span><span class="istickedoff">in  if null danglingPurposes then gCtx else Errors $ map mkDanglingPurposeError danglingPurposes</span></span>
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>-- Return True if the ExplObj in this Purpose does not exist.
<span class="lineno">   80 </span>isDanglingPurpose :: A_Context -&gt; Purpose -&gt; Bool
<span class="lineno">   81 </span><span class="decl"><span class="istickedoff">isDanglingPurpose ctx purp = </span>
<span class="lineno">   82 </span><span class="spaces">  </span><span class="istickedoff">case explObj purp of</span>
<span class="lineno">   83 </span><span class="spaces">    </span><span class="istickedoff">ExplConceptDef concDef -&gt; let nm = name concDef in nm `notElem` map name (ctxcds ctx )</span>
<span class="lineno">   84 </span><span class="spaces">    </span><span class="istickedoff">ExplDeclaration decl -&gt; let nm = name decl in nm `notElem` map name (relsDefdIn ctx) -- is already covered by type checker</span>
<span class="lineno">   85 </span><span class="spaces">    </span><span class="istickedoff">ExplRule nm -&gt; nm `notElem` map name (udefrules ctx) </span>
<span class="lineno">   86 </span><span class="spaces">    </span><span class="istickedoff">ExplIdentityDef nm -&gt; nm `notElem` map name (identities ctx)</span>
<span class="lineno">   87 </span><span class="spaces">    </span><span class="istickedoff">ExplViewDef nm -&gt;  nm `notElem` map name (viewDefs ctx)</span>
<span class="lineno">   88 </span><span class="spaces">    </span><span class="istickedoff">ExplPattern nm -&gt; nm `notElem` map name (ctxpats ctx)</span>
<span class="lineno">   89 </span><span class="spaces">    </span><span class="istickedoff">ExplInterface nm -&gt; nm `notElem` map name (ctxifcs ctx)</span>
<span class="lineno">   90 </span><span class="spaces">    </span><span class="istickedoff">ExplContext nm -&gt; ctxnm ctx /= nm </span>
<span class="lineno">   91 </span><span class="spaces">                         </span><span class="istickedoff">&amp;&amp; False</span></span> -- HJO: This line is a workaround for the issue mentioned in https://github.com/AmpersandTarski/ampersand/issues/46
<span class="lineno">   92 </span>                                  -- TODO: fix this when we pick up working on multiple contexts.
<span class="lineno">   93 </span>-- Check that interface references are not cyclic
<span class="lineno">   94 </span>checkInterfaceCycles :: Guarded A_Context -&gt; Guarded A_Context
<span class="lineno">   95 </span><span class="decl"><span class="istickedoff">checkInterfaceCycles gCtx =</span>
<span class="lineno">   96 </span><span class="spaces">  </span><span class="istickedoff">case gCtx of</span>
<span class="lineno">   97 </span><span class="spaces">    </span><span class="istickedoff">Errors err  -&gt; Errors err</span>
<span class="lineno">   98 </span><span class="spaces">    </span><span class="istickedoff">Checked ctx -&gt; if null interfaceCycles then gCtx else Errors $  map <span class="nottickedoff">mkInterfaceRefCycleError</span> interfaceCycles</span>
<span class="lineno">   99 </span><span class="spaces">      </span><span class="istickedoff">where interfaceCycles = [ <span class="nottickedoff">map lookupInterface iCycle</span> | iCycle &lt;- getCycles refsPerInterface ]</span>
<span class="lineno">  100 </span><span class="spaces">            </span><span class="istickedoff">refsPerInterface = [(name ifc, getDeepIfcRefs $ ifcObj ifc) | ifc &lt;- ctxifcs ctx ]</span>
<span class="lineno">  101 </span><span class="spaces">            </span><span class="istickedoff">getDeepIfcRefs obj = case objmsub obj of</span>
<span class="lineno">  102 </span><span class="spaces">                                   </span><span class="istickedoff">Nothing                  -&gt; []</span>
<span class="lineno">  103 </span><span class="spaces">                                   </span><span class="istickedoff">Just (InterfaceRef _ nm) -&gt; [nm]</span>
<span class="lineno">  104 </span><span class="spaces">                                   </span><span class="istickedoff">Just (Box _ _ objs)      -&gt; concatMap getDeepIfcRefs objs</span>
<span class="lineno">  105 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">lookupInterface nm = case [ ifc | ifc &lt;- ctxifcs ctx, name ifc == nm ] of</span></span>
<span class="lineno">  106 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">[ifc] -&gt; ifc</span></span>
<span class="lineno">  107 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">_     -&gt; fatal 124 &quot;Interface lookup returned zero or more than one result&quot;</span></span></span>
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>-- Check whether each concept has at most one default view
<span class="lineno">  110 </span>checkMultipleDefaultViews :: Guarded A_Context -&gt; Guarded A_Context
<span class="lineno">  111 </span><span class="decl"><span class="istickedoff">checkMultipleDefaultViews gCtx =</span>
<span class="lineno">  112 </span><span class="spaces">  </span><span class="istickedoff">case gCtx of</span>
<span class="lineno">  113 </span><span class="spaces">    </span><span class="istickedoff">Errors err  -&gt; Errors err</span>
<span class="lineno">  114 </span><span class="spaces">    </span><span class="istickedoff">Checked ctx -&gt; let conceptsWithMultipleViews = [ <span class="nottickedoff">(c,vds)</span>| vds@(Vd{vdcpt=c}:_:_) &lt;- eqClass ((==) `on` vdcpt) $ filter vdIsDefault (ctxvs ctx) ]</span>
<span class="lineno">  115 </span><span class="spaces">                   </span><span class="istickedoff">in  if <span class="tickonlytrue">null conceptsWithMultipleViews</span> then gCtx else <span class="nottickedoff">Errors $ map mkMultipleDefaultError conceptsWithMultipleViews</span></span></span>
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>checkDanglingRulesInRuleRoles :: Guarded A_Context -&gt; Guarded A_Context
<span class="lineno">  118 </span><span class="decl"><span class="istickedoff">checkDanglingRulesInRuleRoles gCtx =</span>
<span class="lineno">  119 </span><span class="spaces">  </span><span class="istickedoff">case gCtx of</span>
<span class="lineno">  120 </span><span class="spaces">    </span><span class="istickedoff">Errors _  -&gt; gCtx</span>
<span class="lineno">  121 </span><span class="spaces">    </span><span class="istickedoff">Checked ctx -&gt; case [mkDanglingRefError &quot;Rule&quot; nm (arPos rr)  </span>
<span class="lineno">  122 </span><span class="spaces">                        </span><span class="istickedoff">| rr &lt;- ctxrrules ctx</span>
<span class="lineno">  123 </span><span class="spaces">                        </span><span class="istickedoff">, nm &lt;- arRules rr</span>
<span class="lineno">  124 </span><span class="spaces">                        </span><span class="istickedoff">, nm `notElem` map name (allRules ctx)</span>
<span class="lineno">  125 </span><span class="spaces">                        </span><span class="istickedoff">] of</span>
<span class="lineno">  126 </span><span class="spaces">                     </span><span class="istickedoff">[] -&gt; gCtx</span>
<span class="lineno">  127 </span><span class="spaces">                     </span><span class="istickedoff">errs -&gt; Errors errs</span></span>
<span class="lineno">  128 </span>checkOtherAtomsInSessionConcept :: Guarded A_Context -&gt; Guarded A_Context
<span class="lineno">  129 </span><span class="decl"><span class="istickedoff">checkOtherAtomsInSessionConcept gCtx =</span>
<span class="lineno">  130 </span><span class="spaces">   </span><span class="istickedoff">case gCtx of</span>
<span class="lineno">  131 </span><span class="spaces">     </span><span class="istickedoff">Errors _  -&gt; gCtx</span>
<span class="lineno">  132 </span><span class="spaces">     </span><span class="istickedoff">Checked ctx -&gt; case [<span class="nottickedoff">mkOtherAtomInSessionError atom</span></span>
<span class="lineno">  133 </span><span class="spaces">                         </span><span class="istickedoff">| pop@PCptPopu{popcpt =cpt} &lt;- ctxpopus ctx</span>
<span class="lineno">  134 </span><span class="spaces">                         </span><span class="istickedoff">, name cpt == &quot;SESSION&quot;</span>
<span class="lineno">  135 </span><span class="spaces">                         </span><span class="istickedoff">, atom &lt;- filter (/= &quot;_SESSION&quot;) (popas pop)</span>
<span class="lineno">  136 </span><span class="spaces">                         </span><span class="istickedoff">] of</span>
<span class="lineno">  137 </span><span class="spaces">                      </span><span class="istickedoff">[] -&gt; gCtx</span>
<span class="lineno">  138 </span><span class="spaces">                      </span><span class="istickedoff">errs -&gt; Errors errs</span></span>
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>pCtx2aCtx' :: Options -&gt; P_Context -&gt; Guarded A_Context
<span class="lineno">  141 </span><span class="decl"><span class="istickedoff">pCtx2aCtx' _</span>
<span class="lineno">  142 </span><span class="spaces"> </span><span class="istickedoff">PCtx { ctx_nm     = n1</span>
<span class="lineno">  143 </span><span class="spaces">      </span><span class="istickedoff">, ctx_pos    = n2</span>
<span class="lineno">  144 </span><span class="spaces">      </span><span class="istickedoff">, ctx_lang   = lang</span>
<span class="lineno">  145 </span><span class="spaces">      </span><span class="istickedoff">, ctx_markup = pandocf</span>
<span class="lineno">  146 </span><span class="spaces">      </span><span class="istickedoff">, ctx_thms   = p_themes </span>
<span class="lineno">  147 </span><span class="spaces">      </span><span class="istickedoff">, ctx_pats   = p_patterns</span>
<span class="lineno">  148 </span><span class="spaces">      </span><span class="istickedoff">, ctx_rs     = p_rules    </span>
<span class="lineno">  149 </span><span class="spaces">      </span><span class="istickedoff">, ctx_ds     = p_declarations</span>
<span class="lineno">  150 </span><span class="spaces">      </span><span class="istickedoff">, ctx_cs     = p_conceptdefs</span>
<span class="lineno">  151 </span><span class="spaces">      </span><span class="istickedoff">, ctx_ks     = p_identdefs</span>
<span class="lineno">  152 </span><span class="spaces">      </span><span class="istickedoff">, ctx_rrules = p_roleRules</span>
<span class="lineno">  153 </span><span class="spaces">      </span><span class="istickedoff">, ctx_rrels  = p_roleRelations</span>
<span class="lineno">  154 </span><span class="spaces">      </span><span class="istickedoff">, ctx_vs     = p_viewdefs</span>
<span class="lineno">  155 </span><span class="spaces">      </span><span class="istickedoff">, ctx_gs     = p_gens</span>
<span class="lineno">  156 </span><span class="spaces">      </span><span class="istickedoff">, ctx_ifcs   = p_interfaces</span>
<span class="lineno">  157 </span><span class="spaces">      </span><span class="istickedoff">, ctx_ps     = p_purposes</span>
<span class="lineno">  158 </span><span class="spaces">      </span><span class="istickedoff">, ctx_pops   = p_pops</span>
<span class="lineno">  159 </span><span class="spaces">      </span><span class="istickedoff">, ctx_sql    = p_sqldefs</span>
<span class="lineno">  160 </span><span class="spaces">      </span><span class="istickedoff">, ctx_php    = p_phpdefs</span>
<span class="lineno">  161 </span><span class="spaces">      </span><span class="istickedoff">, ctx_metas  = p_metas</span>
<span class="lineno">  162 </span><span class="spaces">      </span><span class="istickedoff">}</span>
<span class="lineno">  163 </span><span class="spaces"> </span><span class="istickedoff">= (\pats rules identdefs viewdefs interfaces purposes udpops sqldefs phpdefs allRoleRelations</span>
<span class="lineno">  164 </span><span class="spaces">     </span><span class="istickedoff">-&gt; ACtx{ ctxnm = n1</span>
<span class="lineno">  165 </span><span class="spaces">            </span><span class="istickedoff">, ctxpos = <span class="nottickedoff">n2</span></span>
<span class="lineno">  166 </span><span class="spaces">            </span><span class="istickedoff">, ctxlang = <span class="nottickedoff">deflangCtxt</span></span>
<span class="lineno">  167 </span><span class="spaces">            </span><span class="istickedoff">, ctxmarkup = <span class="nottickedoff">deffrmtCtxt</span></span>
<span class="lineno">  168 </span><span class="spaces">            </span><span class="istickedoff">, ctxthms = <span class="nottickedoff">p_themes</span></span>
<span class="lineno">  169 </span><span class="spaces">            </span><span class="istickedoff">, ctxpats = pats</span>
<span class="lineno">  170 </span><span class="spaces">            </span><span class="istickedoff">, ctxrs = rules</span>
<span class="lineno">  171 </span><span class="spaces">            </span><span class="istickedoff">, ctxds = ctxDecls</span>
<span class="lineno">  172 </span><span class="spaces">            </span><span class="istickedoff">, ctxpopus = nub (udpops++dclPops++mp1Pops rules++mp1Pops pats++mp1Pops identdefs++mp1Pops viewdefs++mp1Pops interfaces)</span>
<span class="lineno">  173 </span><span class="spaces">            </span><span class="istickedoff">, ctxcds = allConceptDefs</span>
<span class="lineno">  174 </span><span class="spaces">            </span><span class="istickedoff">, ctxks = identdefs</span>
<span class="lineno">  175 </span><span class="spaces">            </span><span class="istickedoff">, ctxrrules = allRoleRules</span>
<span class="lineno">  176 </span><span class="spaces">            </span><span class="istickedoff">, ctxRRels = <span class="nottickedoff">allRoleRelations</span></span>
<span class="lineno">  177 </span><span class="spaces">            </span><span class="istickedoff">, ctxvs = viewdefs</span>
<span class="lineno">  178 </span><span class="spaces">            </span><span class="istickedoff">, ctxgs = <span class="nottickedoff">map pGen2aGen p_gens</span></span>
<span class="lineno">  179 </span><span class="spaces">            </span><span class="istickedoff">, ctxgenconcs = <span class="nottickedoff">map (map castConcept) (concGroups ++ map (:[]) soloConcs)</span></span>
<span class="lineno">  180 </span><span class="spaces">            </span><span class="istickedoff">, ctxifcs = interfaces</span>
<span class="lineno">  181 </span><span class="spaces">            </span><span class="istickedoff">, ctxps = purposes</span>
<span class="lineno">  182 </span><span class="spaces">            </span><span class="istickedoff">, ctxsql = <span class="nottickedoff">sqldefs</span></span>
<span class="lineno">  183 </span><span class="spaces">            </span><span class="istickedoff">, ctxphp = <span class="nottickedoff">phpdefs</span></span>
<span class="lineno">  184 </span><span class="spaces">            </span><span class="istickedoff">, ctxmetas = <span class="nottickedoff">p_metas</span></span>
<span class="lineno">  185 </span><span class="spaces">            </span><span class="istickedoff">}</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="istickedoff">) &lt;$&gt; traverse pPat2aPat p_patterns            --  The patterns defined in this context</span>
<span class="lineno">  187 </span><span class="spaces">      </span><span class="istickedoff">&lt;*&gt; traverse (pRul2aRul <span class="nottickedoff">n1</span>) p_rules       --  All user defined rules in this context, but outside patterns</span>
<span class="lineno">  188 </span><span class="spaces">      </span><span class="istickedoff">&lt;*&gt; traverse pIdentity2aIdentity p_identdefs --  The identity definitions defined in this context, outside the scope of patterns</span>
<span class="lineno">  189 </span><span class="spaces">      </span><span class="istickedoff">&lt;*&gt; traverse pViewDef2aViewDef p_viewdefs    --  The view definitions defined in this context, outside the scope of patterns</span>
<span class="lineno">  190 </span><span class="spaces">      </span><span class="istickedoff">&lt;*&gt; traverse pIfc2aIfc p_interfaceAndDisambObjs   --  TODO: explain   ... The interfaces defined in this context, outside the scope of patterns</span>
<span class="lineno">  191 </span><span class="spaces">      </span><span class="istickedoff">&lt;*&gt; traverse pPurp2aPurp p_purposes          --  The purposes of objects defined in this context, outside the scope of patterns</span>
<span class="lineno">  192 </span><span class="spaces">      </span><span class="istickedoff">&lt;*&gt; traverse pPop2aPop p_pops                --  [Population]</span>
<span class="lineno">  193 </span><span class="spaces">      </span><span class="istickedoff">&lt;*&gt; traverse <span class="nottickedoff">pObjDef2aObjDef</span> p_sqldefs       --  user defined sqlplugs, taken from the Ampersand script</span>
<span class="lineno">  194 </span><span class="spaces">      </span><span class="istickedoff">&lt;*&gt; traverse <span class="nottickedoff">pObjDef2aObjDef</span> p_phpdefs       --  user defined phpplugs, taken from the Ampersand script</span>
<span class="lineno">  195 </span><span class="spaces">      </span><span class="istickedoff">&lt;*&gt; traverse pRoleRelation2aRoleRelation (p_roleRelations ++ concatMap pt_RRels p_patterns)</span>
<span class="lineno">  196 </span><span class="spaces">      </span><span class="istickedoff"></span>
<span class="lineno">  197 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">p_interfaceAndDisambObjs :: [(P_Interface, P_ObjDef (TermPrim, DisambPrim))]</span>
<span class="lineno">  199 </span><span class="spaces">    </span><span class="istickedoff">p_interfaceAndDisambObjs = [ (ifc, disambiguate termPrimDisAmb $ ifc_Obj ifc) | ifc &lt;- p_interfaces ]</span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">-- story about genRules and genLattice</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff">-- the genRules is a list of equalities between concept sets, in which every set is interpreted as a conjunction of concepts</span>
<span class="lineno">  202 </span><span class="spaces">    </span><span class="istickedoff">-- the genLattice is the resulting optimized structure</span>
<span class="lineno">  203 </span><span class="spaces">    </span><span class="istickedoff">genRules = [ ( Set.singleton (name (gen_spc x)), Set.fromList (map name (gen_concs x)))</span>
<span class="lineno">  204 </span><span class="spaces">               </span><span class="istickedoff">| x &lt;- p_gens ++ concatMap pt_gns p_patterns</span>
<span class="lineno">  205 </span><span class="spaces">               </span><span class="istickedoff">]</span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="istickedoff">genLattice :: Op1EqualitySystem String</span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">genLattice = optimize1 (foldr addEquality emptySystem genRules)</span>
<span class="lineno">  208 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  209 </span><span class="spaces">    </span><span class="istickedoff">concGroups :: [[String]]</span>
<span class="lineno">  210 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">concGroups = getGroups genLattice</span></span>
<span class="lineno">  211 </span><span class="spaces">    </span><span class="istickedoff">allConcs :: Set.Set String</span>
<span class="lineno">  212 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">allConcs = Set.fromList (map (name . source) decls ++ map (name . target) decls)</span></span>
<span class="lineno">  213 </span><span class="spaces">    </span><span class="istickedoff">soloConcs :: [String]</span>
<span class="lineno">  214 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">soloConcs = filter (not . isInSystem genLattice) (Set.toList allConcs)</span></span>
<span class="lineno">  215 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">deflangCtxt = lang</span> -- take the default language from the top-level context</span>
<span class="lineno">  217 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">deffrmtCtxt = fromMaybe ReST pandocf</span></span>
<span class="lineno">  219 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  220 </span><span class="spaces">    </span><span class="istickedoff">(decls,dclPops)= unzip dps</span>
<span class="lineno">  221 </span><span class="spaces">    </span><span class="istickedoff">(ctxDecls,_ ) = unzip ctxDecls'</span>
<span class="lineno">  222 </span><span class="spaces">    </span><span class="istickedoff">dps = ctxDecls'++patDecls</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="istickedoff">ctxDecls' = [ pDecl2aDecl <span class="nottickedoff">n1</span>         <span class="nottickedoff">deflangCtxt</span> <span class="nottickedoff">deffrmtCtxt</span> pDecl | pDecl&lt;-p_declarations ] --  The relations declared in this context, outside the scope of patterns</span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="istickedoff">patDecls  = [ pDecl2aDecl <span class="nottickedoff">(name pat)</span> <span class="nottickedoff">deflangCtxt</span> <span class="nottickedoff">deffrmtCtxt</span> pDecl | pat&lt;-p_patterns , pDecl&lt;-pt_dcs pat ] --  The relations declared in all patterns within this context.</span>
<span class="lineno">  225 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  226 </span><span class="spaces"></span><span class="istickedoff">-- In order to find declarations efficiently, a Map is constructed to search declarations by name.</span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="istickedoff">declMap = Map.map groupOnTp (Map.fromListWith (++) [(name d,[d]) | d &lt;- decls])</span>
<span class="lineno">  228 </span><span class="spaces">      </span><span class="istickedoff">where groupOnTp lst = Map.fromListWith accumDecl [(SignOrd$ sign d,d) | d &lt;- lst]</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff">findDecls x = Map.findWithDefault Map.empty x declMap  -- get all declarations with the same name as x</span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff">findDecl o x = (getOneExactly o . Map.elems . findDecls) x</span>
<span class="lineno">  231 </span><span class="spaces">    </span><span class="istickedoff">findDeclsTyped x tp = Map.findWithDefault [] (SignOrd tp) (Map.map (:[]) (findDecls x))</span>
<span class="lineno">  232 </span><span class="spaces">    </span><span class="istickedoff">findDeclTyped o x tp = getOneExactly o (findDeclsTyped x tp)</span>
<span class="lineno">  233 </span><span class="spaces">    </span><span class="istickedoff">-- accumDecl is the function that combines two relations into one</span>
<span class="lineno">  234 </span><span class="spaces">    </span><span class="istickedoff">-- meanings, for instance, two should get combined into a list of meanings, et cetera</span>
<span class="lineno">  235 </span><span class="spaces">    </span><span class="istickedoff">-- positions are combined</span>
<span class="lineno">  236 </span><span class="spaces">    </span><span class="istickedoff">-- TODO</span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff">accumDecl :: Declaration -&gt; Declaration -&gt; Declaration</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">accumDecl a _ = a</span>
<span class="lineno">  239 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  240 </span><span class="spaces">    </span><span class="istickedoff">pDecl2aDecl ::</span>
<span class="lineno">  241 </span><span class="spaces">         </span><span class="istickedoff">String         -- The name of the pattern</span>
<span class="lineno">  242 </span><span class="spaces">      </span><span class="istickedoff">-&gt; Lang           -- The default language</span>
<span class="lineno">  243 </span><span class="spaces">      </span><span class="istickedoff">-&gt; PandocFormat   -- The default pandocFormat</span>
<span class="lineno">  244 </span><span class="spaces">      </span><span class="istickedoff">-&gt; P_Declaration -&gt; (Declaration, Population)</span>
<span class="lineno">  245 </span><span class="spaces">    </span><span class="istickedoff">pDecl2aDecl patNm defLanguage defFormat pd</span>
<span class="lineno">  246 </span><span class="spaces">     </span><span class="istickedoff">= let (prL:prM:prR:_) = <span class="nottickedoff">dec_pragma pd ++ [&quot;&quot;, &quot;&quot;, &quot;&quot;]</span></span>
<span class="lineno">  247 </span><span class="spaces">           </span><span class="istickedoff">dcl = Sgn { decnm   = dec_nm pd</span>
<span class="lineno">  248 </span><span class="spaces">                     </span><span class="istickedoff">, decsgn  = pSign2aSign (dec_sign pd)</span>
<span class="lineno">  249 </span><span class="spaces">                     </span><span class="istickedoff">, decprps = dec_prps pd</span>
<span class="lineno">  250 </span><span class="spaces">                     </span><span class="istickedoff">, decprps_calc = <span class="nottickedoff">Nothing</span>  --decprps_calc in an A_Context are still the user-defined only. prps are calculated in adl2fspec.</span>
<span class="lineno">  251 </span><span class="spaces">                     </span><span class="istickedoff">, decprL  = <span class="nottickedoff">prL</span></span>
<span class="lineno">  252 </span><span class="spaces">                     </span><span class="istickedoff">, decprM  = <span class="nottickedoff">prM</span></span>
<span class="lineno">  253 </span><span class="spaces">                     </span><span class="istickedoff">, decprR  = <span class="nottickedoff">prR</span></span>
<span class="lineno">  254 </span><span class="spaces">                     </span><span class="istickedoff">, decMean = <span class="nottickedoff">pMean2aMean defLanguage defFormat (dec_Mean pd)</span></span>
<span class="lineno">  255 </span><span class="spaces">                     </span><span class="istickedoff">, decfpos = <span class="nottickedoff">dec_fpos pd</span></span>
<span class="lineno">  256 </span><span class="spaces">                     </span><span class="istickedoff">, deciss  = <span class="nottickedoff">True</span></span>
<span class="lineno">  257 </span><span class="spaces">                     </span><span class="istickedoff">, decusr  = <span class="nottickedoff">True</span></span>
<span class="lineno">  258 </span><span class="spaces">                     </span><span class="istickedoff">, decpat  = <span class="nottickedoff">patNm</span></span>
<span class="lineno">  259 </span><span class="spaces">                     </span><span class="istickedoff">, decplug = <span class="nottickedoff">dec_plug pd</span></span>
<span class="lineno">  260 </span><span class="spaces">                     </span><span class="istickedoff">}</span>
<span class="lineno">  261 </span><span class="spaces">       </span><span class="istickedoff">in (dcl, PRelPopu { popdcl = dcl, popps = dec_popu pd})</span>
<span class="lineno">  262 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff">pSign2aSign :: P_Sign -&gt; Sign</span>
<span class="lineno">  264 </span><span class="spaces">    </span><span class="istickedoff">pSign2aSign (P_Sign src tgt) = Sign (pCpt2aCpt src) (pCpt2aCpt tgt)</span>
<span class="lineno">  265 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  266 </span><span class="spaces">    </span><span class="istickedoff">pGen2aGen :: P_Gen -&gt; A_Gen</span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pGen2aGen pg@PGen{}</span></span>
<span class="lineno">  268 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">= Isa{gengen = pCpt2aCpt (gen_gen pg)</span></span>
<span class="lineno">  269 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">,genspc = pCpt2aCpt (gen_spc pg)</span></span>
<span class="lineno">  270 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pGen2aGen pg@P_Cy{}</span></span>
<span class="lineno">  272 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">= IsE { genrhs = map pCpt2aCpt (gen_rhs pg)</span></span>
<span class="lineno">  273 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">, genspc = pCpt2aCpt (gen_spc pg)</span></span>
<span class="lineno">  274 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno">  275 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  276 </span><span class="spaces">    </span><span class="istickedoff">castSign :: String -&gt; String -&gt; Sign</span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="istickedoff">castSign a b = Sign (castConcept a) (castConcept b)</span>
<span class="lineno">  278 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff">leastConcept :: A_Concept -&gt; String -&gt; A_Concept</span>
<span class="lineno">  280 </span><span class="spaces">    </span><span class="istickedoff">leastConcept c str</span>
<span class="lineno">  281 </span><span class="spaces">     </span><span class="istickedoff">= case (name c `elem` leastConcepts, str `elem` leastConcepts) of</span>
<span class="lineno">  282 </span><span class="spaces">         </span><span class="istickedoff">(True, _) -&gt; c</span>
<span class="lineno">  283 </span><span class="spaces">         </span><span class="istickedoff">(_, True) -&gt; castConcept str</span>
<span class="lineno">  284 </span><span class="spaces">         </span><span class="istickedoff">(_, _)    -&gt; <span class="nottickedoff">fatal 178 (&quot;Either &quot;++name c++&quot; or &quot;++str++&quot; should be a subset of the other.&quot; )</span></span>
<span class="lineno">  285 </span><span class="spaces">       </span><span class="istickedoff">where</span>
<span class="lineno">  286 </span><span class="spaces">         </span><span class="istickedoff">leastConcepts = findExact genLattice (Atom (name c) `Meet` (Atom str))</span>
<span class="lineno">  287 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="istickedoff">castConcept :: String -&gt; A_Concept</span>
<span class="lineno">  289 </span><span class="spaces">    </span><span class="istickedoff">castConcept &quot;ONE&quot; = <span class="nottickedoff">ONE</span></span>
<span class="lineno">  290 </span><span class="spaces">    </span><span class="istickedoff">castConcept x     = PlainConcept { cptnm = x }</span>
<span class="lineno">  291 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  292 </span><span class="spaces">    </span><span class="istickedoff">pPop2aPop :: P_Population -&gt; Guarded Population</span>
<span class="lineno">  293 </span><span class="spaces">    </span><span class="istickedoff">pPop2aPop P_CptPopu { p_cnme = cnm, p_popas = ps }</span>
<span class="lineno">  294 </span><span class="spaces">     </span><span class="istickedoff">= pure PCptPopu{ popcpt = castConcept cnm, popas = <span class="nottickedoff">ps</span> }</span>
<span class="lineno">  295 </span><span class="spaces">    </span><span class="istickedoff">pPop2aPop orig@(P_RelPopu { p_rnme = rnm, p_popps = ps })</span>
<span class="lineno">  296 </span><span class="spaces">     </span><span class="istickedoff">= fmap (\dcl -&gt; PRelPopu { popdcl = dcl, popps = ps})</span>
<span class="lineno">  297 </span><span class="spaces">            </span><span class="istickedoff">(findDecl orig rnm)</span>
<span class="lineno">  298 </span><span class="spaces">    </span><span class="istickedoff">pPop2aPop orig@(P_TRelPop { p_rnme = rnm, p_type = tp, p_popps = ps })</span>
<span class="lineno">  299 </span><span class="spaces">     </span><span class="istickedoff">= fmap (\dcl -&gt; PRelPopu { popdcl = dcl, popps = ps})</span>
<span class="lineno">  300 </span><span class="spaces">            </span><span class="istickedoff">(findDeclTyped orig rnm (pSign2aSign tp))</span>
<span class="lineno">  301 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">pObjDef2aObjDef :: P_ObjectDef -&gt; Guarded ObjectDef</span>
<span class="lineno">  303 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pObjDef2aObjDef x = pObjDefDisamb2aObjDef $ disambiguate termPrimDisAmb x</span></span>
<span class="lineno">  304 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  305 </span><span class="spaces">    </span><span class="istickedoff">pObjDefDisamb2aObjDef :: P_ObjDef (TermPrim, DisambPrim) -&gt; Guarded ObjectDef</span>
<span class="lineno">  306 </span><span class="spaces">    </span><span class="istickedoff">pObjDefDisamb2aObjDef x = fmap fst (typecheckObjDef x)</span>
<span class="lineno">  307 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  308 </span><span class="spaces">    </span><span class="istickedoff">pViewDef2aViewDef :: P_ViewDef -&gt; Guarded ViewDef</span>
<span class="lineno">  309 </span><span class="spaces">    </span><span class="istickedoff">pViewDef2aViewDef x = typecheckViewDef tpda</span>
<span class="lineno">  310 </span><span class="spaces">     </span><span class="istickedoff">where tpda = disambiguate termPrimDisAmb x</span>
<span class="lineno">  311 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  312 </span><span class="spaces">    </span><span class="istickedoff">typecheckViewDef :: P_ViewD (TermPrim, DisambPrim) -&gt; Guarded ViewDef</span>
<span class="lineno">  313 </span><span class="spaces">    </span><span class="istickedoff">typecheckViewDef</span>
<span class="lineno">  314 </span><span class="spaces">       </span><span class="istickedoff">o@(P_Vd { vd_pos = orig</span>
<span class="lineno">  315 </span><span class="spaces">            </span><span class="istickedoff">, vd_lbl  = lbl   -- String</span>
<span class="lineno">  316 </span><span class="spaces">            </span><span class="istickedoff">, vd_cpt  = cpt   -- Concept</span>
<span class="lineno">  317 </span><span class="spaces">            </span><span class="istickedoff">, vd_isDefault = isDefault</span>
<span class="lineno">  318 </span><span class="spaces">            </span><span class="istickedoff">, vd_html = mHtml -- Html template</span>
<span class="lineno">  319 </span><span class="spaces">            </span><span class="istickedoff">, vd_ats  = pvs   -- view segment</span>
<span class="lineno">  320 </span><span class="spaces">            </span><span class="istickedoff">})</span>
<span class="lineno">  321 </span><span class="spaces">     </span><span class="istickedoff">= (\vdts</span>
<span class="lineno">  322 </span><span class="spaces">        </span><span class="istickedoff">-&gt; Vd { vdpos  = <span class="nottickedoff">orig</span></span>
<span class="lineno">  323 </span><span class="spaces">              </span><span class="istickedoff">, vdlbl  = lbl</span>
<span class="lineno">  324 </span><span class="spaces">              </span><span class="istickedoff">, vdcpt  = pCpt2aCpt cpt</span>
<span class="lineno">  325 </span><span class="spaces">              </span><span class="istickedoff">, vdIsDefault = isDefault</span>
<span class="lineno">  326 </span><span class="spaces">              </span><span class="istickedoff">, vdhtml = <span class="nottickedoff">mHtml</span></span>
<span class="lineno">  327 </span><span class="spaces">              </span><span class="istickedoff">, vdats  = vdts</span>
<span class="lineno">  328 </span><span class="spaces">              </span><span class="istickedoff">})</span>
<span class="lineno">  329 </span><span class="spaces">       </span><span class="istickedoff">&lt;$&gt; traverse (typeCheckViewSegment o) pvs</span>
<span class="lineno">  330 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  331 </span><span class="spaces">    </span><span class="istickedoff">typeCheckViewSegment :: (P_ViewD a) -&gt; (P_ViewSegmt (TermPrim, DisambPrim)) -&gt; Guarded ViewSegment</span>
<span class="lineno">  332 </span><span class="spaces">    </span><span class="istickedoff">typeCheckViewSegment o vs</span>
<span class="lineno">  333 </span><span class="spaces">     </span><span class="istickedoff">= case vs of </span>
<span class="lineno">  334 </span><span class="spaces">        </span><span class="istickedoff">P_ViewExp{} -&gt; </span>
<span class="lineno">  335 </span><span class="spaces">          </span><span class="istickedoff">unguard $</span>
<span class="lineno">  336 </span><span class="spaces">            </span><span class="istickedoff">(\(obj,b) -&gt; case findExact genLattice (mIsc c (name (source (objctx obj)))) of</span>
<span class="lineno">  337 </span><span class="spaces">                           </span><span class="istickedoff">[] -&gt; mustBeOrdered <span class="nottickedoff">o</span> <span class="nottickedoff">o</span> <span class="nottickedoff">(Src,(source (objctx obj)),obj)</span></span>
<span class="lineno">  338 </span><span class="spaces">                           </span><span class="istickedoff">r  -&gt; if <span class="tickonlytrue">b || <span class="nottickedoff">c `elem` r</span></span> then pure (ViewExp <span class="nottickedoff">(vs_nr vs)</span> obj{objctx = addEpsilonLeft' (head r) (objctx obj)})</span>
<span class="lineno">  339 </span><span class="spaces">                                 </span><span class="istickedoff">else <span class="nottickedoff">mustBeBound (origin obj) [(Tgt,objctx obj)]</span>)</span>
<span class="lineno">  340 </span><span class="spaces">         </span><span class="istickedoff">&lt;$&gt; typecheckObjDef (vs_obj vs)</span>
<span class="lineno">  341 </span><span class="spaces">        </span><span class="istickedoff">P_ViewText{} -&gt; pure$ ViewText <span class="nottickedoff">(vs_nr vs)</span> <span class="nottickedoff">(vs_txt vs)</span></span>
<span class="lineno">  342 </span><span class="spaces">        </span><span class="istickedoff">P_ViewHtml{} -&gt; pure$ ViewHtml <span class="nottickedoff">(vs_nr vs)</span> <span class="nottickedoff">(vs_htm vs)</span></span>
<span class="lineno">  343 </span><span class="spaces">     </span><span class="istickedoff">where c = name (vd_cpt o)</span>
<span class="lineno">  344 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  345 </span><span class="spaces">    </span><span class="istickedoff">isa :: String -&gt; String -&gt; Bool</span>
<span class="lineno">  346 </span><span class="spaces">    </span><span class="istickedoff">isa c1 c2 = c1 `elem` findExact genLattice (Atom c1 `Meet` Atom c2) -- shouldn't this Atom be called a Concept? SJC: Answer: we're using the constructor &quot;Atom&quot; in the lattice sense, not in the relation-algebra sense. c1 and c2 are indeed Concepts here</span>
<span class="lineno">  347 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  348 </span><span class="spaces">    </span><span class="istickedoff">typecheckObjDef :: (P_ObjDef (TermPrim, DisambPrim)) -&gt; Guarded (ObjectDef, Bool)</span>
<span class="lineno">  349 </span><span class="spaces">    </span><span class="istickedoff">typecheckObjDef o@(P_Obj { obj_nm = nm</span>
<span class="lineno">  350 </span><span class="spaces">                             </span><span class="istickedoff">, obj_pos = orig</span>
<span class="lineno">  351 </span><span class="spaces">                             </span><span class="istickedoff">, obj_ctx = ctx</span>
<span class="lineno">  352 </span><span class="spaces">                             </span><span class="istickedoff">, obj_mView = mView</span>
<span class="lineno">  353 </span><span class="spaces">                             </span><span class="istickedoff">, obj_msub = subs</span>
<span class="lineno">  354 </span><span class="spaces">                             </span><span class="istickedoff">, obj_strs = ostrs</span>
<span class="lineno">  355 </span><span class="spaces">                             </span><span class="istickedoff">})</span>
<span class="lineno">  356 </span><span class="spaces">     </span><span class="istickedoff">= unguard $</span>
<span class="lineno">  357 </span><span class="spaces">        </span><span class="istickedoff">(\ (objExpr,(srcBounded,tgtBounded)) -&gt;</span>
<span class="lineno">  358 </span><span class="spaces">            </span><span class="istickedoff">(\case</span>
<span class="lineno">  359 </span><span class="spaces">               </span><span class="istickedoff">Just (newExpr,subStructures) -&gt; obj (newExpr,srcBounded) (Just subStructures)</span>
<span class="lineno">  360 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt; obj (objExpr,srcBounded) Nothing</span>
<span class="lineno">  361 </span><span class="spaces">            </span><span class="istickedoff">)</span>
<span class="lineno">  362 </span><span class="spaces">            </span><span class="istickedoff">&lt;$&gt; maybeOverGuarded (pSubi2aSubi objExpr tgtBounded o) subs &lt;* typeCheckViewAnnotation objExpr mView</span>
<span class="lineno">  363 </span><span class="spaces">        </span><span class="istickedoff">) &lt;$&gt; typecheckTerm ctx</span>
<span class="lineno">  364 </span><span class="spaces">     </span><span class="istickedoff">where      </span>
<span class="lineno">  365 </span><span class="spaces">      </span><span class="istickedoff"></span>
<span class="lineno">  366 </span><span class="spaces">      </span><span class="istickedoff">lookupView :: String -&gt; Maybe P_ViewDef</span>
<span class="lineno">  367 </span><span class="spaces">      </span><span class="istickedoff">lookupView viewId = case [ vd | vd &lt;- p_viewdefs, vd_lbl vd == viewId ] of</span>
<span class="lineno">  368 </span><span class="spaces">                            </span><span class="istickedoff">[]   -&gt; Nothing</span>
<span class="lineno">  369 </span><span class="spaces">                            </span><span class="istickedoff">vd:_ -&gt; Just vd -- return the first one, if there are more, this is caught later on by uniqueness static check</span>
<span class="lineno">  370 </span><span class="spaces">                        </span><span class="istickedoff"></span>
<span class="lineno">  371 </span><span class="spaces">      </span><span class="istickedoff">typeCheckViewAnnotation :: Expression -&gt; Maybe String -&gt; Guarded ()</span>
<span class="lineno">  372 </span><span class="spaces">      </span><span class="istickedoff">typeCheckViewAnnotation _       Nothing       = pure <span class="nottickedoff">()</span></span>
<span class="lineno">  373 </span><span class="spaces">      </span><span class="istickedoff">typeCheckViewAnnotation objExpr (Just viewId) =</span>
<span class="lineno">  374 </span><span class="spaces">        </span><span class="istickedoff">case lookupView viewId of </span>
<span class="lineno">  375 </span><span class="spaces">          </span><span class="istickedoff">Just vd -&gt; let viewAnnCptStr = name $ target objExpr</span>
<span class="lineno">  376 </span><span class="spaces">                         </span><span class="istickedoff">viewDefCptStr = name $ vd_cpt vd</span>
<span class="lineno">  377 </span><span class="spaces">                         </span><span class="istickedoff">viewIsCompatible = viewAnnCptStr `isa` viewDefCptStr</span>
<span class="lineno">  378 </span><span class="spaces">                     </span><span class="istickedoff">in  if viewIsCompatible then pure <span class="nottickedoff">()</span> else Errors [<span class="nottickedoff">mkIncompatibleViewError o viewId viewAnnCptStr viewDefCptStr</span>]</span>
<span class="lineno">  379 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; Errors <span class="nottickedoff">[mkUndeclaredError &quot;view&quot; o viewId]</span> </span>
<span class="lineno">  380 </span><span class="spaces">     </span><span class="istickedoff"></span>
<span class="lineno">  381 </span><span class="spaces">      </span><span class="istickedoff"></span>
<span class="lineno">  382 </span><span class="spaces">      </span><span class="istickedoff">obj (e,sr) s</span>
<span class="lineno">  383 </span><span class="spaces">       </span><span class="istickedoff">= ( Obj { objnm = nm</span>
<span class="lineno">  384 </span><span class="spaces">               </span><span class="istickedoff">, objpos = <span class="nottickedoff">orig</span></span>
<span class="lineno">  385 </span><span class="spaces">               </span><span class="istickedoff">, objctx = e</span>
<span class="lineno">  386 </span><span class="spaces">               </span><span class="istickedoff">, objmView = <span class="nottickedoff">mView</span></span>
<span class="lineno">  387 </span><span class="spaces">               </span><span class="istickedoff">, objmsub = s</span>
<span class="lineno">  388 </span><span class="spaces">               </span><span class="istickedoff">, objstrs = <span class="nottickedoff">ostrs</span></span>
<span class="lineno">  389 </span><span class="spaces">               </span><span class="istickedoff">}, sr)</span>
<span class="lineno">  390 </span><span class="spaces">    </span><span class="istickedoff">addEpsilonLeft',addEpsilonRight' :: String -&gt; Expression -&gt; Expression -- TODO: why use primes here?</span>
<span class="lineno">  391 </span><span class="spaces">    </span><span class="istickedoff">addEpsilonLeft' a e</span>
<span class="lineno">  392 </span><span class="spaces">     </span><span class="istickedoff">= if a==name (source e) then e else EEps (leastConcept (source e) a) (castSign a (name (source e))) .:. e</span>
<span class="lineno">  393 </span><span class="spaces">    </span><span class="istickedoff">addEpsilonRight' a e</span>
<span class="lineno">  394 </span><span class="spaces">     </span><span class="istickedoff">= if a==name (target e) then e else e .:. EEps (leastConcept (target e) a) (castSign (name (target e)) a)</span>
<span class="lineno">  395 </span><span class="spaces">    </span><span class="istickedoff">addEpsilon :: String -&gt; String -&gt; Expression -&gt; Expression</span>
<span class="lineno">  396 </span><span class="spaces">    </span><span class="istickedoff">addEpsilon s t e</span>
<span class="lineno">  397 </span><span class="spaces">     </span><span class="istickedoff">= addEpsilonLeft' s (addEpsilonRight' t e)</span>
<span class="lineno">  398 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  399 </span><span class="spaces">    </span><span class="istickedoff">pSubi2aSubi :: Expression -- Expression of the surrounding</span>
<span class="lineno">  400 </span><span class="spaces">                </span><span class="istickedoff">-&gt; Bool -- Whether the surrounding is bounded</span>
<span class="lineno">  401 </span><span class="spaces">                </span><span class="istickedoff">-&gt; P_ObjDef a -- name of where the error occured!</span>
<span class="lineno">  402 </span><span class="spaces">                </span><span class="istickedoff">-&gt; P_SubIfc (TermPrim, DisambPrim) -- Subinterface to check</span>
<span class="lineno">  403 </span><span class="spaces">                </span><span class="istickedoff">-&gt; Guarded ( Expression -- In the case of a &quot;Ref&quot;, we do not change the type of the subinterface with epsilons, this is to change the type of our surrounding instead. In the case of &quot;Box&quot;, this is simply the original expression (in such a case, epsilons are added to the branches instead)</span>
<span class="lineno">  404 </span><span class="spaces">                           </span><span class="istickedoff">, SubInterface -- the subinterface</span>
<span class="lineno">  405 </span><span class="spaces">                           </span><span class="istickedoff">)</span>
<span class="lineno">  406 </span><span class="spaces">    </span><span class="istickedoff">pSubi2aSubi objExpr b o x</span>
<span class="lineno">  407 </span><span class="spaces">      </span><span class="istickedoff">= case x of</span>
<span class="lineno">  408 </span><span class="spaces">         </span><span class="istickedoff">P_InterfaceRef{si_str = ifcId} </span>
<span class="lineno">  409 </span><span class="spaces">           </span><span class="istickedoff">-&gt;  unguard $</span>
<span class="lineno">  410 </span><span class="spaces">             </span><span class="istickedoff">(\(refIfcExpr,_) -&gt; (\objExprEps -&gt; (objExprEps,InterfaceRef <span class="nottickedoff">(si_isLink x)</span> ifcId)) &lt;$&gt; typeCheckInterfaceRef <span class="nottickedoff">o</span> <span class="nottickedoff">ifcId</span> objExpr refIfcExpr)</span>
<span class="lineno">  411 </span><span class="spaces">             </span><span class="istickedoff">&lt;$&gt; case lookupDisambIfcObj ifcId of</span>
<span class="lineno">  412 </span><span class="spaces">                   </span><span class="istickedoff">Just disambObj -&gt; typecheckTerm $ obj_ctx disambObj -- term is type checked twice, but otherwise we need a more complicated type check method to access already-checked interfaces. TODO: hide possible duplicate errors in a nice way (that is: via CtxError)</span>
<span class="lineno">  413 </span><span class="spaces">                   </span><span class="istickedoff">Nothing        -&gt; Errors [mkUndeclaredError &quot;interface&quot; o ifcId]</span>
<span class="lineno">  414 </span><span class="spaces">         </span><span class="istickedoff">P_Box{}</span>
<span class="lineno">  415 </span><span class="spaces">           </span><span class="istickedoff">-&gt; case si_box x of</span>
<span class="lineno">  416 </span><span class="spaces">                </span><span class="istickedoff">[]  -&gt; <span class="nottickedoff">const undefined &lt;$&gt; hasNone ([]::[P_SubIfc a]) x</span> -- error</span>
<span class="lineno">  417 </span><span class="spaces">                </span><span class="istickedoff">l   -&gt; (\lst -&gt; (objExpr,Box <span class="nottickedoff">(target objExpr)</span> <span class="nottickedoff">(si_class x)</span> lst)) &lt;$&gt; traverse (unguard . fmap (matchWith <span class="nottickedoff">(target objExpr)</span>) . typecheckObjDef) l &lt;* uniqueNames l</span>
<span class="lineno">  418 </span><span class="spaces">     </span><span class="istickedoff">where matchWith _ (ojd,exprBound)</span>
<span class="lineno">  419 </span><span class="spaces">            </span><span class="istickedoff">= if <span class="tickonlytrue">b || exprBound</span> then</span>
<span class="lineno">  420 </span><span class="spaces">              </span><span class="istickedoff">( case findExact genLattice (mIsc (name$ target objExpr) (name . source . objctx $ ojd)) of</span>
<span class="lineno">  421 </span><span class="spaces">                    </span><span class="istickedoff">[] -&gt; mustBeOrderedLst <span class="nottickedoff">x</span> <span class="nottickedoff">[(source (objctx ojd),Src, ojd)]</span></span>
<span class="lineno">  422 </span><span class="spaces">                    </span><span class="istickedoff">(r:_) -&gt; pure (ojd{objctx=addEpsilonLeft' r (objctx ojd)})</span>
<span class="lineno">  423 </span><span class="spaces">              </span><span class="istickedoff">)</span>
<span class="lineno">  424 </span><span class="spaces">              </span><span class="istickedoff">else <span class="nottickedoff">mustBeBound (origin ojd) [(Src,objctx ojd),(Tgt,objExpr)]</span></span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="istickedoff">typeCheckInterfaceRef :: P_ObjDef a -&gt; String -&gt; Expression -&gt; Expression -&gt; Guarded Expression</span>
<span class="lineno">  426 </span><span class="spaces">    </span><span class="istickedoff">typeCheckInterfaceRef objDef ifcRef objExpr ifcExpr = </span>
<span class="lineno">  427 </span><span class="spaces">      </span><span class="istickedoff">let expTarget = target objExpr</span>
<span class="lineno">  428 </span><span class="spaces">          </span><span class="istickedoff">expTargetStr = name expTarget</span>
<span class="lineno">  429 </span><span class="spaces">          </span><span class="istickedoff">ifcSource = source ifcExpr</span>
<span class="lineno">  430 </span><span class="spaces">          </span><span class="istickedoff">ifcSourceStr = name ifcSource</span>
<span class="lineno">  431 </span><span class="spaces">          </span><span class="istickedoff">refIsCompatible = expTargetStr `isa` ifcSourceStr || ifcSourceStr `isa` expTargetStr</span>
<span class="lineno">  432 </span><span class="spaces">      </span><span class="istickedoff">in  if refIsCompatible </span>
<span class="lineno">  433 </span><span class="spaces">          </span><span class="istickedoff">then pure $ addEpsilonRight' ifcSourceStr objExpr </span>
<span class="lineno">  434 </span><span class="spaces">          </span><span class="istickedoff">else Errors [<span class="nottickedoff">mkIncompatibleInterfaceError objDef expTarget ifcSource ifcRef</span> ]</span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="istickedoff">lookupDisambIfcObj :: String -&gt; Maybe (P_ObjDef (TermPrim, DisambPrim))</span>
<span class="lineno">  436 </span><span class="spaces">    </span><span class="istickedoff">lookupDisambIfcObj ifcId =</span>
<span class="lineno">  437 </span><span class="spaces">      </span><span class="istickedoff">case [ disambObj | (vd,disambObj) &lt;- p_interfaceAndDisambObjs, ifc_Name vd == ifcId ] of</span>
<span class="lineno">  438 </span><span class="spaces">        </span><span class="istickedoff">[]          -&gt; Nothing</span>
<span class="lineno">  439 </span><span class="spaces">        </span><span class="istickedoff">disambObj:_ -&gt; Just disambObj -- return the first one, if there are more, this is caught later on by uniqueness static check</span>
<span class="lineno">  440 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  441 </span><span class="spaces">    </span><span class="istickedoff">typecheckTerm :: Term (TermPrim, DisambPrim) -&gt; Guarded (Expression, (Bool, Bool))</span>
<span class="lineno">  442 </span><span class="spaces">    </span><span class="istickedoff">typecheckTerm tct</span>
<span class="lineno">  443 </span><span class="spaces">     </span><span class="istickedoff">= case tct of</span>
<span class="lineno">  444 </span><span class="spaces">         </span><span class="istickedoff">Prim (t,v) -&gt; (\x -&gt; (x, case t of</span>
<span class="lineno">  445 </span><span class="spaces">                                   </span><span class="istickedoff">PVee _ -&gt; (False,False)</span>
<span class="lineno">  446 </span><span class="spaces">                                   </span><span class="istickedoff">_      -&gt; (True,True)</span>
<span class="lineno">  447 </span><span class="spaces">                                   </span><span class="istickedoff">)) &lt;$&gt; pDisAmb2Expr (t,v)</span>
<span class="lineno">  448 </span><span class="spaces">         </span><span class="istickedoff">PEqu _ a b -&gt; unguard $ binary  (.==.) (MBE (Src,fst) (Src,snd), MBE (Tgt,fst) (Tgt,snd)) &lt;$&gt; tt a &lt;*&gt; tt b</span>
<span class="lineno">  449 </span><span class="spaces">         </span><span class="istickedoff">PImp _ a b -&gt; unguard $ binary  (.|-.) (MBG (Src,snd) (Src,fst), MBG (Tgt,snd) (Tgt,fst)) &lt;$&gt; tt a &lt;*&gt; tt b</span>
<span class="lineno">  450 </span><span class="spaces">         </span><span class="istickedoff">PIsc _ a b -&gt; unguard $ binary  (./\.) (ISC (Src,fst) (Src,snd), ISC (Tgt,fst) (Tgt,snd)) &lt;$&gt; tt a &lt;*&gt; tt b</span>
<span class="lineno">  451 </span><span class="spaces">         </span><span class="istickedoff">PUni _ a b -&gt; unguard $ binary  (.\/.) (UNI (Src,fst) (Src,snd), UNI (Tgt,fst) (Tgt,snd)) &lt;$&gt; tt a &lt;*&gt; tt b</span>
<span class="lineno">  452 </span><span class="spaces">         </span><span class="istickedoff">PDif _ a b -&gt; unguard $ binary  (.-.)  (MBG (Src,fst) (Src,snd), MBG (Tgt,fst) (Tgt,snd)) &lt;$&gt; tt a &lt;*&gt; tt b</span>
<span class="lineno">  453 </span><span class="spaces">         </span><span class="istickedoff">PLrs _ a b -&gt; unguard $ binary' (./.)  (MBG (Tgt,snd) (Tgt,fst)) ((Src,fst),(Src,snd)) Tgt Tgt &lt;$&gt; tt a &lt;*&gt; tt b</span>
<span class="lineno">  454 </span><span class="spaces">         </span><span class="istickedoff">PRrs _ a b -&gt; unguard $ binary' (.\.)  (MBG (Src,fst) (Src,snd)) ((Tgt,fst),(Tgt,snd)) Src Src &lt;$&gt; tt a &lt;*&gt; tt b</span>
<span class="lineno">  455 </span><span class="spaces">         </span><span class="istickedoff">PDia _ a b -&gt; <span class="nottickedoff">unguard $ binary' (.&lt;&gt;.) (ISC (Tgt,fst) (Src,snd)) ((Src,fst),(Tgt,snd)) Tgt Src &lt;$&gt; tt a &lt;*&gt; tt b</span> -- MBE would have been correct, but too restrictive</span>
<span class="lineno">  456 </span><span class="spaces">         </span><span class="istickedoff">PCps _ a b -&gt; unguard $ binary' (.:.)  (ISC (Tgt,fst) (Src,snd)) ((Src,fst),(Tgt,snd)) Tgt Src &lt;$&gt; tt a &lt;*&gt; tt b</span>
<span class="lineno">  457 </span><span class="spaces">         </span><span class="istickedoff">PRad _ a b -&gt; unguard $ binary' (.!.)  (MBE (Tgt,fst) (Src,snd)) ((Src,fst),(Tgt,snd)) Tgt Src &lt;$&gt; tt a &lt;*&gt; tt b -- Using MBE instead of ISC allows the programmer to use De Morgan</span>
<span class="lineno">  458 </span><span class="spaces">         </span><span class="istickedoff">PPrd _ a b -&gt; (\(x,(s,_)) (y,(_,t)) -&gt; (x .*. y, (<span class="nottickedoff">s</span>,t))) &lt;$&gt; tt a &lt;*&gt; tt b</span>
<span class="lineno">  459 </span><span class="spaces">         </span><span class="istickedoff">PKl0 _ a   -&gt; unguard $ unary   EKl0   (UNI (Src, id) (Tgt, id), UNI (Src, id) (Tgt, id)) &lt;$&gt; tt a</span>
<span class="lineno">  460 </span><span class="spaces">         </span><span class="istickedoff">PKl1 _ a   -&gt; unguard $ unary   EKl1   (UNI (Src, id) (Tgt, id), UNI (Src, id) (Tgt, id)) &lt;$&gt; tt a</span>
<span class="lineno">  461 </span><span class="spaces">         </span><span class="istickedoff">PFlp _ a   -&gt; (\(x,(s,t)) -&gt; ((EFlp x), (t,s))) &lt;$&gt; tt a</span>
<span class="lineno">  462 </span><span class="spaces">         </span><span class="istickedoff">PCpl _ a   -&gt; (\(x,_) -&gt; (ECpl x,(False,False))) &lt;$&gt; tt a</span>
<span class="lineno">  463 </span><span class="spaces">         </span><span class="istickedoff">PBrk _ e   -&gt; (\(x,t) -&gt; (EBrk x,t)) &lt;$&gt; tt e </span>
<span class="lineno">  464 </span><span class="spaces">     </span><span class="istickedoff">where</span>
<span class="lineno">  465 </span><span class="spaces">      </span><span class="istickedoff">o = origin (fmap <span class="nottickedoff">fst</span> tct)</span>
<span class="lineno">  466 </span><span class="spaces">      </span><span class="istickedoff">tt = typecheckTerm</span>
<span class="lineno">  467 </span><span class="spaces">      </span><span class="istickedoff">-- SJC: Here is what binary, binary' and unary do:</span>
<span class="lineno">  468 </span><span class="spaces">      </span><span class="istickedoff">-- (1) Create an expression, the combinator for this is given by its first argument</span>
<span class="lineno">  469 </span><span class="spaces">      </span><span class="istickedoff">-- (2) Fill in the corresponding type-checked terms to that expression</span>
<span class="lineno">  470 </span><span class="spaces">      </span><span class="istickedoff">-- (3) For binary' only: fill in the intermediate concept too</span>
<span class="lineno">  471 </span><span class="spaces">      </span><span class="istickedoff">-- (4) Fill in the type of the new expression</span>
<span class="lineno">  472 </span><span class="spaces">      </span><span class="istickedoff">-- For steps (3) and (4), you can use the `TT' data type to specify the new type, and what checks should occur:</span>
<span class="lineno">  473 </span><span class="spaces">      </span><span class="istickedoff">-- If you don't know what to use, try MBE: it is the strictest form.</span>
<span class="lineno">  474 </span><span class="spaces">      </span><span class="istickedoff">-- In the steps (3) and (4), different type errors may arise:</span>
<span class="lineno">  475 </span><span class="spaces">      </span><span class="istickedoff">-- If the type does not exist, this yields a type error.</span>
<span class="lineno">  476 </span><span class="spaces">      </span><span class="istickedoff">-- Some types may be generalized, while others may not.</span>
<span class="lineno">  477 </span><span class="spaces">      </span><span class="istickedoff">-- When a type may be generalized, that means that the value of the expression does not change if the type becomes larger</span>
<span class="lineno">  478 </span><span class="spaces">      </span><span class="istickedoff">-- When a type may not be generalized:</span>
<span class="lineno">  479 </span><span class="spaces">      </span><span class="istickedoff">--   the type so far is actually just an estimate</span>
<span class="lineno">  480 </span><span class="spaces">      </span><span class="istickedoff">--   it must be bound by the context to something smaller, or something as big</span>
<span class="lineno">  481 </span><span class="spaces">      </span><span class="istickedoff">--   a way to do this, is by using (V[type] /\ thingToBeBound)</span>
<span class="lineno">  482 </span><span class="spaces">      </span><span class="istickedoff">-- More details about generalizable types can be found by looking at &quot;deriv1&quot;.</span>
<span class="lineno">  483 </span><span class="spaces">      </span><span class="istickedoff">binary :: (Expression -&gt; Expression-&gt;Expression) -- combinator</span>
<span class="lineno">  484 </span><span class="spaces">             </span><span class="istickedoff">-&gt; ( TT ( SrcOrTgt</span>
<span class="lineno">  485 </span><span class="spaces">                     </span><span class="istickedoff">, ( (Expression, (Bool, Bool))</span>
<span class="lineno">  486 </span><span class="spaces">                       </span><span class="istickedoff">, (Expression, (Bool, Bool))</span>
<span class="lineno">  487 </span><span class="spaces">                       </span><span class="istickedoff">) -&gt; (Expression, (Bool, Bool))</span>
<span class="lineno">  488 </span><span class="spaces">                     </span><span class="istickedoff">)</span>
<span class="lineno">  489 </span><span class="spaces">                </span><span class="istickedoff">, TT ( SrcOrTgt</span>
<span class="lineno">  490 </span><span class="spaces">                     </span><span class="istickedoff">, ( (Expression, (Bool, Bool))</span>
<span class="lineno">  491 </span><span class="spaces">                       </span><span class="istickedoff">, (Expression, (Bool, Bool))</span>
<span class="lineno">  492 </span><span class="spaces">                       </span><span class="istickedoff">) -&gt; (Expression, (Bool, Bool))</span>
<span class="lineno">  493 </span><span class="spaces">                     </span><span class="istickedoff">)</span>
<span class="lineno">  494 </span><span class="spaces">                </span><span class="istickedoff">) -- simple instruction on how to derive the type</span>
<span class="lineno">  495 </span><span class="spaces">             </span><span class="istickedoff">-&gt; (Expression,(Bool,Bool))</span>
<span class="lineno">  496 </span><span class="spaces">             </span><span class="istickedoff">-&gt; (Expression,(Bool,Bool)) -- expressions to feed into the combinator after translation</span>
<span class="lineno">  497 </span><span class="spaces">             </span><span class="istickedoff">-&gt; Guarded (Expression,(Bool,Bool))</span>
<span class="lineno">  498 </span><span class="spaces">      </span><span class="istickedoff">binary  cbn     tp  e1 e2 = wrap (fst e1,fst e2) &lt;$&gt; deriv tp (e1,e2)</span>
<span class="lineno">  499 </span><span class="spaces">        </span><span class="istickedoff">where</span>
<span class="lineno">  500 </span><span class="spaces">         </span><span class="istickedoff">wrap (expr1,expr2) ((src,b1), (tgt,b2)) = (cbn (addEpsilon src tgt expr1) (addEpsilon src tgt expr2), (b1, b2))</span>
<span class="lineno">  501 </span><span class="spaces">      </span><span class="istickedoff">unary   cbn     tp e1      = wrap (fst e1) &lt;$&gt; deriv tp e1</span>
<span class="lineno">  502 </span><span class="spaces">        </span><span class="istickedoff">where</span>
<span class="lineno">  503 </span><span class="spaces">         </span><span class="istickedoff">wrap expr  ((src,b1), (tgt,b2))  = (cbn (addEpsilon src tgt expr), (b1, b2))</span>
<span class="lineno">  504 </span><span class="spaces">      </span><span class="istickedoff">binary' cbn preConcept tp side1 side2 e1 e2 = wrap (fst e1,fst e2) &lt;$&gt; deriv1 o (fmap (resolve (e1,e2)) preConcept) &lt;*&gt; deriv' tp (e1,e2)</span>
<span class="lineno">  505 </span><span class="spaces">        </span><span class="istickedoff">where</span>
<span class="lineno">  506 </span><span class="spaces">         </span><span class="istickedoff">wrap (expr1,expr2) (cpt,_) ((_,b1), (_,b2))</span>
<span class="lineno">  507 </span><span class="spaces">          </span><span class="istickedoff">= (cbn (lrDecide side1 expr1) (lrDecide side2 expr2), (b1, b2))</span>
<span class="lineno">  508 </span><span class="spaces">            </span><span class="istickedoff">where lrDecide side e = case side of Src -&gt; addEpsilonLeft' cpt e; Tgt -&gt; addEpsilonRight' cpt e</span>
<span class="lineno">  509 </span><span class="spaces">      </span><span class="istickedoff">deriv (t1,t2) es = (,) &lt;$&gt; deriv1 o (fmap (resolve es) t1) &lt;*&gt; deriv1 <span class="nottickedoff">o</span> (fmap (resolve es) t2)</span>
<span class="lineno">  510 </span><span class="spaces"> </span><span class="istickedoff"></span>
<span class="lineno">  511 </span><span class="spaces">    </span><span class="istickedoff">deriv1 o x'</span>
<span class="lineno">  512 </span><span class="spaces">     </span><span class="istickedoff">= case x' of</span>
<span class="lineno">  513 </span><span class="spaces">        </span><span class="istickedoff">(MBE a@(p1,(e1,b1)) b@(p2,(e2,b2))) -&gt;</span>
<span class="lineno">  514 </span><span class="spaces">             </span><span class="istickedoff">if <span class="tickonlytrue">(b1 &amp;&amp; b2) || (getConcept p1 e1 == getConcept p2 e2)</span> then (\x -&gt; (x,<span class="nottickedoff">b1||b2</span>)) &lt;$&gt; getExactType mjoin (p1, e1) (p2, e2)</span>
<span class="lineno">  515 </span><span class="spaces">             </span><span class="istickedoff">else <span class="nottickedoff">mustBeBound o [(p,e) | (p,(e,False))&lt;-[a,b]]</span></span>
<span class="lineno">  516 </span><span class="spaces">        </span><span class="istickedoff">(MBG (p1,(e1,b1)) (p2,(e2,b2))) -&gt;</span>
<span class="lineno">  517 </span><span class="spaces">             </span><span class="istickedoff">(\x -&gt; (x,b1)) &lt;$&gt; getAndCheckType mjoin (p1, True, e1) (p2, b2, e2)</span>
<span class="lineno">  518 </span><span class="spaces">        </span><span class="istickedoff">(UNI (p1,(e1,b1)) (p2,(e2,b2))) -&gt;</span>
<span class="lineno">  519 </span><span class="spaces">             </span><span class="istickedoff">(\x -&gt; (x,b1 &amp;&amp; b2)) &lt;$&gt; getAndCheckType mjoin (p1, b1, e1) (p2, b2, e2)</span>
<span class="lineno">  520 </span><span class="spaces">        </span><span class="istickedoff">(ISC (p1,(e1,b1)) (p2,(e2,b2))) -&gt;</span>
<span class="lineno">  521 </span><span class="spaces">             </span><span class="istickedoff">(\x -&gt; (x,b1 || b2)) &lt;$&gt; getAndCheckType mIsc  (p1, b1, e1) (p2, b2, e2)</span>
<span class="lineno">  522 </span><span class="spaces">     </span><span class="istickedoff">where</span>
<span class="lineno">  523 </span><span class="spaces">      </span><span class="istickedoff">getExactType flf (p1,e1) (p2,e2)</span>
<span class="lineno">  524 </span><span class="spaces">       </span><span class="istickedoff">= case findExact genLattice (flf (getConcept p1 e1) (getConcept p2 e2)) of</span>
<span class="lineno">  525 </span><span class="spaces">          </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">mustBeOrdered o (p1,e1) (p2,e2)</span></span>
<span class="lineno">  526 </span><span class="spaces">          </span><span class="istickedoff">r  -&gt; pure$ head r</span>
<span class="lineno">  527 </span><span class="spaces">      </span><span class="istickedoff">getAndCheckType flf (p1,b1,e1) (p2,b2,e2)</span>
<span class="lineno">  528 </span><span class="spaces">       </span><span class="istickedoff">= case findSubsets genLattice (flf (getConcept p1 e1) (getConcept p2 e2)) of -- note: we could have used GetOneGuarded, but this is more specific</span>
<span class="lineno">  529 </span><span class="spaces">          </span><span class="istickedoff">[]  -&gt; mustBeOrdered o (p1,e1) (p2,e2)</span>
<span class="lineno">  530 </span><span class="spaces">          </span><span class="istickedoff">[r] -&gt; case (b1 || Set.member (getConcept p1 e1) r,b2 || Set.member (getConcept p2 e2) r ) of</span>
<span class="lineno">  531 </span><span class="spaces">                   </span><span class="istickedoff">(True,True) -&gt; pure (head (Set.toList r))</span>
<span class="lineno">  532 </span><span class="spaces">                   </span><span class="istickedoff">(a,b) -&gt; mustBeBound <span class="nottickedoff">o</span> [(<span class="nottickedoff">p</span>,<span class="nottickedoff">e</span>) | (False,p,e)&lt;-[(a,<span class="nottickedoff">p1</span>,<span class="nottickedoff">e1</span>),(b,<span class="nottickedoff">p2</span>,<span class="nottickedoff">e2</span>)]]</span>
<span class="lineno">  533 </span><span class="spaces">          </span><span class="istickedoff">lst -&gt; mustBeOrderedConcLst <span class="nottickedoff">o</span> (<span class="nottickedoff">p1</span>,<span class="nottickedoff">e1</span>) (<span class="nottickedoff">p2</span>,<span class="nottickedoff">e2</span>) <span class="nottickedoff">(map (map castConcept . Set.toList) lst)</span></span>
<span class="lineno">  534 </span><span class="spaces">    </span><span class="istickedoff">termPrimDisAmb :: TermPrim -&gt; (TermPrim, DisambPrim)</span>
<span class="lineno">  535 </span><span class="spaces">    </span><span class="istickedoff">termPrimDisAmb x</span>
<span class="lineno">  536 </span><span class="spaces">     </span><span class="istickedoff">= (x, case x of</span>
<span class="lineno">  537 </span><span class="spaces">           </span><span class="istickedoff">PI _        -&gt; Ident</span>
<span class="lineno">  538 </span><span class="spaces">           </span><span class="istickedoff">Pid _ conspt-&gt; Known (EDcI (pCpt2aCpt conspt))</span>
<span class="lineno">  539 </span><span class="spaces">           </span><span class="istickedoff">Patm _ s Nothing -&gt; Mp1 s</span>
<span class="lineno">  540 </span><span class="spaces">           </span><span class="istickedoff">Patm _ s (Just conspt) -&gt; Known (EMp1 s (pCpt2aCpt conspt))</span>
<span class="lineno">  541 </span><span class="spaces">           </span><span class="istickedoff">PVee _      -&gt; Vee</span>
<span class="lineno">  542 </span><span class="spaces">           </span><span class="istickedoff">Pfull _ a b -&gt; Known (EDcV (Sign (pCpt2aCpt a) (pCpt2aCpt b)))</span>
<span class="lineno">  543 </span><span class="spaces">           </span><span class="istickedoff">PNamedR nr -&gt; Rel $ disambNamedRel nr</span>
<span class="lineno">  544 </span><span class="spaces">        </span><span class="istickedoff">)</span>
<span class="lineno">  545 </span><span class="spaces">    </span><span class="istickedoff">disambNamedRel (PNamedRel _ r Nothing)  = [EDcD dc | dc &lt;- (Map.elems $ findDecls r)]</span>
<span class="lineno">  546 </span><span class="spaces">    </span><span class="istickedoff">disambNamedRel (PNamedRel _ r (Just s)) = [EDcD dc | dc &lt;- (findDeclsTyped r (pSign2aSign s))]</span>
<span class="lineno">  547 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  548 </span><span class="spaces">    </span><span class="istickedoff">namedRel2Decl :: P_NamedRel -&gt; Guarded Declaration</span>
<span class="lineno">  549 </span><span class="spaces">    </span><span class="istickedoff">namedRel2Decl o@(PNamedRel _ r Nothing)  = getOneExactly o [ dc | dc &lt;- (Map.elems $ findDecls r)]</span>
<span class="lineno">  550 </span><span class="spaces">    </span><span class="istickedoff">namedRel2Decl o@(PNamedRel _ r (Just s)) = getOneExactly <span class="nottickedoff">o</span> [ dc | dc &lt;- (findDeclsTyped r (pSign2aSign s))]</span>
<span class="lineno">  551 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  552 </span><span class="spaces">    </span><span class="istickedoff">pIfc2aIfc :: (P_Interface, P_ObjDef (TermPrim, DisambPrim)) -&gt; Guarded Interface</span>
<span class="lineno">  553 </span><span class="spaces">    </span><span class="istickedoff">pIfc2aIfc (P_Ifc { ifc_Params = tps</span>
<span class="lineno">  554 </span><span class="spaces">                    </span><span class="istickedoff">, ifc_Class = iclass</span>
<span class="lineno">  555 </span><span class="spaces">                    </span><span class="istickedoff">, ifc_Args = args</span>
<span class="lineno">  556 </span><span class="spaces">                    </span><span class="istickedoff">, ifc_Roles = rols</span>
<span class="lineno">  557 </span><span class="spaces">                    </span><span class="istickedoff">, ifc_Obj = _</span>
<span class="lineno">  558 </span><span class="spaces">                    </span><span class="istickedoff">, ifc_Pos = orig</span>
<span class="lineno">  559 </span><span class="spaces">                    </span><span class="istickedoff">-- , ifc_Name = nm</span>
<span class="lineno">  560 </span><span class="spaces">                    </span><span class="istickedoff">, ifc_Prp = prp</span>
<span class="lineno">  561 </span><span class="spaces">                    </span><span class="istickedoff">}, objDisamb)</span>
<span class="lineno">  562 </span><span class="spaces">        </span><span class="istickedoff">= (\ tps' obj'</span>
<span class="lineno">  563 </span><span class="spaces">             </span><span class="istickedoff">-&gt; Ifc { ifcParams = tps'</span>
<span class="lineno">  564 </span><span class="spaces">                    </span><span class="istickedoff">, ifcClass = <span class="nottickedoff">iclass</span></span>
<span class="lineno">  565 </span><span class="spaces">                    </span><span class="istickedoff">, ifcArgs = <span class="nottickedoff">args</span></span>
<span class="lineno">  566 </span><span class="spaces">                    </span><span class="istickedoff">, ifcRoles = <span class="nottickedoff">rols</span></span>
<span class="lineno">  567 </span><span class="spaces">                    </span><span class="istickedoff">, ifcObj = obj'</span>
<span class="lineno">  568 </span><span class="spaces">                    </span><span class="istickedoff">, ifcEcas = <span class="nottickedoff">[]</span>      -- to be enriched in Adl2fSpec with ECA-rules</span>
<span class="lineno">  569 </span><span class="spaces">                    </span><span class="istickedoff">, ifcControls = <span class="nottickedoff">[]</span>  -- to be enriched in Adl2fSpec with rules to be checked</span>
<span class="lineno">  570 </span><span class="spaces">                    </span><span class="istickedoff">, ifcPos = <span class="nottickedoff">orig</span></span>
<span class="lineno">  571 </span><span class="spaces">                    </span><span class="istickedoff">, ifcPrp = <span class="nottickedoff">prp</span></span>
<span class="lineno">  572 </span><span class="spaces">                    </span><span class="istickedoff">}) &lt;$&gt; traverse namedRel2Decl tps</span>
<span class="lineno">  573 </span><span class="spaces">                       </span><span class="istickedoff">&lt;*&gt; pObjDefDisamb2aObjDef objDisamb</span>
<span class="lineno">  574 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  575 </span><span class="spaces">    </span><span class="istickedoff">pRoleRelation2aRoleRelation :: P_RoleRelation -&gt; Guarded A_RoleRelation</span>
<span class="lineno">  576 </span><span class="spaces">    </span><span class="istickedoff">pRoleRelation2aRoleRelation prr</span>
<span class="lineno">  577 </span><span class="spaces">     </span><span class="istickedoff">= <span class="nottickedoff">(\ ds' </span></span>
<span class="lineno">  578 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-&gt; RR { rrRoles = rr_Roles prr</span></span>
<span class="lineno">  579 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, rrRels  = ds'</span></span>
<span class="lineno">  580 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, rrPos   = rr_Pos prr</span></span>
<span class="lineno">  581 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">})</span> &lt;$&gt; traverse namedRel2Decl (rr_Rels prr)</span>
<span class="lineno">  582 </span><span class="spaces">    </span><span class="istickedoff">pRoleRule2aRoleRule :: P_RoleRule -&gt; A_RoleRule</span>
<span class="lineno">  583 </span><span class="spaces">    </span><span class="istickedoff">pRoleRule2aRoleRule prr</span>
<span class="lineno">  584 </span><span class="spaces">     </span><span class="istickedoff">= A_RoleRule { arRoles = <span class="nottickedoff">mRoles prr</span></span>
<span class="lineno">  585 </span><span class="spaces">                  </span><span class="istickedoff">, arRules = mRules prr</span>
<span class="lineno">  586 </span><span class="spaces">                  </span><span class="istickedoff">, arPos   = mPos prr</span>
<span class="lineno">  587 </span><span class="spaces">                  </span><span class="istickedoff">}</span>
<span class="lineno">  588 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  589 </span><span class="spaces">    </span><span class="istickedoff">pPat2aPat :: P_Pattern -&gt; Guarded Pattern</span>
<span class="lineno">  590 </span><span class="spaces">    </span><span class="istickedoff">pPat2aPat ppat</span>
<span class="lineno">  591 </span><span class="spaces">     </span><span class="istickedoff">= f &lt;$&gt; traverse (pRul2aRul <span class="nottickedoff">(name ppat)</span>) (pt_rls ppat)</span>
<span class="lineno">  592 </span><span class="spaces">         </span><span class="istickedoff">&lt;*&gt; traverse pIdentity2aIdentity (pt_ids ppat) </span>
<span class="lineno">  593 </span><span class="spaces">         </span><span class="istickedoff">&lt;*&gt; traverse pPop2aPop (pt_pop ppat)</span>
<span class="lineno">  594 </span><span class="spaces">         </span><span class="istickedoff">&lt;*&gt; traverse pViewDef2aViewDef (pt_vds ppat) </span>
<span class="lineno">  595 </span><span class="spaces">         </span><span class="istickedoff">&lt;*&gt; traverse pPurp2aPurp (pt_xps ppat)</span>
<span class="lineno">  596 </span><span class="spaces">       </span><span class="istickedoff">where</span>
<span class="lineno">  597 </span><span class="spaces">        </span><span class="istickedoff">f rules' keys' pops' views' xpls</span>
<span class="lineno">  598 </span><span class="spaces">           </span><span class="istickedoff">= let (decls',dPops) = unzip [ pDecl2aDecl <span class="nottickedoff">(name ppat)</span> <span class="nottickedoff">deflangCtxt</span> <span class="nottickedoff">deffrmtCtxt</span> pDecl | pDecl&lt;-pt_dcs ppat ]</span>
<span class="lineno">  599 </span><span class="spaces">             </span><span class="istickedoff">in A_Pat { ptnm  = name ppat</span>
<span class="lineno">  600 </span><span class="spaces">                      </span><span class="istickedoff">, ptpos = pt_pos ppat</span>
<span class="lineno">  601 </span><span class="spaces">                      </span><span class="istickedoff">, ptend = <span class="nottickedoff">pt_end ppat</span></span>
<span class="lineno">  602 </span><span class="spaces">                      </span><span class="istickedoff">, ptrls = rules'</span>
<span class="lineno">  603 </span><span class="spaces">                      </span><span class="istickedoff">, ptgns = <span class="nottickedoff">map pGen2aGen (pt_gns ppat)</span></span>
<span class="lineno">  604 </span><span class="spaces">                      </span><span class="istickedoff">, ptdcs = decls'</span>
<span class="lineno">  605 </span><span class="spaces">                      </span><span class="istickedoff">, ptups = <span class="nottickedoff">pops' ++ [ dp | dp@PRelPopu{}&lt;-dPops, (not.null.popps) dp ] ++ [ cp | cp@PCptPopu{}&lt;-dPops, (not.null.popas) cp ]</span></span>
<span class="lineno">  606 </span><span class="spaces">                      </span><span class="istickedoff">, ptids = keys'</span>
<span class="lineno">  607 </span><span class="spaces">                      </span><span class="istickedoff">, ptvds = views'</span>
<span class="lineno">  608 </span><span class="spaces">                      </span><span class="istickedoff">, ptxps = xpls</span>
<span class="lineno">  609 </span><span class="spaces">                      </span><span class="istickedoff">}</span>
<span class="lineno">  610 </span><span class="spaces">    </span><span class="istickedoff">pRul2aRul :: String -- environment name (pattern / proc name)</span>
<span class="lineno">  611 </span><span class="spaces">              </span><span class="istickedoff">-&gt; (P_Rule TermPrim) -&gt; Guarded Rule</span>
<span class="lineno">  612 </span><span class="spaces">    </span><span class="istickedoff">pRul2aRul env = typeCheckRul <span class="nottickedoff">env</span> . disambiguate termPrimDisAmb</span>
<span class="lineno">  613 </span><span class="spaces">    </span><span class="istickedoff">typeCheckRul :: </span>
<span class="lineno">  614 </span><span class="spaces">                 </span><span class="istickedoff">String -- environment name (pattern / proc name)</span>
<span class="lineno">  615 </span><span class="spaces">              </span><span class="istickedoff">-&gt; (P_Rule (TermPrim, DisambPrim)) -&gt; Guarded Rule</span>
<span class="lineno">  616 </span><span class="spaces">    </span><span class="istickedoff">typeCheckRul env P_Ru { rr_fps = orig</span>
<span class="lineno">  617 </span><span class="spaces">                          </span><span class="istickedoff">, rr_nm = nm</span>
<span class="lineno">  618 </span><span class="spaces">                          </span><span class="istickedoff">, rr_exp = expr</span>
<span class="lineno">  619 </span><span class="spaces">                          </span><span class="istickedoff">, rr_mean = meanings</span>
<span class="lineno">  620 </span><span class="spaces">                          </span><span class="istickedoff">, rr_msg = msgs</span>
<span class="lineno">  621 </span><span class="spaces">                          </span><span class="istickedoff">, rr_viol = viols</span>
<span class="lineno">  622 </span><span class="spaces">                          </span><span class="istickedoff">}</span>
<span class="lineno">  623 </span><span class="spaces">     </span><span class="istickedoff">= unguard $ </span>
<span class="lineno">  624 </span><span class="spaces">         </span><span class="istickedoff">(\ (exp',_) -&gt; </span>
<span class="lineno">  625 </span><span class="spaces">           </span><span class="istickedoff">(\ vls -&gt;</span>
<span class="lineno">  626 </span><span class="spaces">             </span><span class="istickedoff">Ru { rrnm = nm</span>
<span class="lineno">  627 </span><span class="spaces">                </span><span class="istickedoff">, rrexp = exp'</span>
<span class="lineno">  628 </span><span class="spaces">                </span><span class="istickedoff">, rrfps = <span class="nottickedoff">orig</span></span>
<span class="lineno">  629 </span><span class="spaces">                </span><span class="istickedoff">, rrmean = <span class="nottickedoff">pMean2aMean deflangCtxt deffrmtCtxt meanings</span></span>
<span class="lineno">  630 </span><span class="spaces">                </span><span class="istickedoff">, rrmsg = <span class="nottickedoff">map (pMess2aMess deflangCtxt deffrmtCtxt) msgs</span></span>
<span class="lineno">  631 </span><span class="spaces">                </span><span class="istickedoff">, rrviol = vls</span>
<span class="lineno">  632 </span><span class="spaces">                </span><span class="istickedoff">, rrtyp = <span class="nottickedoff">sign exp'</span></span>
<span class="lineno">  633 </span><span class="spaces">                </span><span class="istickedoff">, rrdcl = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  634 </span><span class="spaces">                </span><span class="istickedoff">, r_env = <span class="nottickedoff">env</span></span>
<span class="lineno">  635 </span><span class="spaces">                </span><span class="istickedoff">, r_usr = <span class="nottickedoff">UserDefined</span></span>
<span class="lineno">  636 </span><span class="spaces">                </span><span class="istickedoff">, isSignal = <span class="nottickedoff">not . null . concatMap arRoles . filter (\x -&gt; nm `elem` arRules x) $ allRoleRules</span> </span>
<span class="lineno">  637 </span><span class="spaces">                </span><span class="istickedoff">})</span>
<span class="lineno">  638 </span><span class="spaces">           </span><span class="istickedoff">&lt;$&gt; maybeOverGuarded (typeCheckPairView <span class="nottickedoff">orig</span> exp') viols)</span>
<span class="lineno">  639 </span><span class="spaces">         </span><span class="istickedoff">&lt;$&gt; typecheckTerm expr</span>
<span class="lineno">  640 </span><span class="spaces">    </span><span class="istickedoff">pIdentity2aIdentity :: P_IdentDef -&gt; Guarded IdentityDef</span>
<span class="lineno">  641 </span><span class="spaces">    </span><span class="istickedoff">pIdentity2aIdentity pidt</span>
<span class="lineno">  642 </span><span class="spaces">     </span><span class="istickedoff">= case disambiguate termPrimDisAmb pidt of</span>
<span class="lineno">  643 </span><span class="spaces">           </span><span class="istickedoff">P_Id { ix_lbl = lbl</span>
<span class="lineno">  644 </span><span class="spaces">                </span><span class="istickedoff">, ix_ats = isegs</span>
<span class="lineno">  645 </span><span class="spaces">                </span><span class="istickedoff">} -&gt; (\isegs' -&gt; Id { idPos = <span class="nottickedoff">orig</span></span>
<span class="lineno">  646 </span><span class="spaces">                                    </span><span class="istickedoff">, idLbl = lbl</span>
<span class="lineno">  647 </span><span class="spaces">                                    </span><span class="istickedoff">, idCpt = <span class="nottickedoff">conc</span></span>
<span class="lineno">  648 </span><span class="spaces">                                    </span><span class="istickedoff">, identityAts = isegs'</span>
<span class="lineno">  649 </span><span class="spaces">                                    </span><span class="istickedoff">}) &lt;$&gt; traverse pIdentSegment2IdentSegment isegs</span>
<span class="lineno">  650 </span><span class="spaces">     </span><span class="istickedoff">where conc = pCpt2aCpt (ix_cpt pidt)</span>
<span class="lineno">  651 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">orig = ix_pos pidt</span></span>
<span class="lineno">  652 </span><span class="spaces">           </span><span class="istickedoff">pIdentSegment2IdentSegment :: P_IdentSegmnt (TermPrim, DisambPrim) -&gt; Guarded IdentitySegment</span>
<span class="lineno">  653 </span><span class="spaces">           </span><span class="istickedoff">pIdentSegment2IdentSegment (P_IdentExp ojd) =</span>
<span class="lineno">  654 </span><span class="spaces">              </span><span class="istickedoff">unguard $</span>
<span class="lineno">  655 </span><span class="spaces">                </span><span class="istickedoff">(\o -&gt; case findExact genLattice $ name (source $ objctx o) `mjoin` name conc of</span>
<span class="lineno">  656 </span><span class="spaces">                         </span><span class="istickedoff">[] -&gt; mustBeOrdered <span class="nottickedoff">orig</span> <span class="nottickedoff">(Src, origin ojd, objctx o)</span> <span class="nottickedoff">pidt</span></span>
<span class="lineno">  657 </span><span class="spaces">                         </span><span class="istickedoff">_  -&gt; pure $ IdentityExp o{objctx = addEpsilonLeft' (name conc) (objctx o)}</span>
<span class="lineno">  658 </span><span class="spaces">                </span><span class="istickedoff">) &lt;$&gt; pObjDefDisamb2aObjDef ojd</span>
<span class="lineno">  659 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  660 </span><span class="spaces">    </span><span class="istickedoff">typeCheckPairView :: Origin -&gt; Expression -&gt; PairView (Term (TermPrim, DisambPrim)) -&gt; Guarded (PairView Expression)</span>
<span class="lineno">  661 </span><span class="spaces">    </span><span class="istickedoff">typeCheckPairView o x (PairView lst)</span>
<span class="lineno">  662 </span><span class="spaces">     </span><span class="istickedoff">= PairView &lt;$&gt; traverse (typeCheckPairViewSeg <span class="nottickedoff">o</span> x) lst</span>
<span class="lineno">  663 </span><span class="spaces">    </span><span class="istickedoff">typeCheckPairViewSeg :: Origin -&gt; Expression -&gt; (PairViewSegment (Term (TermPrim, DisambPrim))) -&gt; Guarded (PairViewSegment Expression)</span>
<span class="lineno">  664 </span><span class="spaces">    </span><span class="istickedoff">typeCheckPairViewSeg _ _ (PairViewText orig x) = pure (PairViewText <span class="nottickedoff">orig</span> <span class="nottickedoff">x</span>)</span>
<span class="lineno">  665 </span><span class="spaces">    </span><span class="istickedoff">typeCheckPairViewSeg o t (PairViewExp orig s x)</span>
<span class="lineno">  666 </span><span class="spaces">     </span><span class="istickedoff">= unguard $</span>
<span class="lineno">  667 </span><span class="spaces">         </span><span class="istickedoff">(\(e,(b,_)) -&gt; case (findSubsets genLattice (mjoin (name (source e)) (getConcept s t))) of</span>
<span class="lineno">  668 </span><span class="spaces">                          </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">mustBeOrdered o (Src, (origin (fmap fst x)), e) (s,t)</span></span>
<span class="lineno">  669 </span><span class="spaces">                          </span><span class="istickedoff">lst -&gt; if <span class="tickonlytrue">b || and (map (name (source e) `elem`) lst)</span></span>
<span class="lineno">  670 </span><span class="spaces">                                 </span><span class="istickedoff">then pure (PairViewExp <span class="nottickedoff">orig</span> <span class="nottickedoff">s</span> e)</span>
<span class="lineno">  671 </span><span class="spaces">                                 </span><span class="istickedoff">else <span class="nottickedoff">mustBeBound (origin (fmap fst x)) [(Src, e)]</span>)</span>
<span class="lineno">  672 </span><span class="spaces">         </span><span class="istickedoff">&lt;$&gt; typecheckTerm x</span>
<span class="lineno">  673 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  674 </span><span class="spaces">    </span><span class="istickedoff">pPurp2aPurp :: PPurpose -&gt; Guarded Purpose</span>
<span class="lineno">  675 </span><span class="spaces">    </span><span class="istickedoff">pPurp2aPurp PRef2 { pexPos    = orig     -- :: Origin</span>
<span class="lineno">  676 </span><span class="spaces">                      </span><span class="istickedoff">, pexObj    = objref   -- :: PRefObj</span>
<span class="lineno">  677 </span><span class="spaces">                      </span><span class="istickedoff">, pexMarkup = pmarkup  -- :: P_Markup</span>
<span class="lineno">  678 </span><span class="spaces">                      </span><span class="istickedoff">, pexRefIDs  = refIds  -- :: [String]</span>
<span class="lineno">  679 </span><span class="spaces">                      </span><span class="istickedoff">}</span>
<span class="lineno">  680 </span><span class="spaces">     </span><span class="istickedoff">= (\ obj -&gt; Expl { explPos      = orig</span>
<span class="lineno">  681 </span><span class="spaces">                      </span><span class="istickedoff">, explObj      = obj</span>
<span class="lineno">  682 </span><span class="spaces">                      </span><span class="istickedoff">, explMarkup   = <span class="nottickedoff">pMarkup2aMarkup deflangCtxt deffrmtCtxt pmarkup</span></span>
<span class="lineno">  683 </span><span class="spaces">                      </span><span class="istickedoff">, explUserdefd = <span class="nottickedoff">True</span></span>
<span class="lineno">  684 </span><span class="spaces">                      </span><span class="istickedoff">, explRefIds   = <span class="nottickedoff">refIds</span></span>
<span class="lineno">  685 </span><span class="spaces">                      </span><span class="istickedoff">})</span>
<span class="lineno">  686 </span><span class="spaces">       </span><span class="istickedoff">&lt;$&gt; pRefObj2aRefObj objref</span>
<span class="lineno">  687 </span><span class="spaces">    </span><span class="istickedoff">pRefObj2aRefObj :: PRef2Obj -&gt; Guarded ExplObj</span>
<span class="lineno">  688 </span><span class="spaces">    </span><span class="istickedoff">pRefObj2aRefObj (PRef2ConceptDef  s ) = pure$ ExplConceptDef (lookupConceptDef s)</span>
<span class="lineno">  689 </span><span class="spaces">    </span><span class="istickedoff">pRefObj2aRefObj (PRef2Declaration tm) = ExplDeclaration &lt;$&gt; (namedRel2Decl tm)</span>
<span class="lineno">  690 </span><span class="spaces">    </span><span class="istickedoff">pRefObj2aRefObj (PRef2Rule        s ) = pure$ ExplRule s</span>
<span class="lineno">  691 </span><span class="spaces">    </span><span class="istickedoff">pRefObj2aRefObj (PRef2IdentityDef s ) = pure$ ExplIdentityDef s</span>
<span class="lineno">  692 </span><span class="spaces">    </span><span class="istickedoff">pRefObj2aRefObj (PRef2ViewDef     s ) = pure$ ExplViewDef s</span>
<span class="lineno">  693 </span><span class="spaces">    </span><span class="istickedoff">pRefObj2aRefObj (PRef2Pattern     s ) = pure$ ExplPattern s</span>
<span class="lineno">  694 </span><span class="spaces">    </span><span class="istickedoff">pRefObj2aRefObj (PRef2Interface   s ) = pure$ ExplInterface s</span>
<span class="lineno">  695 </span><span class="spaces">    </span><span class="istickedoff">pRefObj2aRefObj (PRef2Context     s ) = pure$ ExplContext s</span>
<span class="lineno">  696 </span><span class="spaces">    </span><span class="istickedoff">pRefObj2aRefObj (PRef2Fspc        s ) = <span class="nottickedoff">pure$ ExplContext s</span></span>
<span class="lineno">  697 </span><span class="spaces">    </span><span class="istickedoff">lookupConceptDef :: String -&gt; ConceptDef</span>
<span class="lineno">  698 </span><span class="spaces">    </span><span class="istickedoff">lookupConceptDef s</span>
<span class="lineno">  699 </span><span class="spaces">     </span><span class="istickedoff">= case filter (\cd -&gt; name cd == s) allConceptDefs of</span>
<span class="lineno">  700 </span><span class="spaces">        </span><span class="istickedoff">[]    -&gt; <span class="nottickedoff">Cd{cdpos=OriginUnknown, cdcpt=s, cdplug=True, cddef=&quot;&quot;, cdtyp=&quot;&quot;, cdref=&quot;&quot;, cdfrom=n1}</span> </span>
<span class="lineno">  701 </span><span class="spaces">        </span><span class="istickedoff">(x:_) -&gt; x</span>
<span class="lineno">  702 </span><span class="spaces">    </span><span class="istickedoff">allConceptDefs :: [ConceptDef]</span>
<span class="lineno">  703 </span><span class="spaces">    </span><span class="istickedoff">allConceptDefs = p_conceptdefs++concatMap pt_cds p_patterns</span>
<span class="lineno">  704 </span><span class="spaces">    </span><span class="istickedoff">allRoleRules :: [A_RoleRule]</span>
<span class="lineno">  705 </span><span class="spaces">    </span><span class="istickedoff">allRoleRules = map pRoleRule2aRoleRule </span>
<span class="lineno">  706 </span><span class="spaces">                      </span><span class="istickedoff">(p_roleRules ++ concatMap pt_RRuls p_patterns)</span></span>
<span class="lineno">  707 </span>pDisAmb2Expr :: (TermPrim, DisambPrim) -&gt; Guarded Expression
<span class="lineno">  708 </span><span class="decl"><span class="istickedoff">pDisAmb2Expr (_,Known x) = pure x</span>
<span class="lineno">  709 </span><span class="spaces"></span><span class="istickedoff">pDisAmb2Expr (_,Rel [x]) = <span class="nottickedoff">pure x</span></span>
<span class="lineno">  710 </span><span class="spaces"></span><span class="istickedoff">pDisAmb2Expr (o,Rel rs)  = cannotDisambRel o rs</span>
<span class="lineno">  711 </span><span class="spaces"></span><span class="istickedoff">pDisAmb2Expr (o,_)       = cannotDisamb o</span></span>
<span class="lineno">  712 </span>
<span class="lineno">  713 </span>pMean2aMean :: Lang           -- The default language
<span class="lineno">  714 </span>            -&gt; PandocFormat   -- The default pandocFormat
<span class="lineno">  715 </span>            -&gt; [PMeaning] -&gt; AMeaning
<span class="lineno">  716 </span><span class="decl"><span class="nottickedoff">pMean2aMean defLanguage defFormat pmeanings</span>
<span class="lineno">  717 </span><span class="spaces"> </span><span class="nottickedoff">= AMeaning [ pMarkup2aMarkup defLanguage defFormat pmarkup | PMeaning pmarkup &lt;-pmeanings ]</span></span>
<span class="lineno">  718 </span>pMess2aMess :: Lang           -- The default language
<span class="lineno">  719 </span>            -&gt; PandocFormat   -- The default pandocFormat
<span class="lineno">  720 </span>            -&gt; PMessage -&gt; A_Markup
<span class="lineno">  721 </span><span class="decl"><span class="nottickedoff">pMess2aMess defLanguage defFormat (PMessage x) = pMarkup2aMarkup defLanguage defFormat x</span></span>
<span class="lineno">  722 </span>pMarkup2aMarkup :: Lang           -- The default language
<span class="lineno">  723 </span>                -&gt; PandocFormat   -- The default pandocFormat
<span class="lineno">  724 </span>                -&gt; P_Markup -&gt; A_Markup
<span class="lineno">  725 </span><span class="decl"><span class="nottickedoff">pMarkup2aMarkup defLanguage defFormat</span>
<span class="lineno">  726 </span><span class="spaces">   </span><span class="nottickedoff">P_Markup  { mLang   = ml</span>
<span class="lineno">  727 </span><span class="spaces">             </span><span class="nottickedoff">, mFormat = mpdf</span>
<span class="lineno">  728 </span><span class="spaces">             </span><span class="nottickedoff">, mString = str</span>
<span class="lineno">  729 </span><span class="spaces">             </span><span class="nottickedoff">}</span>
<span class="lineno">  730 </span><span class="spaces"> </span><span class="nottickedoff">= A_Markup { amLang = fromMaybe defLanguage ml -- The language is always defined; if not by the user, then by default.</span>
<span class="lineno">  731 </span><span class="spaces">            </span><span class="nottickedoff">, amFormat = fmt</span>
<span class="lineno">  732 </span><span class="spaces">            </span><span class="nottickedoff">, amPandoc = string2Blocks fmt str</span>
<span class="lineno">  733 </span><span class="spaces">            </span><span class="nottickedoff">}</span>
<span class="lineno">  734 </span><span class="spaces">     </span><span class="nottickedoff">where</span>
<span class="lineno">  735 </span><span class="spaces">       </span><span class="nottickedoff">fmt = fromMaybe defFormat mpdf</span></span>           -- The pandoc format is always defined; if not by the user, then by default.
<span class="lineno">  736 </span>
<span class="lineno">  737 </span>-- helpers for generating a lattice, not having to write `Atom' all the time
<span class="lineno">  738 </span>-- TODO: Names are inconsistent: maybe call these either mUnion &amp; mIsc or mJoin &amp; mMeet? Or even lJoin and lMeet to denote the lattice.
<span class="lineno">  739 </span>mjoin,mIsc :: a -&gt; a -&gt; FreeLattice a
<span class="lineno">  740 </span><span class="decl"><span class="istickedoff">mjoin a b = Join (Atom a) (Atom b)</span></span>
<span class="lineno">  741 </span><span class="decl"><span class="istickedoff">mIsc  a b = Meet (Atom a) (Atom b)</span></span>
<span class="lineno">  742 </span>-- intended for finding the right expression on terms like (Src,fst)
<span class="lineno">  743 </span>resolve :: t -&gt; (SrcOrTgt, t -&gt; (t1, (t2, t2))) -&gt; (SrcOrTgt, (t1, t2))
<span class="lineno">  744 </span><span class="decl"><span class="istickedoff">resolve es (p,f)</span>
<span class="lineno">  745 </span><span class="spaces"> </span><span class="istickedoff">= case (p,f es) of</span>
<span class="lineno">  746 </span><span class="spaces">  </span><span class="istickedoff">(Src,(e,(b,_))) -&gt; (Src,(e,b))</span>
<span class="lineno">  747 </span><span class="spaces">  </span><span class="istickedoff">(Tgt,(e,(_,b))) -&gt; (Tgt,(e,b))</span></span>
<span class="lineno">  748 </span>
<span class="lineno">  749 </span>maybeOverGuarded :: Applicative f =&gt; (t -&gt; f a) -&gt; Maybe t -&gt; f (Maybe a)
<span class="lineno">  750 </span><span class="decl"><span class="istickedoff">maybeOverGuarded _ Nothing = pure Nothing</span>
<span class="lineno">  751 </span><span class="spaces"></span><span class="istickedoff">maybeOverGuarded f (Just x) = Just &lt;$&gt; f x</span></span>
<span class="lineno">  752 </span>
<span class="lineno">  753 </span>data TT a  -- (In order of increasing strictness. If you are unsure which to pick: just use MBE, it'll usually work fine)
<span class="lineno">  754 </span> = UNI a a -- find the union of these types, return it.
<span class="lineno">  755 </span> | ISC a a -- find the intersection of these types, return it.
<span class="lineno">  756 </span> | MBE a a -- must be equal: must be (made) of equal type. If these types are comparable, it returns the greatest.
<span class="lineno">  757 </span> | MBG a a -- The first of these types must be the greatest, if so, return it (error otherwise)
<span class="lineno">  758 </span> -- SJC: difference between UNI and MBE
<span class="lineno">  759 </span> -- in general, UNI is less strict than MBE:
<span class="lineno">  760 </span> --   suppose A ≤ C, B ≤ C, and C is the least such concept (e.g. if A≤D and B≤D then C≤D)
<span class="lineno">  761 </span> --   in this case UNI A B will yield C (if both A and B are generalizable), while MBE A B will give an error
<span class="lineno">  762 </span> --   note that in case of A ≤ C, B ≤ C, A ≤ D, B ≤ D (and there is no order between C and D), both will give an error
<span class="lineno">  763 </span> --   the error message, however, should be different:
<span class="lineno">  764 </span> --     for MBE it says that A and B must be of the same type, and suggests adding an order between A and B
<span class="lineno">  765 </span> --     for UNI it says that it cannot decide whether A \/ B is of type C or D, and suggests adding an order between C and D
<span class="lineno">  766 </span> --   In addition, MBE requires that both sides are not generalizable. UNI does not, and simply propagates this property.
<span class="lineno">  767 </span> -- MBG is like MBE, but will only try to generalize the right hand side (when allowed)
<span class="lineno">  768 </span>
<span class="lineno">  769 </span>deriv' :: (Applicative f)
<span class="lineno">  770 </span>       =&gt; ((SrcOrTgt, t -&gt; (Expression, (Bool, Bool))), (SrcOrTgt, t -&gt; (Expression, (Bool, Bool))))
<span class="lineno">  771 </span>       -&gt; t
<span class="lineno">  772 </span>       -&gt; f ((String, Bool), (String, Bool))
<span class="lineno">  773 </span><span class="decl"><span class="istickedoff">deriv' (a,b) es = let (sourceOrTarget1, (e1, t1)) = resolve es a</span>
<span class="lineno">  774 </span><span class="spaces">                      </span><span class="istickedoff">(sourceOrTarget2, (e2, t2)) = resolve es b</span>
<span class="lineno">  775 </span><span class="spaces">                  </span><span class="istickedoff">in pure ((<span class="nottickedoff">getConcept sourceOrTarget1 e1</span>, t1), (<span class="nottickedoff">getConcept sourceOrTarget2 e2</span>, t2))</span></span>
<span class="lineno">  776 </span>instance Functor TT where
<span class="lineno">  777 </span>  <span class="decl"><span class="istickedoff">fmap f (UNI a b) = UNI (f a) (f b)</span>
<span class="lineno">  778 </span><span class="spaces">  </span><span class="istickedoff">fmap f (ISC a b) = ISC (f a) (f b)</span>
<span class="lineno">  779 </span><span class="spaces">  </span><span class="istickedoff">fmap f (MBE a b) = MBE (f a) (f b)</span>
<span class="lineno">  780 </span><span class="spaces">  </span><span class="istickedoff">fmap f (MBG a b) = MBG (f a) (f b)</span></span>
<span class="lineno">  781 </span>  
<span class="lineno">  782 </span>-- TODO: would probably be better to return an A_Concept
<span class="lineno">  783 </span>getConcept :: SrcOrTgt -&gt; Expression -&gt; String
<span class="lineno">  784 </span><span class="decl"><span class="istickedoff">getConcept Src = name . source</span>
<span class="lineno">  785 </span><span class="spaces"></span><span class="istickedoff">getConcept Tgt = name . target</span></span>
<span class="lineno">  786 </span>

</pre>
</body>
</html>
